<?xml version="1.0"?>
<doc>
  <assembly>
    <name>C1.LiveLinq</name>
  </assembly>
  <members>
    <member name="T:C1.LiveLinq.IObservableSource`1">
      <summary>
            Provides methods and events that are required for LiveLinq functionality, indexing and live views.
            </summary>
      <remarks>
        <para>Indexing and live view functionality is available for any collection that supports change notifications
            necessary for maintaining indexes and live views,
            that is, fires events when an item is added to or removed from the collection and when a property of the item changes.
            So, the members of this interface are mostly concerned with providing such notifications.</para>
        <para>Classes implementing this interface usually also implement <see cref="T:C1.LiveLinq.Indexing.IIndexedSource`1" />.</para>
        <para>Both these interfaces are implemented by all main LiveLinq collection classes: <see cref="T:C1.LiveLinq.Collections.IndexedCollection`1" />,
            <see cref="T:C1.LiveLinq.AdoNet.IndexedDataTable`1" />, <see cref="T:C1.LiveLinq.LiveViews.View`1" />.</para>
        <para>You need to implement this interface only if you want to define your own indexable collection classes 
            and then only if they don't inherit from <see cref="T:C1.LiveLinq.Collections.IndexedCollection`1" />,
            see <span style="C1H Jump">LiveLinq to Objects: IndexedCollection(T) and other collection classes</span>.</para>
      </remarks>
      <typeparam name="T">The type of the elements in the collection.</typeparam>
    </member>
    <member name="M:C1.LiveLinq.IObservableSource`1.EnableItemOrdinals">
      <summary>
            After this method is called, the collection is required to provide <see cref="P:C1.LiveLinq.SourceChangeEventArgs`1.Ordinal" /> in event data.
            </summary>
    </member>
    <member name="E:C1.LiveLinq.IObservableSource`1.Changed">
      <summary>
            Occurs after an item of the collection or the entire collection has changed.
            </summary>
    </member>
    <member name="P:C1.LiveLinq.IObservableSource`1.SupportsItemOrdinals">
      <summary>
            Gets a value that indicates whether this collection is capable of providing the 
            ordinal position of the changed item when it notifies of an item change.
            </summary>
      <returns>
        <b>true</b> if the collection can provide item ordinal positions.</returns>
      <remarks>If this property returns <b>true</b>, LiveLinq can call the
            <see cref="M:C1.LiveLinq.IObservableSource`1.EnableItemOrdinals" /> method to require providing ordinals.</remarks>
    </member>
    <member name="P:C1.LiveLinq.IObservableSource`1.IsDeletedStateAvailable">
      <summary>
            Gets a value indicating whether an item of this collection can still return 
            correct property values after it has been deleted from the collection.
            </summary>
      <returns>
        <b>true</b> if deleted items can still be used to get property values.</returns>
      <seealso cref="T:C1.LiveLinq.DeletedStateIsAvailableAttribute" />
    </member>
    <member name="P:C1.LiveLinq.IObservableSource`1.CreateNew">
      <summary>
            This delegate is used to create new items.
            If it is null, a public parameterless constructor of type <b>T</b> is used.
            </summary>
    </member>
    <member name="T:C1.LiveLinq.ITransaction">
      <summary>
            Represents a transaction with an explicit scope.
            </summary>
    </member>
    <member name="M:C1.LiveLinq.ITransaction.Scope">
      <summary>
            Opens a transaction scope. 
            </summary>
      <remarks>
        <para>The transaction tracks changes only when they are made inside an open scope.</para>
        <para>Calling <see cref="M:System.IDisposable.Dispose" /> on the return value closes the scope.</para>
      </remarks>
      <returns>An instance of <see cref="T:System.IDisposable" /> that will close the scope 
            when its <see cref="M:System.IDisposable.Dispose" /> method is called.</returns>
    </member>
    <member name="M:C1.LiveLinq.ITransaction.Commit">
      <summary>
            Commits changes that were made while this transaction's scope was open.
            </summary>
    </member>
    <member name="M:C1.LiveLinq.ITransaction.Rollback">
      <summary>
            Rolls back changes that were made while this transaction's scope was open.
            </summary>
    </member>
    <member name="P:C1.LiveLinq.ITransaction.State">
      <summary>
            Gets the current state of the transaction.
            </summary>
    </member>
    <member name="P:C1.LiveLinq.ITransaction.HasChanges">
      <summary>
            Gets a value indicating whether any changes were made in the scope of this transaction.
            </summary>
    </member>
    <member name="T:C1.LiveLinq.TransactionState">
      <summary>
            Enumeration of the possible states an <see cref="T:C1.LiveLinq.ITransaction" /> can be in.
            </summary>
    </member>
    <member name="F:C1.LiveLinq.TransactionState.Open">
      <summary>
            A transaction is open.
            </summary>
      <remarks>Open state does not necessarily mean that a transaction scope is open.</remarks>
    </member>
    <member name="F:C1.LiveLinq.TransactionState.Committing">
      <summary>
            A transaction is in the process of being committed.
            </summary>
    </member>
    <member name="F:C1.LiveLinq.TransactionState.Committed">
      <summary>
            A transaction is committed.
            </summary>
    </member>
    <member name="F:C1.LiveLinq.TransactionState.RollingBack">
      <summary>
            A transaction is in the process of being rolled back.
            </summary>
    </member>
    <member name="F:C1.LiveLinq.TransactionState.RolledBack">
      <summary>
            A transaction is rolled back.
            </summary>
    </member>
    <member name="T:C1.LiveLinq.Listeners.PropertyChangeListener`1">
      <summary>
            Represents a listener object used by LiveLinq to receive notifications of changes to property values in a collection element object.
            </summary>
      <typeparam name="T">The type of the elements in the collection.</typeparam>
      <remarks>
        <para>In most cases, the default listener mechanism performs its function and does not need user intervention. As an advanced functionality,
            LiveLinq allows the user to customize default listeners. It may be needed in those rare cases when you use <see cref="T:C1.LiveLinq.Collections.IndexedCollection`1" />
            with element class <b>T</b> that does not provide property change notifications, and you can't add such notifications,
            nor by deriving the class from <see cref="T:C1.LiveLinq.Collections.IndexableObject" /> nor by other means, but you have some other way of knowing when property changes occur
            (maybe you can listen to some events, for example).</para>
        <para>Then you can define your own class derived from the base class <b>PropertyChangeListener&lt;T&gt;</b>
            and pass an object of that class to the <see cref="T:C1.LiveLinq.Collections.IndexedCollection`1" /> constructor.</para>
      </remarks>
      <summary>
            Represents a listener object used by LiveLinq to receive notifications of changes to property values in a collection element object.
            </summary>
    </member>
    <member name="M:C1.LiveLinq.Listeners.PropertyChangeListener`1.StartListening(`0)">
      <summary>Start listening to property changes in a particular object.</summary>
      <param name="item">The object to listen to.</param>
      <remarks>
            LiveLinq calls this method when a new object is added to a collection, so LiveLinq needs to be notified of changes to property values in that object.
            </remarks>
    </member>
    <member name="M:C1.LiveLinq.Listeners.PropertyChangeListener`1.StopListening(`0)">
      <summary>Stop listening to property changes in a particular object.</summary>
      <param name="item">The object to stop listening to.</param>
      <remarks>
            LiveLinq calls this method when an object is removed from a collection, so LiveLinq no longer needs to be notified of changes to property values in that object.
            </remarks>
    </member>
    <member name="M:C1.LiveLinq.Listeners.PropertyChangeListener`1.Clear">
      <summary>Stop listening to all, don't listen to any objects.</summary>
      <remarks>
            LiveLinq calls this method when a collection is cleared, all objects are removed from it, so it no longer needs to be notified of changes in any of those objects.
            </remarks>
    </member>
    <member name="M:C1.LiveLinq.Listeners.PropertyChangeListener`1.GetListeningProperties">
      <summary>Gets the list of property names for which change notifications are supported.</summary>
    </member>
    <member name="M:C1.LiveLinq.Listeners.PropertyChangeListener`1.CreateDefault">
      <summary>Creates the default listener used by LiveLinq to listen to property change notifications in objects of type <b>T</b>.</summary>
      <returns>The default listener handling property change notifications.</returns>
      <remarks>
        <para>For ADO.NET and XML objects (<b>DataRow</b>, <b>DataRowView</b>, <b>XContainer</b>), their corresponding property change notifications are used.</para>
        <para>For objects implementing <b>INotifyPropertyChanged</b> interface, that interface is used.</para>
        <para>If the class is neither of the above, the default listener 
            tries to use two change notification patterns if they are present in the class:</para>
        <list type="bullet">
          <item>events named <i>propertyName</i>Changed</item>
          <item>dependency properties of WPF classes</item>
        </list>
        <para>These patterns don't have to exist in the class, it's just a last ditch attempt of the default listener to find a
            notification mechanism if the standard one is not found.</para>
      </remarks>
    </member>
    <member name="E:C1.LiveLinq.Listeners.PropertyChangeListener`1.PropertyChanged">
      <summary>Occurs after a property has changed its value.</summary>
    </member>
    <member name="T:C1.LiveLinq.LiveViews.DataBindingMode">
      <summary>
            Enumeration of the possible data binding modes. It is used by the <see cref="P:C1.LiveLinq.LiveViews.View.DataBindingMode" /> property.
            </summary>
    </member>
    <member name="F:C1.LiveLinq.LiveViews.DataBindingMode.Default">
      <summary>
            The default mode, which is <see cref="F:C1.LiveLinq.LiveViews.DataBindingMode.WPF">WPF mode</see> in WPF applications and <see cref="F:C1.LiveLinq.LiveViews.DataBindingMode.WinForms">WinForms mode</see> in WinForms applications.
            </summary>
    </member>
    <member name="F:C1.LiveLinq.LiveViews.DataBindingMode.WPF">
      <summary>
            In data binding to a <see cref="T:C1.LiveLinq.LiveViews.View" />, view items (elements of the <see cref="T:C1.LiveLinq.LiveViews.View" /> itself as a collection) are used for data binding.
            </summary>
    </member>
    <member name="F:C1.LiveLinq.LiveViews.DataBindingMode.WinForms">
      <summary>
            In data binding to a <see cref="T:C1.LiveLinq.LiveViews.View" />, view rows (elements of the <see cref="P:C1.LiveLinq.LiveViews.View.Rows" /> collection) are used for data binding.
            </summary>
    </member>
    <member name="T:C1.LiveLinq.LiveViews.PropertyIsNotVirtualException">
      <summary>Represents an exception that indicates that a property used in a result selector of a live view is not virtual.</summary>
    </member>
    <member name="M:C1.LiveLinq.LiveViews.PropertyIsNotVirtualException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Initializes a new instance of the <see cref="T:C1.LiveLinq.LiveViews.PropertyIsNotVirtualException" /> class with serialized data.
            </summary>
      <param name="info">
            The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> that holds the serialized object data about the exception being thrown.
            </param>
      <param name="context">
            The <see cref="T:System.Runtime.Serialization.StreamingContext" /> that contains contextual information about the source or destination.
            </param>
    </member>
    <member name="P:C1.LiveLinq.LiveViews.PropertyIsNotVirtualException.Property">
      <summary>
            The non-virtual property.
            </summary>
    </member>
    <member name="P:C1.LiveLinq.LiveViews.PropertyIsNotVirtualException.Context">
      <summary>
            Lambda expression where a type with the non-virtual property is used.
            </summary>
    </member>
    <member name="P:C1.LiveLinq.LiveViews.PropertyIsNotVirtualException.ResultType">
      <summary>
            The result type of the lambda expression.
            </summary>
    </member>
    <member name="P:C1.LiveLinq.LiveViews.PropertyIsNotVirtualException.Message">
      <summary>
            Gets a message that describes the current exception.
            </summary>
      <returns>
            The error message that explains the reason for the exception.
            </returns>
    </member>
    <member name="T:C1.LiveLinq.LiveViews.ViewRow">
      <summary>Represents a view element (item) for the purposes of dynamic, programmatic access to its properties and data binding.</summary>
      <seealso cref="P:C1.LiveLinq.LiveViews.View.Rows" />
    </member>
    <member name="T:C1.LiveLinq.Collections.IndexableObject">
      <summary> Base class for collection element classes.</summary>
      <remarks>
            Using <see cref="T:C1.LiveLinq.Collections.IndexedCollection`1" /> and
            <span style="C1H Jump">other collection classes|tag=LiveLinq to Objects: IndexedCollection(T) and other collection classes</span>
            in LiveLinq to Objects, the element class <b>T</b> must implement the property change notification interface
            <see cref="T:System.ComponentModel.INotifyPropertyChanged" />.
            The easiest way to satisfy this requirement is to derive that class from
            <b>IndexableObject</b>. Then you can use its method <see cref="M:C1.LiveLinq.Collections.IndexableObject.OnPropertyChanged(System.String)" />
            to send the required property change notifications. For example, a <b>Customer</b> class can be defined like this:
            <code>
            public class Customer : IndexableObject
            {
            .....................
                private string _name;
                public string Name
                {
                    get { return _name; }
                    set
                    {
                        _name = value;
                        OnPropertyChanged("Name");
                    }
                }
            .....................
            }
            </code></remarks>
    </member>
    <member name="M:C1.LiveLinq.Collections.IndexableObject.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:C1.LiveLinq.Collections.IndexableObject" /> class.
            </summary>
    </member>
    <member name="M:C1.LiveLinq.Collections.IndexableObject.OnPropertyChanged(System.String)">
      <summary>
            Raises the <see cref="E:C1.LiveLinq.Collections.IndexableObject.PropertyChanged" /> event.
            </summary>
      <param name="propertyName">The name of the property that is changed.</param>
    </member>
    <member name="E:C1.LiveLinq.Collections.IndexableObject.PropertyChanged">
      <summary>
            Occurs when a property value changes, after it has been changed.
            </summary>
    </member>
    <member name="M:C1.LiveLinq.LiveViews.ViewRow.OnPropertyChanged(System.String)">
      <summary>
            Raises the <see cref="E:System.ComponentModel.INotifyPropertyChanged.PropertyChanged" /> event.
            </summary>
      <param name="propertyName">The name of the property that is changed.</param>
    </member>
    <member name="M:C1.LiveLinq.LiveViews.ViewRow.BeginEdit">
      <summary>Puts the <see cref="T:C1.LiveLinq.LiveViews.ViewRow" /> into edit mode.</summary>
      <remarks>
        <para>In edit mode, events and notifications are temporarily suspended, letting the user make changes to more than one property
             without triggering validation rules.</para>
        <para>Edit mode is a standard feature of .NET data binding mechanism, supported by every data source 
             implementing the <see cref="T:System.ComponentModel.IEditableObject" /> interface. For detailed explanation, see, for example, <see cref="T:System.Data.DataRowView" />
             in .NET Framework documentation.</para>
        <para> While a view item is in edit mode, changes made to its updatable properties directly in the view are not propagated
             to the corresponding base data properties until the edit operation is completed by a call to <see cref="M:C1.LiveLinq.LiveViews.ViewRow.EndEdit" />
             (see <see cref="P:C1.LiveLinq.LiveViews.View.IsReadOnly" /> about updatability of view element properties directly in the view).</para>
        <para>If you change  base data (source) properties, those changes are propagated to this view and other views depending
             on that base data according to the normal view maintenance process, regardless
             of whether the view row is in edit mode or not.</para>
        <para>Many-to-one relations between view properties are maintained automatically on changes made to updatable 
             properties directly in the view, regardless of whether the view row is in edit mode or not. For example, if you set a CustomerID
             directly in the view, CustomerName will change accordingly, even if you do it in edit mode.</para>
      </remarks>
    </member>
    <member name="M:C1.LiveLinq.LiveViews.ViewRow.EndEdit">
      <summary>Ends the edit occurring on the row.</summary>
      <remarks>
        <para>If the user set some of the updatable properties of the row while it was in edit mode, the changes to those properties are
            propagated to the corresponding base data properties at this point.</para>
        <para>See the <see cref="M:C1.LiveLinq.LiveViews.ViewRow.BeginEdit" /> method for more information.</para>
      </remarks>
    </member>
    <member name="M:C1.LiveLinq.LiveViews.ViewRow.CancelEdit">
      <summary>Cancels the edit occurring on the row.</summary>
      <remarks>
        <para>If the user set some of the updatable properties of the row while it was in edit mode, the changes to those properties are
            rolled back and not propagated to the corresponding base data properties.</para>
        <para>See the <see cref="M:C1.LiveLinq.LiveViews.ViewRow.BeginEdit" /> method for more information.</para>
      </remarks>
    </member>
    <member name="M:C1.LiveLinq.LiveViews.ViewRow.Delete">
      <summary>Deletes a view item.</summary>
      <remarks>
            Deleting a view item is an update operation on the view. As any other update operation performed directly on the
            view (as opposed to on the base data collection on which that view depends,
            see <see cref="M:C1.LiveLinq.LiveViewExtensions.AsUpdatable``1(C1.LiveLinq.LiveViews.View{``0})" />), it is allowed only if the view
            is not read-only (see <see cref="P:C1.LiveLinq.LiveViews.View.IsReadOnly" />), and it results in updating (in this case, deleting an item from)
            one of the view's base data collections.
            </remarks>
    </member>
    <member name="M:C1.LiveLinq.LiveViews.ViewRow.ToString">
      <summary>Gets the string representing this view row.</summary>
    </member>
    <member name="E:C1.LiveLinq.LiveViews.ViewRow.PropertyChanged">
      <summary>
            Occurs when a property value changes, after it has been changed.
            </summary>
    </member>
    <member name="P:C1.LiveLinq.LiveViews.ViewRow.View">
      <summary>Gets the view to which the <see cref="T:C1.LiveLinq.LiveViews.ViewRow" /> belongs.</summary>
    </member>
    <member name="P:C1.LiveLinq.LiveViews.ViewRow.Value">
      <summary>Gets the view element (item) represented by this <see cref="T:C1.LiveLinq.LiveViews.ViewRow" /> object.</summary>
    </member>
    <member name="P:C1.LiveLinq.LiveViews.ViewRow.Tag">
      <summary>Gets or sets user-supplied data associated with the view item.</summary>
      <remarks>
            Use this property to store any object you want to associate in your code with the view item that you need to access quickly.
            </remarks>
    </member>
    <member name="P:C1.LiveLinq.LiveViews.ViewRow.RowState">
      <summary>Gets the state of a view row with regard to edit, add and delete operations if they are performed directly on the view.</summary>
    </member>
    <member name="P:C1.LiveLinq.LiveViews.ViewRow.Item(System.Int32)">
      <summary>Gets or sets a value of the specified view property.</summary>
      <param name="propertyOrdinal">The ordinal position of the property in the collection of public properties of the type of the view element.</param>
      <returns>The value of the property.</returns>
      <remarks>
        <para>Setting a view property is an update operation on the view. As any other update operation performed directly on the
            view (as opposed to on the base data collection on which that view depends,
            see <see cref="M:C1.LiveLinq.LiveViewExtensions.AsUpdatable``1(C1.LiveLinq.LiveViews.View{``0})" />), it is allowed only if the view
            is not read-only (see <see cref="P:C1.LiveLinq.LiveViews.View.IsReadOnly" />), and it results in updating 
            one of the view's base data collections.</para>
        <para>Only updatable properties can be set. An attempt to set a read-only property results in an exception.
            See <see cref="P:C1.LiveLinq.LiveViews.View.IsReadOnly" /> for more details.</para>
      </remarks>
    </member>
    <member name="P:C1.LiveLinq.LiveViews.ViewRow.Item(System.String)">
      <summary>Gets or sets a value of the specified view property.</summary>
      <param name="propertyName">The name of the property.</param>
      <returns>The value of the property.</returns>
      <remarks>
        <para>Setting a view property is an update operation on the view. As any other update operation performed directly on the
            view (as opposed to on the base data collection on which that view depends,
            see <see cref="M:C1.LiveLinq.LiveViewExtensions.AsUpdatable``1(C1.LiveLinq.LiveViews.View{``0})" />), it is allowed only if the view
            is not read-only (see <see cref="P:C1.LiveLinq.LiveViews.View.IsReadOnly" />), and it results in updating 
            one of the view's base data collections.</para>
        <para>Only updatable properties can be set. An attempt to set a read-only property results in an exception.
            See <see cref="P:C1.LiveLinq.LiveViews.View.IsReadOnly" /> for more details.</para>
      </remarks>
    </member>
    <member name="T:C1.LiveLinq.LiveViews.View">
      <summary>Base class for the <see cref="T:C1.LiveLinq.LiveViews.View`1"></see> class. Contains members that don't depend on the element type <i>T</i>.</summary>
      <remarks>
            Use this class to type variables that can accept views with different element types or a view with anonymous element type.
            </remarks>
    </member>
    <member name="M:C1.LiveLinq.LiveViews.View.AsCollectionViewFactory">
      <summary>
            Returns an instance of <see cref="T:System.ComponentModel.ICollectionViewFactory" /> that can be used as a 
            source of a <see cref="T:System.Windows.Data.CollectionViewSource" />.
            </summary>
      <returns>A factory that returns the same View as a <see cref="T:System.ComponentModel.ICollectionView" />.</returns>
    </member>
    <member name="M:C1.LiveLinq.LiveViews.View.AllowInResult(System.Type)">
      <summary>
            Specifies that a type with non-virtual properties can be used in a result selector.
            </summary>
      <param name="type">The type that is allowed to be used.</param>
    </member>
    <member name="M:C1.LiveLinq.LiveViews.View.AsDynamic">
      <summary>
            Used for views with anonymous type constructor as the result selector, 
            converts the <see cref="T:C1.LiveLinq.LiveViews.View" /> to a View&lt;dynamic&gt; so it can be used for data binding and programmatic access.
            </summary>
      <remarks>
            A view with anonymous type constructor as the result selector cannot be used for data binding or programmatic access without
            applying <see cref="M:C1.LiveLinq.LiveViews.View.AsDynamic" /> to it. An attempt to do so results in an exception. After applying <see cref="M:C1.LiveLinq.LiveViews.View.AsDynamic" />,
            such view can be used for data binding and programmatic access without limitations.
            </remarks>
      <returns>A dynamic view.</returns>
    </member>
    <member name="M:C1.LiveLinq.LiveViews.View.SetTransaction(C1.LiveLinq.ITransaction,System.Boolean)">
      <summary>
            Sets the value of the <see cref="P:C1.LiveLinq.LiveViews.View.Transaction" /> property.
            </summary>
      <remarks>
            If a writable property path exists in the view element type (for example, <code>Order.Customer.City</code>), then an exception is thrown
            unless suppressed by setting <paramref name="allowPropertyPaths" /> to True, 
            because modifying properties using such paths cannot be supported by transactions. 
            To prevent the exception, set the <paramref name="allowPropertyPaths" /> parameter to True,
            but make sure you do not use such property paths in your code and don't have a two-way data binding to such property path in your controls.
            If you modify a property using such path in your code or through data binding, that modification happens outside the transaction scope.
            </remarks>
      <param name="transaction">The new value for the the <see cref="P:C1.LiveLinq.LiveViews.View.Transaction" /> property.</param>
      <param name="allowPropertyPaths">
            Set this parameter to True to prevent exception if you have writable property paths and want to ignore them
            (but be aware that updates through property paths are not tracked by the transaction). The default is False.
            </param>
    </member>
    <member name="M:C1.LiveLinq.LiveViews.View.Rebuild">
      <summary>Re-populates the view by re-executing the view's query.</summary>
      <remarks>
            This method is rarely needed, because normally automatic incremental <see cref="M:C1.LiveLinq.LiveViews.View.Maintain">maintenance</see> is
            faster than re-executing the query over the entire base data collection. However, if for some reason you need
            to re-populate it from scratch, that can be done with the <b>Rebuild</b> method.
            </remarks>
    </member>
    <member name="M:C1.LiveLinq.LiveViews.View.Maintain">
      <summary>Brings the view up to date with its source data.</summary>
      <remarks>
        <para>If source data have not changed since the last 
            time the view was maintained (updated), this method does nothing. It also does nothing if the view's
            <see cref="P:C1.LiveLinq.LiveViews.View.MaintenanceMode" /> is <b>Immediate</b>, because in that case the view is guaranteed to be
            in synch with its base data at all times. If the view is in deferred mode (its <see cref="P:C1.LiveLinq.LiveViews.View.MaintenanceMode" /> property
            returns <b>true</b>), the programmer can use the <b>Maintain</b> method to force updating the view.</para>
        <para>Note that it is not necessary to call <b>Maintain</b> to make sure you get updated data from the view.
            The view is automatically updated every time you request data from it, if base data changed since the last request,
            regardless of the view's <see cref="P:C1.LiveLinq.LiveViews.View.MaintenanceMode" />.</para>
        <para>LiveLinq maintains views using optimized incremental algorithms, not simply re-populates them from scratch.
            It calculating the delta in the view from the delta in the base data. In most cases, it allows to propagate 
            the change from base data to the view very fast.</para>
      </remarks>
    </member>
    <member name="M:C1.LiveLinq.LiveViews.View.PurgeEmptyGroups">
      <summary>Remove empty groups from a grouping view.</summary>
      <remarks>
        <para>This method is used only for <b>GroupBy</b> (grouping) views, does nothing for views of other kinds.</para>
        <para>When a grouping view is populated, it does not contain empty groups. But later, as a result of maintaining the grouping view,
             keeping it in synch with changes in its base data, some of the groups can become empty. If it is undesirable to have
             empty groups, you can call this method to delete them.</para>
      </remarks>
    </member>
    <member name="M:C1.LiveLinq.LiveViews.View.DeferMaintenance">
      <summary>
            Enters a defer cycle that you can use to make bulk changes to the view sources and delay automatic view maintenance.
            </summary>
      <returns>
            An <see cref="T:System.IDisposable" /> object that you can use to dispose of the calling object.
            </returns>
    </member>
    <member name="P:C1.LiveLinq.LiveViews.View.CurrentItem">
      <summary>
            Gets the current item in the view.
            </summary>
    </member>
    <member name="P:C1.LiveLinq.LiveViews.View.Rows">
      <summary>Gets the collection of <see cref="T:C1.LiveLinq.LiveViews.ViewRow" /> objects used for programmatic access to view elements (items) and for data binding.</summary>
      <remarks>
        <para>There can be a view with elements of any type <i>T</i>, as represented by the generic class <see cref="T:C1.LiveLinq.LiveViews.View`1" />.
            That type is not always known beforehand, so it is not always possible to access
            properties of view elements with strong-typed (early binding) code. Dynamic (untyped, late binding) access to view elements is
            provided by the <see cref="T:C1.LiveLinq.LiveViews.ViewRowCollection" /> owned by the view.</para>
        <para>The collection of <i>view rows</i> (<see cref="T:C1.LiveLinq.LiveViews.ViewRow" /> objects)
            is always synchronized with the collection of view elements.
            <see cref="T:C1.LiveLinq.LiveViews.ViewRow" /> objects provide programmatic access to view elements and their properties.</para>
        <para>Also, in WinForms, the <b>Rows</b> collection serves as the data source for data binding, when you bind a control or another client to a view,
            because a view returns its <b>Rows</b> collection in its implementation of the <see cref="T:System.ComponentModel.IListSource" /> interface.</para>
      </remarks>
    </member>
    <member name="P:C1.LiveLinq.LiveViews.View.Order">
      <summary>Gets a value indicating whether and how this view preserves item order if it exists in its base data source.</summary>
    </member>
    <member name="P:C1.LiveLinq.LiveViews.View.Count">
      <summary>Gets the total number of elements in the view.</summary>
    </member>
    <member name="P:C1.LiveLinq.LiveViews.View.IsReadOnly">
      <summary>Gets a value indicating whether this view is read-only, not updatable.</summary>
      <remarks>
        <para>Properties exposed by a view can be updatable or read-only. Updatable properties of a view can be modified directly in the view.</para>
        <para>All properties of a read-only (not updatable) view are read-only.
            In an updatable view, properties directly corresponding to base data (source) properties are updatable,
            calculated properties are read-only.
            For example, in a view
            <code>
            from x in X
            select new { x.P, Q = x.Q + 1 }
            </code>
            P is updatable and Q is read-only.</para>
        <para>Read-only properties of a view cannot be modified directly in the view, but they still reflect up-to-date values of the source,
            so the difference is often not critical, you can always modify corresponding property in the source, that
            will automatically change the property in the view.</para>
        <para>Also, a read-only view cannot be cleared or its rows deleted or new rows added directly in the view
            (but all these actions can be performed on the source data collection and they will normally result 
            in the corresponding changes of the view).</para>
        <para>A <b>Join</b> view is read-only by default, but one of its two parts can be made updatable using the <see cref="M:C1.LiveLinq.LiveViewExtensions.AsUpdatable``1(C1.LiveLinq.LiveViews.View{``0})" /> method.</para>
      </remarks>
      <seealso cref="M:C1.LiveLinq.LiveViewExtensions.AsUpdatable``1(C1.LiveLinq.LiveViews.View{``0})" />
      <seealso cref="T:C1.LiveLinq.LiveViews.ViewRow" />
      <seealso cref="T:C1.LiveLinq.LiveViews.ViewRowState" />
    </member>
    <member name="P:C1.LiveLinq.LiveViews.View.DataBindingMode">
      <summary>
            Gets or sets the data binding mode for this view.
            </summary>
      <seealso cref="P:C1.LiveLinq.LiveViews.View.DataBindingMode">DataBindingMode enumeration.</seealso>
    </member>
    <member name="P:C1.LiveLinq.LiveViews.View.Transaction">
      <summary>
            Gets an instance of <see cref="T:C1.LiveLinq.ITransaction" /> associated with the view.
            If a view has a transaction associated with it, that transaction's scope is opened automatically
            every time the view is updated, so the programmer does not need to do it manually in code.
            </summary>
    </member>
    <member name="P:C1.LiveLinq.LiveViews.View.MoveToFirstOnReset">
      <summary>
            Gets or sets a value indicating that the first item must be made current after initial loading or reset
            (on any <see cref="F:C1.LiveLinq.SourceChangeType.Reset" /> notification) if current item was not set by other means. The default is True.
            </summary>
    </member>
    <member name="P:C1.LiveLinq.LiveViews.View.MaintenanceMode">
      <summary>Gets or sets a value controlling how the view is synchronized with changes in its base data.</summary>
      <remarks>
        <para>A view in <b>Default</b> mode (which is the default value for this property) is effectively in <b>Immediate</b> mode 
            if it has a listener (for example, if a GUI control is bound to it); otherwise it is in <b>Deferred</b> mode.
            To find out whether the view is effectively in <b>Deferred</b> or in <b>Immediate</b> mode,
            you can use the <see cref="P:C1.LiveLinq.LiveViews.View.DeferredMaintenance" /> property.</para>
        <para>If you set this property to <b>Deferred</b>, no listeners are allowed to register with this view.
            An attempt to register a listener will result in an exception.</para>
        <para>
          <b>See Also:</b>
          <span style="C1H Jump">View Maintenance Mode</span>.</para>
      </remarks>
      <seealso cref="P:C1.LiveLinq.LiveViews.View.DeferredMaintenance" />
    </member>
    <member name="P:C1.LiveLinq.LiveViews.View.DeferredMaintenance">
      <summary>Gets the effective value of MaintenanceMode. </summary>
      <returns>
        <b>true</b> if <see cref="P:C1.LiveLinq.LiveViews.View.MaintenanceMode" /> is set to <b>Deferred</b>, or if it is set to <b>Default</b>
            and no listeners are registered with this view.</returns>
    </member>
    <member name="T:C1.LiveLinq.LiveViews.View`1">
      <summary>Represents a <i>live view</i>: a LINQ query result that supports two-way data binding and is kept up-to-date with base data.</summary>
      <typeparam name="T">The type of the elements in the view.</typeparam>
    </member>
    <member name="T:C1.LiveLinq.Indexing.IIndexedSource`1">
      <summary>Represents an indexed collection.</summary>
      <typeparam name="T">The type of the elements of the collection.</typeparam>
      <remarks>
        <para>An indexed collection has a collection of indexes, <see cref="T:C1.LiveLinq.Indexing.ScannerCollection`1" /> that are maintained
            up-to-date on every change made to the collection.</para>
        <para>This interface is implemented by all main LiveLinq collection classes: <see cref="T:C1.LiveLinq.Collections.IndexedCollection`1" />,
            <see cref="T:C1.LiveLinq.AdoNet.IndexedDataTable`1" />, <see cref="T:C1.LiveLinq.LiveViews.View`1" />.</para>
        <para>You need to implement this interface only if you want to define your own indexable collection classes 
            and then only if they don't inherit from <see cref="T:C1.LiveLinq.Collections.IndexedCollection`1" />,
            see <span style="C1H Jump">LiveLinq to Objects: IndexedCollection(T) and other collection classes</span>.</para>
      </remarks>
    </member>
    <member name="P:C1.LiveLinq.Indexing.IIndexedSource`1.Indexes">
      <summary>Gets the collection of indexes attached to this collection.</summary>
      <value>A collection of indexes attached to this collection. If this is an independent collection, not the result of 
            a LiveLinq indexing search, then its <see cref="P:C1.LiveLinq.Indexing.IIndexedSource`1.Indexes" />
            collection contains <see cref="T:C1.LiveLinq.Indexing.Index`1" /> objects. Otherwise, that is, if it is the result of an indexing search
            operation such as <see cref="M:C1.LiveLinq.Indexing.Index`1.Find(System.Object)">Index.Find</see> and others, it contains 
            subindexes implementing <see cref="T:C1.LiveLinq.Indexing.Search.IIndexScanner`1" />.
            </value>
    </member>
    <member name="M:C1.LiveLinq.LiveViews.View`1.GetEnumerator">
      <summary>Returns an enumerator that iterates through the view items.</summary>
    </member>
    <member name="M:C1.LiveLinq.LiveViews.View`1.Contains(`0)">
      <summary>Determines whether the view contains a specified item.</summary>
      <param name="item">The item to locate in the view.</param>
      <returns>
        <b>true</b> if the view contains the specified item; otherwise, <b>false</b>.</returns>
    </member>
    <member name="M:C1.LiveLinq.LiveViews.View`1.IndexOf(`0)">
      <summary>
            Searches for the specified object among the elements of the view and returns the zero-based ordinal position of its first occurrence.
            </summary>
      <param name="item">The object to locate in the view.</param>
      <returns>The zero-based ordinal position of the first occurrence of <i>item</i> in the view, if found; otherwise, -1.</returns>
    </member>
    <member name="M:C1.LiveLinq.LiveViews.View`1.Select``1(System.Linq.Expressions.Expression{System.Func{`0,``0}})">
      <summary>Projects each element of a view into a new form.</summary>
      <typeparam name="TResult">The type of the value returned by <i>selector</i>.</typeparam>
      <param name="selector">A transform function to apply to each element.</param>
      <returns>A view whose elements are the result of invoking the transform function on each element of this view.</returns>
    </member>
    <member name="M:C1.LiveLinq.LiveViews.View`1.Where(System.Linq.Expressions.Expression{System.Func{`0,System.Boolean}})">
      <summary>Filters the source view based on a predicate.</summary>
      <param name="predicate">A function to test each element for a condition.</param>
      <returns>A view that contains elements of this view that satisfy the condition.</returns>
    </member>
    <member name="M:C1.LiveLinq.LiveViews.View`1.Join``3(C1.LiveLinq.IObservableSource{``0},System.Linq.Expressions.Expression{System.Func{`0,``1}},System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Linq.Expressions.Expression{System.Func{`0,``0,``2}})">
      <summary>Correlates the elements of two views based on matching keys.</summary>
      <typeparam name="TInner">The type of the elements of the view to join with this view.</typeparam>
      <typeparam name="TKey">The type of the keys returned by the key selector functions.</typeparam>
      <typeparam name="TResult">The type of the result elements.</typeparam>
      <param name="inner">The collection (usually, a view) to join to this view.</param>
      <param name="outerKeySelector">A function to extract the join key from each element of this view.</param>
      <param name="innerKeySelector">A function to extract the join key from each element of the second view.</param>
      <param name="resultSelector">A function to create a result element from two matching elements.</param>
      <returns>A view containing elements of type <i>TResult</i> that are obtained by performing an inner join on two views.</returns>
    </member>
    <member name="M:C1.LiveLinq.LiveViews.View`1.GroupJoin``3(C1.LiveLinq.IObservableSource{``0},System.Linq.Expressions.Expression{System.Func{`0,``1}},System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Linq.Expressions.Expression{System.Func{`0,C1.LiveLinq.LiveViews.GroupView{``1,``0},``2}})">
      <summary>Correlates the elements of two views based on equality of keys and groups the results.</summary>
      <typeparam name="TInner">The type of the elements of the view to join with this view.</typeparam>
      <typeparam name="TKey">The type of the keys returned by the key selector functions.</typeparam>
      <typeparam name="TResult">The type of the result elements.</typeparam>
      <param name="inner">The collection (usually, a view) to join to this view.</param>
      <param name="outerKeySelector">A function to extract the join key from each element of this view.</param>
      <param name="innerKeySelector">A function to extract the join key from each element of the second view.</param>
      <param name="resultSelector">A function to create a result view from an element 
            from this view and a collection of matching elements from the second view.</param>
      <returns>A view containing elements of type <i>TResult</i>
            that are obtained by performing a grouped join on two views.</returns>
    </member>
    <member name="M:C1.LiveLinq.LiveViews.View`1.OrderBy``1(System.Linq.Expressions.Expression{System.Func{`0,``0}})">
      <summary>Sorts the elements of a view in ascending order.</summary>
      <typeparam name="TKey">The type of the key returned by <i>keySelector</i>.</typeparam>
      <param name="keySelector">A function to extract a key from an element.</param>
      <returns>A view whose elements are sorted according to a key.</returns>
    </member>
    <member name="M:C1.LiveLinq.LiveViews.View`1.OrderByDescending``1(System.Linq.Expressions.Expression{System.Func{`0,``0}})">
      <summary>Sorts the elements of a view in descending order.</summary>
      <typeparam name="TKey">The type of the key returned by <i>keySelector</i>.</typeparam>
      <param name="keySelector">A function to extract a key from an element.</param>
      <returns>A view whose elements are sorted in descending order according to a key.</returns>
    </member>
    <member name="M:C1.LiveLinq.LiveViews.View`1.GroupBy``1(System.Linq.Expressions.Expression{System.Func{`0,``0}})">
      <summary>Groups the elements of a view according to a specified key selector function.</summary>
      <typeparam name="TKey">The type of the key returned by <i>keySelector</i>.</typeparam>
      <param name="keySelector">A function to extract the key for each element.</param>
      <returns>A view containing elements of type <see cref="T:C1.LiveLinq.LiveViews.GroupView`2" /> each containing a key value
            and a view of the elements having that key value.</returns>
    </member>
    <member name="M:C1.LiveLinq.LiveViews.View`1.GroupBy``2(System.Linq.Expressions.Expression{System.Func{`0,``0}},System.Linq.Expressions.Expression{System.Func{`0,``1}})">
      <summary>
            Groups the elements of a view according to a specified key selector function
            and projects the elements for each group by using a specified function.
            </summary>
      <typeparam name="TKey">The type of the key returned by <i>keySelector</i>.</typeparam>
      <typeparam name="TElement">The type of the element to which elements of each group are projected.</typeparam>
      <param name="keySelector">A function to extract the key for each element.</param>
      <param name="elementSelector">A function to map each source element to a <i>TElement</i>.</param>
      <returns>A view containing elements of type <see cref="T:C1.LiveLinq.LiveViews.GroupView`2" /> each containing a key value
            and a view of the elements projected (mapped) from the elements having that key value.</returns>
    </member>
    <member name="M:C1.LiveLinq.LiveViews.View`1.GroupBy``3(System.Linq.Expressions.Expression{System.Func{`0,``0}},System.Linq.Expressions.Expression{System.Func{`0,``1}},System.Linq.Expressions.Expression{System.Func{``0,System.Collections.Generic.IEnumerable{``1},``2}})">
      <summary>
            Groups the elements of a view according to a specified key selector function 
            and creates a result value from each group and its key. 
            The elements of each group are projected by using a specified function. 
            </summary>
      <typeparam name="TKey">The type of the key returned by <i>keySelector</i>.</typeparam>
      <typeparam name="TElement">The type of the elements in groups.</typeparam>
      <typeparam name="TResult">The type of the result value returned by <i>resultSelector</i>.</typeparam>
      <param name="keySelector">A function to extract the key for each element.</param>
      <param name="elementSelector">A function to map each source element to an element in the <see cref="T:System.Linq.IGrouping`2" />.</param>
      <param name="resultSelector">A function to create a result value from each group.</param>
      <returns>A view of elements of type <i>TResult</i> where each element represents a projection over a group and its key.</returns>
    </member>
    <member name="M:C1.LiveLinq.LiveViews.View`1.SelectMany``2(System.Linq.Expressions.Expression{System.Func{`0,C1.LiveLinq.IObservableSource{``0}}},System.Linq.Expressions.Expression{System.Func{`0,``0,``1}})">
      <summary>
            Projects each element of this view to a collection of collections, flattens the resulting collections into one collection,
            and invokes a result selector function on each element therein.
            </summary>
      <typeparam name="TCollection">The type of the intermediate elements collected by <i>collectionSelector</i>.</typeparam>
      <typeparam name="TResult">The type of the elements of the resulting view.</typeparam>
      <param name="collectionSelector">A transform function to apply to each element of this view.</param>
      <param name="resultSelector">A transform function to apply to each element of the intermediate collection.</param>
      <returns>A view whose elements are the result of invoking the one-to-many transform function
            <i>collectionSelector</i> on each element of this view and then mapping each of those collection elements and their
            corresponding source element to a result element.</returns>
    </member>
    <member name="M:C1.LiveLinq.LiveViews.View`1.SelectMany``1(System.Linq.Expressions.Expression{System.Func{`0,C1.LiveLinq.IObservableSource{``0}}})">
      <summary>
            Projects each element of this view to a collection of <i>TResult</i> and flattens the resulting collections into one view.
            </summary>
      <typeparam name="TResult">The type of the elements of the resulting view.</typeparam>
      <param name="selector">A transform function to apply to each element.</param>
      <returns>A view whose elements are the result of invoking the one-to-many transform function on each element of this view.</returns>
    </member>
    <member name="M:C1.LiveLinq.LiveViews.View`1.Concat(C1.LiveLinq.IObservableSource{`0})">
      <summary>Concatenation of two views.</summary>
      <param name="second">A collection (usually, a view) to concatenate to this view's collection of elements.</param>
      <returns>The view that contains first the elements of this view and then the elements of the parameter collection.</returns>
    </member>
    <member name="M:C1.LiveLinq.LiveViews.View`1.Union(C1.LiveLinq.IObservableSource{`0})">
      <summary>Set union of two views.</summary>
      <param name="second">A collection (usually, a view) whose distinct elements form the second set for the union.</param>
      <returns>The view that contains the elements from both input views, excluding duplicates.</returns>
      <remarks>This method excludes duplicates from the result set. This is different behavior to
            the <see cref="M:C1.LiveLinq.LiveViews.View`1.Concat(C1.LiveLinq.IObservableSource{`0})" /> method, which returns all the elements in the input sequences including duplicates.
            </remarks>
    </member>
    <member name="M:C1.LiveLinq.LiveViews.View`1.AttachView``1(System.Func{C1.LiveLinq.LiveViews.View{`0},C1.LiveLinq.LiveViews.View{``0}})">
      <summary>Includes a subquery into the incremental maintenance mechanism of a view.</summary>
      <typeparam name="TResult">The type of the elements in the subquery view.</typeparam>
      <param name="selector">A function to obtain the attached subview from the view to which it is attached.</param>
      <returns>The attached subview.</returns>
      <remarks>
        <para>Subquery is a query inside a function that is a part of an outer query.
             If the outer query is a live view, and its base data changes so it needs to recompute the function,
             by default it just evaluates the function, which means creating a new view object for the subquery on every such recomputation.
             To improve performance by avoiding repeated creation and population of subviews, use the <b>AttachView</b> method to make the
             outer view aware of its subview. Then the outer view will cache and reuse subview objects it creates.</para>
        <para>If there are more than one subviews attached to a single view, every 
             subview must be supplied with a unique <i>subview id</i> by using the <b>AttachView</b> overload with <i>subviewId</i> parameter.</para>
        <example>
          <code>
             var productView =
                 from p in products
                 join s in sales on p.ProductID equals s.ProductID into productSales
                 select new
                 {
                     p.Name,
                     SalesByCountry = productSales.AttachView(v =&gt;
                         from s in v
                         group s by s.Country into countrySales
                         select new
                         {
                             Country = countrySales.Key,
                             SaleCount = countrySales.LiveSum(s =&gt; s.Quantity).Value
                         })
                 };
            </code>
        </example>
      </remarks>
      <seealso cref="M:C1.LiveLinq.LiveViews.View`1.AttachAggregationView``1(System.Func{C1.LiveLinq.LiveViews.View{`0},C1.LiveLinq.LiveViews.AggregationView{`0,``0}})" />
    </member>
    <member name="M:C1.LiveLinq.LiveViews.View`1.AttachView``1(System.Object,System.Func{C1.LiveLinq.LiveViews.View{`0},C1.LiveLinq.LiveViews.View{``0}})">
      <summary>Includes a subquery into the incremental maintenance mechanism of a view and uniquely identifies it among other subqueries of the same view.</summary>
      <typeparam name="TResult">The type of the elements in the subquery view.</typeparam>
      <param name="subqueryId">A string uniquely specifying this subquery in the view to which it is attached. Can be any string.
            The only requirement is that different subqueries attached to the same view, if such exist, must have different subquery ids.</param>
      <param name="selector">A function to obtain the attached subview from the view to which it is attached.</param>
      <returns>The attached subview.</returns>
      <remarks>
        <para>This overload must be used if you have several subviews attached to the same view.
            The <i>subqueryId</i> can be any string as long as it is not repeated for two different subviews attached to the same view.</para>
        <para>See the other overload for the explanation of the <b>AttachView</b> method.</para>
      </remarks>
      <seealso cref="M:C1.LiveLinq.LiveViews.View`1.AttachAggregationView``1(System.Object,System.Func{C1.LiveLinq.LiveViews.View{`0},C1.LiveLinq.LiveViews.AggregationView{`0,``0}})" />
    </member>
    <member name="M:C1.LiveLinq.LiveViews.View`1.AttachAggregationView``1(System.Object,System.Func{C1.LiveLinq.LiveViews.View{`0},C1.LiveLinq.LiveViews.AggregationView{`0,``0}})">
      <summary>Includes an aggregation subquery into the incremental maintenance mechanism of a view and uniquely identifies it among other subqueries of the same view.</summary>
      <typeparam name="TResult">The type of the elements in the aggregation subview.</typeparam>
      <param name="subqueryId">A string uniquely specifying this subquery in the view to which it is attached. Can be any string.
            The only requirement is that different subqueries attached to the same view, if such exist, must have different subquery ids.</param>
      <param name="selector">A function to obtain the attached aggregation subview from the view to which it is attached.</param>
      <returns>The attached aggregation subview.</returns>
      <remarks>
        <para>This overload must be used if you have several subviews attached to the same view.
            The <i>subqueryId'</i> can be any string as long as it is not repeated for two different subviews attached to the same view.</para>
        <para>See the other overload for the explanation of the <b>AttachAggregationView</b> method.</para>
      </remarks>
      <seealso cref="M:C1.LiveLinq.LiveViews.View`1.AttachView``1(System.Object,System.Func{C1.LiveLinq.LiveViews.View{`0},C1.LiveLinq.LiveViews.View{``0}})" />
    </member>
    <member name="M:C1.LiveLinq.LiveViews.View`1.AttachAggregationView``1(System.Func{C1.LiveLinq.LiveViews.View{`0},C1.LiveLinq.LiveViews.AggregationView{`0,``0}})">
      <summary>Includes an aggregation subquery into the incremental maintenance mechanism of a view.</summary>
      <typeparam name="TResult">The type of the elements in the aggregation subview.</typeparam>
      <param name="selector">A function to obtain the attached aggregation subview from the view to which it is attached.</param>
      <returns>The attached aggregation subview.</returns>
      <remarks>
        <para>Subquery is a query inside a function that is a part of an outer query.
             If the outer query is a live view, and its base data changes so it needs to recompute the function,
             by default it just evaluates the function, which means creating a new view object for the subquery on every such recomputation.
             To improve performance by avoiding repeated creation of subviews, use the <b>AttachAggregationView</b> method to make the
             outer view aware of its subview. Then the outer view will cache and reuse subview objects it creates.</para>
        <para>If there are more than one subviews attached to a single view, every 
             subview must be supplied with a unique <i>subview id</i> by using the <b>AttachAggregationView</b> overload with <i>subviewId</i> parameter.</para>
        <example>
          <code>
             var productView =
                 from p in products
                 join s in sales on p.ProductID equals s.ProductID into productSales
                 select new
                 {
                     p.Name,
                     ProductTotal = productSales.AttachAggregationView(v =&gt; v.LiveSum(s =&gt; s.Quantity))
                 };
            </code>
        </example>
      </remarks>
      <seealso cref="M:C1.LiveLinq.LiveViews.View`1.AttachView``1(System.Func{C1.LiveLinq.LiveViews.View{`0},C1.LiveLinq.LiveViews.View{``0}})" />
    </member>
    <member name="M:C1.LiveLinq.LiveViews.View`1.ToString">
      <summary>Returns a string representing this view.</summary>
    </member>
    <member name="P:C1.LiveLinq.LiveViews.View`1.Indexes">
      <summary>Gets the collection of indexes for this view.</summary>
      <remarks>
        <para>Live views can be indexed, just like other LiveLinq data sources, to optimize search operations over their data.
            For an example of an index over a view, see
            <span style="C1H Jump">Live Views How To: Create Views Based on Other Views and Create Indexes on Views</span>.</para>
      </remarks>
      <seealso cref="P:C1.LiveLinq.LiveViews.ViewRowCollection.Indexes" />
    </member>
    <member name="P:C1.LiveLinq.LiveViews.View`1.Item(System.Int32)">
      <summary>Gets the view item (element) at the specified ordinal position.</summary>
      <param name="ordinal">The zero-based ordinal position of the view item.</param>
    </member>
    <member name="E:C1.LiveLinq.LiveViews.View`1.Changed">
      <summary>
            Occurs after an item of the view or the entire view has changed.
            </summary>
    </member>
    <member name="T:C1.LiveLinq.LiveViews.ViewRowCollection">
      <summary>Represents a collection of <see cref="T:C1.LiveLinq.LiveViews.ViewRow" /> objects used for programmatic access to view elements (items) and for data binding.</summary>
      <remarks>
        <para>A <b>ViewRowCollection</b> is owned by a view, see <see cref="P:C1.LiveLinq.LiveViews.View.Rows" />.</para>
        <para>The collection of <i>view rows</i> (<see cref="T:C1.LiveLinq.LiveViews.ViewRow" /> objects)
            is always synchronized with the collection of view elements.</para>
        <para>
          <see cref="T:C1.LiveLinq.LiveViews.ViewRow" /> objects provide programmatic access to view elements and their properties.
            Also, the <see cref="P:C1.LiveLinq.LiveViews.View.Rows" /> collection serves as the data source for data binding, when you bind a control or another client to a view.</para>
      </remarks>
    </member>
    <member name="M:C1.LiveLinq.LiveViews.ViewRowCollection.GetItemProperties(System.ComponentModel.PropertyDescriptor[])">
      <summary>
            Returns the collection of properties available in the view element type to programmatic
            access through <see cref="T:C1.LiveLinq.LiveViews.ViewRow" /> and to data binding.
            </summary>
      <param name="listAccessors">An array of <see cref="T:System.ComponentModel.PropertyDescriptor" /> objects to find in the collection as bindable. Can be null. </param>
      <remarks>
        <para>If <i>listAccessors</i> is null, this method returns the collection of properties of the view element type.</para>
        <para>Non-null <i>listAccessors</i> is used for obtaining property collection for hierarchical binding:
            If <i>listAccessors</i> contains a single element, then it is used to find an object-valued property in 
            the element type, and the collection of properties of the type of that object-valued property is returned.
            If <i>listAccessors</i> contains two elements, then its second element is used to find an object-valued property in 
            the collection of properties on the previous level, and so on, see <see cref="M:System.ComponentModel.ITypedList.GetItemProperties(System.ComponentModel.PropertyDescriptor[])">ITypedList.GetItemProperties</see> for more information.</para>
      </remarks>
    </member>
    <member name="M:C1.LiveLinq.LiveViews.ViewRowCollection.DeferRefresh">
      <summary>
            Enters a defer cycle that you can use to merge changes to the view and delay automatic refresh.
            </summary>
      <returns>
            An <see cref="T:System.IDisposable" /> object that you can use to dispose of the calling object.
            </returns>
    </member>
    <member name="M:C1.LiveLinq.LiveViews.ViewRowCollection.CreateRow">
      <summary>Creates a new item directly in the view, and a view row associated with it, and adds it to the <see cref="T:C1.LiveLinq.LiveViews.ViewRowCollection" />.</summary>
      <returns>The newly created view row.</returns>
      <remarks>
            Creating a new row is an update operation on the view. As any other update operation performed directly on the
            view (as opposed to on the base data collection on which that view depends,
            see <see cref="M:C1.LiveLinq.LiveViewExtensions.AsUpdatable``1(C1.LiveLinq.LiveViews.View{``0})" />), it is allowed only if the view
            is not read-only (see <see cref="P:C1.LiveLinq.LiveViews.View.IsReadOnly" />), and it results in updating (in this case, adding a new item to)
            one of the view's base data collections.
            </remarks>
    </member>
    <member name="M:C1.LiveLinq.LiveViews.ViewRowCollection.Remove(C1.LiveLinq.LiveViews.ViewRow)">
      <summary>Deletes the specified view item.</summary>
      <param name="row">The view row representing the item to delete.</param>
      <returns>
        <b>true</b>, if the item was deleted as a result of this operation; otherwise, <b>false</b>.</returns>
      <remarks>
            This is an update operation on the view equivalent to calling <see cref="M:C1.LiveLinq.LiveViews.ViewRow.Delete" />.
            </remarks>
    </member>
    <member name="M:C1.LiveLinq.LiveViews.ViewRowCollection.RemoveAt(System.Int32)">
      <summary>Deletes the view row at a specified ordinal position in <see cref="T:C1.LiveLinq.LiveViews.ViewRowCollection" />.</summary>
      <param name="ordinal">The zero-based ordinal position of the item to remove.</param>
      <remarks>
            This is an update operation on the view equivalent to calling <see cref="M:C1.LiveLinq.LiveViews.ViewRow.Delete" />.
            </remarks>
    </member>
    <member name="M:C1.LiveLinq.LiveViews.ViewRowCollection.Clear">
      <summary>Deletes all view elements.</summary>
            Clearing a view is an update operation on the view. As any other update operation performed directly on the
            view (as opposed to on the base data collection on which that view depends,
            see <see cref="M:C1.LiveLinq.LiveViewExtensions.AsUpdatable``1(C1.LiveLinq.LiveViews.View{``0})" />), it is allowed only if the view
            is not read-only (see <see cref="P:C1.LiveLinq.LiveViews.View.IsReadOnly" />). It results in deleting
            all items from one of the view's base data collections.
        </member>
    <member name="M:C1.LiveLinq.LiveViews.ViewRowCollection.GetEnumerator">
      <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
      <returns>
            A <see cref="T:System.Collections.Generic.IEnumerator`1" /> that can be used to iterate through the collection.
            </returns>
      <filterpriority>1</filterpriority>
    </member>
    <member name="M:C1.LiveLinq.LiveViews.ViewRowCollection.Contains(C1.LiveLinq.LiveViews.ViewRow)">
      <summary>Determines whether the <see cref="T:C1.LiveLinq.LiveViews.ViewRowCollection" /> contains a specific view row.</summary>
      <param name="row">The view row to locate in the collection.</param>
      <returns>
        <b>true</b> if the view row is found in the collection; otherwise, <b>false</b>.</returns>.
        </member>
    <member name="M:C1.LiveLinq.LiveViews.ViewRowCollection.IndexOf(C1.LiveLinq.LiveViews.ViewRow)">
      <summary>Determines the ordinal position of a specific view row in the <see cref="T:C1.LiveLinq.LiveViews.ViewRowCollection" />.</summary>
      <param name="row">The view row to locate in the collection.</param>
      <returns>The ordinal position of the view row in the collection if it is found; otherwise, -1.</returns>
    </member>
    <member name="P:C1.LiveLinq.LiveViews.ViewRowCollection.SortDescriptions">
      <summary>
            Gets a collection of <see cref="T:System.ComponentModel.SortDescription" /> objects that describe how the items in the collection are sorted.
            </summary>
      <returns>
            A collection of <see cref="T:System.ComponentModel.SortDescription" /> objects that describe how the items in the collection are sorted.
            </returns>
    </member>
    <member name="P:C1.LiveLinq.LiveViews.ViewRowCollection.GroupDescriptions">
      <summary>
            Gets a collection of <see cref="T:System.ComponentModel.GroupDescription" /> objects that describe how the items in the collection are grouped.
            </summary>
      <returns>
            A collection of <see cref="T:System.ComponentModel.GroupDescription" /> objects that describe how the items in the collection are grouped.
            </returns>
    </member>
    <member name="P:C1.LiveLinq.LiveViews.ViewRowCollection.Groups">
      <summary>
            Gets the top-level groups.
            </summary>
      <returns>
            A read-only collection of the top-level groups.
            </returns>
    </member>
    <member name="P:C1.LiveLinq.LiveViews.ViewRowCollection.AllowNew">
      <summary>
            Gets a value indicating whether the <see cref="M:C1.LiveLinq.LiveViews.ViewRowCollection.CreateRow" /> operation is allowed on the view directly.
            </summary>
      <remarks>
            As any other update operation performed directly on the
            view (as opposed to on the base data collection on which that view depends,
            see <see cref="M:C1.LiveLinq.LiveViewExtensions.AsUpdatable``1(C1.LiveLinq.LiveViews.View{``0})" />), it is allowed only if the view
            is not read-only (see <see cref="P:C1.LiveLinq.LiveViews.View.IsReadOnly" />).
            Note that the same operation is usually allowed on the base data collection, and it will normally result 
            in the corresponding change of the view.
            </remarks>
    </member>
    <member name="P:C1.LiveLinq.LiveViews.ViewRowCollection.AllowEdit">
      <summary>
            Gets a value indicating whether modifying property values is allowed on the view directly.
            </summary>
      <remarks>
        <para>As any other update operation performed directly on the
            view (as opposed to on the base data collection on which that view depends,
            see <see cref="M:C1.LiveLinq.LiveViewExtensions.AsUpdatable``1(C1.LiveLinq.LiveViews.View{``0})" />), it is allowed only if the view
            is not read-only (see <see cref="P:C1.LiveLinq.LiveViews.View.IsReadOnly" />).</para>
        <para>Although read-only properties of a view cannot be modified directly in the view,
            they still reflect up-to-date values of the source,
            so the difference is often not critical, you can always modify corresponding property in the source, that
            will automatically change the property in the view.</para>
      </remarks>
    </member>
    <member name="P:C1.LiveLinq.LiveViews.ViewRowCollection.AllowRemove">
      <summary>
            Gets a value indicating whether deleting rows is allowed on the view directly.
            </summary>
      <remarks>
            As any other update operation performed directly on the
            view (as opposed to on the base data collection on which that view depends,
            see <see cref="M:C1.LiveLinq.LiveViewExtensions.AsUpdatable``1(C1.LiveLinq.LiveViews.View{``0})" />), it is allowed only if the view
            is not read-only (see <see cref="P:C1.LiveLinq.LiveViews.View.IsReadOnly" />).
            Note that the same operation is often allowed on the base data collection, and it will normally result 
            in the corresponding change of the view.
            </remarks>
    </member>
    <member name="P:C1.LiveLinq.LiveViews.ViewRowCollection.AllowClear">
      <summary>
            Gets a value indicating whether the <see cref="M:C1.LiveLinq.LiveViews.ViewRowCollection.Clear" /> operation is allowed on the view directly.
            </summary>
      <remarks>
            As any other update operation performed directly on the
            view (as opposed to on the base data collection on which that view depends,
            see <see cref="M:C1.LiveLinq.LiveViewExtensions.AsUpdatable``1(C1.LiveLinq.LiveViews.View{``0})" />), it is allowed only if the view
            is not read-only (see <see cref="P:C1.LiveLinq.LiveViews.View.IsReadOnly" />).
            Note that the same operation is often allowed on the base data collection, and it will normally result 
            in the corresponding change of the view.
            </remarks>
    </member>
    <member name="P:C1.LiveLinq.LiveViews.ViewRowCollection.Properties">
      <summary>
            Returns the collection of properties available in the view element type to programmatic
            access through <see cref="T:C1.LiveLinq.LiveViews.ViewRow" /> and to data binding.
            </summary>
    </member>
    <member name="E:C1.LiveLinq.LiveViews.ViewRowCollection.Changed">
      <summary>Occurs after a view row has changed.</summary>
    </member>
    <member name="E:C1.LiveLinq.LiveViews.ViewRowCollection.ViewRowAdding">
      <summary>Occurs after a new view row is created so it can be populated with default values.</summary>
      <remarks>
        <para>This event occurs only if the new row is created directly in the view, as a result of a view update operation,
            that is, with <see cref="M:C1.LiveLinq.LiveViews.ViewRowCollection.CreateRow" /> or via data binding. It does not occur when new rows appear in the view
            as a result of view maintenance on changes made to the view's source data collections.</para>
        <para>This event occurs immediately on creating the new row, before the method creating it returns,
            before the row enters edit mode (see <see cref="T:C1.LiveLinq.LiveViews.ViewRowState" /> about edit mode).</para>
      </remarks>
    </member>
    <member name="P:C1.LiveLinq.LiveViews.ViewRowCollection.Indexes">
      <summary>Gets the collection of indexes for this view allowing to search for <see cref="T:C1.LiveLinq.LiveViews.ViewRow" /> objects.</summary>
      <remarks>
        <see cref="T:C1.LiveLinq.LiveViews.ViewRowCollection" /> can be indexed, just like other 
            LiveLinq data sources, to optimize searches for <see cref="T:C1.LiveLinq.LiveViews.ViewRow" /> objects.
            It implements the <see cref="T:C1.LiveLinq.Indexing.IIndexedSource`1" /> interface.
            </remarks>
      <seealso cref="P:C1.LiveLinq.LiveViews.View`1.Indexes" />
    </member>
    <member name="P:C1.LiveLinq.LiveViews.ViewRowCollection.Count">
      <summary>Gets the number of elements in the view.</summary>
    </member>
    <member name="P:C1.LiveLinq.LiveViews.ViewRowCollection.Item(System.Int32)">
      <summary>
            Gets the view row at the specified ordinal position.
            </summary>
      <param name="ordinal">The zero-based ordinal position of the view row.</param>
    </member>
    <member name="T:C1.LiveLinq.IndexedQueryExtensions">
      <summary>
            Provides a set of static (extension) methods for querying objects that implement <see cref="T:C1.LiveLinq.Indexing.IIndexedSource`1" />.
            </summary>
      <remarks>
        <para>The methods in this class provide an implementation of the LINQ query operators for querying data sources that implement <see cref="T:C1.LiveLinq.Indexing.IIndexedSource`1" />.
            Those data sources include LiveLinq to Objects, LiveLinq to DataSet and LiveLinq to XML,
            see <span style="C1H Jump">How to query collections with LiveLinq</span>.</para>
        <para>These implementations of query operators use indexing and other optimization techniques to speed up query execution.</para>
        <para>Not all standard LINQ query operators are present here, but it does not mean that they cannot be used in the same query.
            For the operators that are not present here, standard LINQ implementations are used,
            because they don't require or don't allow optimization. </para>
        <para>
          <b>Note:</b> Live views are also LiveLinq data sources, but they have their own implementations of query operators
            defined in the <see cref="T:C1.LiveLinq.LiveViews.View`1" /> class.
            Live view implementations are heavier, require more resources, so it is not recommended to use live view implementations
            in cases where you don't need live view functionality (for example, for querying read-only collections),
            see <span style="C1H Jump">Live View Performance</span>. If you have a live view, but want to query it using operators
            from <b>IndexedQueryExtensions</b> instead of <see cref="T:C1.LiveLinq.LiveViews.View`1" />, use <see cref="M:C1.LiveLinq.IndexedQueryExtensions.AsIndexed``1(C1.LiveLinq.Indexing.IIndexedSource{``0})" /> to
            "downgrade" the live view to an <see cref="T:C1.LiveLinq.Indexing.IIndexedSource`1" />.</para>
      </remarks>
    </member>
    <member name="M:C1.LiveLinq.IndexedQueryExtensions.AsIndexed``1(C1.LiveLinq.Indexing.IIndexedSource{``0})">
      <summary>Returns the input typed as <see cref="T:C1.LiveLinq.Indexing.IIndexedSource`1" />.</summary>
      <typeparam name="T">The type of the elements of <i>source</i>.</typeparam>
      <param name="source">The collection to type as <see cref="T:C1.LiveLinq.Indexing.IIndexedSource`1" />.</param>
      <returns>The input collection typed as <see cref="T:C1.LiveLinq.Indexing.IIndexedSource`1" />.</returns>
      <remarks>
        <para>This method has no effect other than to change the compile-time type of <i>source</i> from a type that
            implements <see cref="T:C1.LiveLinq.Indexing.IIndexedSource`1" /> to <see cref="T:C1.LiveLinq.Indexing.IIndexedSource`1" /> itself.
            It is used to choose between query implementations when a collection implements
            <see cref="T:C1.LiveLinq.Indexing.IIndexedSource`1" /> but also has a different set of public query methods available.</para>
        <para>The main scenario is when you want to perform queries on live views without creating new live views.</para>
        <para> Live views have their own implementations of query operators defined in the <see cref="T:C1.LiveLinq.LiveViews.View`1" /> class.
            Live view implementations are heavier, require more resources, so it is not recommended to use live view implementations
            in cases where you don't need live view functionality (for example, for querying read-only collections),
            see <span style="C1H Jump">Live View Performance</span>. If you have a live view, but want to query it using operators
            from <see cref="T:C1.LiveLinq.IndexedQueryExtensions" /> instead of <see cref="T:C1.LiveLinq.LiveViews.View`1" />, use this method to
            "downgrade" the live view to an <see cref="T:C1.LiveLinq.Indexing.IIndexedSource`1" />. This method does not cause the live view to lose its
            "live" functionality, it simply returns the live view's implementation of the <see cref="T:C1.LiveLinq.Indexing.IIndexedSource`1" /> interface.</para>
      </remarks>
    </member>
    <member name="M:C1.LiveLinq.IndexedQueryExtensions.ToIndexed``1(C1.LiveLinq.IObservableSource{``0})">
      <summary>Creates an <see cref="T:C1.LiveLinq.Indexing.IIndexedSource`1" /> based on the specified <see cref="T:C1.LiveLinq.IObservableSource`1" /> collection.</summary>
      <typeparam name="T">The type of the elements in the collection.</typeparam>
      <param name="source">An <see cref="T:C1.LiveLinq.IObservableSource`1" /> collection to base an <see cref="T:C1.LiveLinq.Indexing.IIndexedSource`1" /> on.</param>
      <returns>An <see cref="T:C1.LiveLinq.Indexing.IIndexedSource`1" /> that contains the same elements as the <see cref="T:C1.LiveLinq.IObservableSource`1" />
            collection and enables indexing of that collection.</returns>
      <remarks>
        <para>Use this method to index and query your collection if that collection is your own custom implementation
            of the <see cref="T:C1.LiveLinq.IObservableSource`1" /> interface.</para>
        <para>Elements of the source collection aren't duplicated or copied to a new collection.
            This method just wraps the original collection in an <see cref="T:C1.LiveLinq.Indexing.IIndexedSource`1" />,
            enabling its indexing by using the change notification mechanism of <see cref="T:C1.LiveLinq.IObservableSource`1" />.</para>
        <para>
          <b>Note: </b>Indexes created on the resulting  <see cref="T:C1.LiveLinq.Indexing.IIndexedSource`1" /> are owned by it
            and not by the original collection. Every <b>ToIndexed()</b> call creates a separate object
            that has its own separate indexes. Avoid calling <b>ToIndexed()</b> repeatedly 
            for the same collection because it can increase the cost of maintaining indexes.</para>
      </remarks>
    </member>
    <member name="M:C1.LiveLinq.IndexedQueryExtensions.ToIndexed``1(System.ComponentModel.IBindingList)">
      <summary>Creates an <see cref="T:C1.LiveLinq.Collections.IndexedCollection`1" /> based on the specified <see cref="T:System.ComponentModel.IBindingList" /> data source.</summary>
      <typeparam name="T">The type of the elements in the collection.</typeparam>
      <param name="source">An <see cref="T:System.ComponentModel.IBindingList" /> data source to represent as an <see cref="T:C1.LiveLinq.Collections.IndexedCollection`1" />.</param>
      <returns>An <see cref="T:C1.LiveLinq.Collections.IndexedCollection`1" /> that contains the same elements as the <see cref="T:System.ComponentModel.IBindingList" />
            and enables indexing of that data source.</returns>
      <remarks>
        <para>Use this method to index and query your existing data sources. The only requirements for the data source 
            is that it implements the standard data binding interface <see cref="T:System.ComponentModel.IBindingList" />.</para>
        <para>
          <b>Note: </b>Indexes created on the resulting  <see cref="T:C1.LiveLinq.Collections.IndexedCollection`1" /> are owned by it
            and not by the original data source. Every <b>ToIndexed()</b> call creates a separate object that
            has its own separate indexes. Avoid calling <b>ToIndexed()</b> repeatedly 
            for the same collection because it can increase the cost of maintaining indexes.</para>
      </remarks>
    </member>
    <member name="M:C1.LiveLinq.IndexedQueryExtensions.ToIndexed``1(System.ComponentModel.BindingList{``0})">
      <summary>A typed specialization of the <see cref="M:C1.LiveLinq.IndexedQueryExtensions.ToIndexed``1(System.ComponentModel.IBindingList)" /> method.</summary>
      <typeparam name="T">The type of the elements in the collection.</typeparam>
      <param name="source">A <see cref="T:System.ComponentModel.BindingList`1" /> data source to represent as an <see cref="T:C1.LiveLinq.Collections.IndexedCollection`1" />.</param>
      <returns>An <see cref="T:C1.LiveLinq.Indexing.IIndexedSource`1" /> that contains the same elements as the <see cref="T:System.ComponentModel.BindingList`1" />
            and enables indexing of that data source.</returns>
    </member>
    <member name="M:C1.LiveLinq.IndexedQueryExtensions.Where``1(C1.LiveLinq.Indexing.IIndexedSource{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})">
      <summary>Filters the source collection based on a predicate.</summary>
      <typeparam name="T">The type of the elements of <i>source</i>.</typeparam>
      <param name="source">An <see cref="T:C1.LiveLinq.Indexing.IIndexedSource`1" /> to filter.</param>
      <param name="predicate">A function to test each element for a condition.</param>
      <returns>An <see cref="T:C1.LiveLinq.Indexing.IIndexedSource`1" /> that contains elements from the input collection that satisfy the condition.</returns>
      <remarks>If an index is used to optimized performance of this operation, the resulting collection may not be in 
            the same order as the source collection. If you need to preserve the order, use the other overload of the <b>Where</b> operator.
            It will still be optimized, albeit to a lesser degree.</remarks>
    </member>
    <member name="M:C1.LiveLinq.IndexedQueryExtensions.Where``1(C1.LiveLinq.Indexing.IIndexedSource{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}},System.Boolean)">
      <summary>Filters the source collection based on a predicate, preserving the order of the source collection.</summary>
      <typeparam name="T">The type of the elements of <i>source</i>.</typeparam>
      <param name="source">An <see cref="T:C1.LiveLinq.Indexing.IIndexedSource`1" /> to filter.</param>
      <param name="predicate">A function to test each element for a condition.</param>
      <param name="preserveOriginalOrder">Specifies whether the source order must be preserved in the result.</param>
      <returns>An <see cref="T:C1.LiveLinq.Indexing.IIndexedSource`1" /> that contains elements from the input collection that satisfy the condition.</returns>
      <remarks>Preserving the order can lessen the effect of performance optimization using an index.
            Use this overload only if preserving the order in this operation is essential.</remarks>
    </member>
    <member name="M:C1.LiveLinq.IndexedQueryExtensions.Select``2(C1.LiveLinq.Indexing.IIndexedSource{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}})">
      <summary>Projects each element of a collection into a new form.</summary>
      <typeparam name="TSource">The type of the elements of <i>source</i>.</typeparam>
      <typeparam name="TResult">The type of the value returned by <i>selector</i>.</typeparam>
      <param name="source">An <see cref="T:C1.LiveLinq.Indexing.IIndexedSource`1">IIndexedSource&lt;TSource&gt;</see> collection of values to invoke a transform function on.</param>
      <param name="selector">A transform function to apply to each element.</param>
      <returns>An <see cref="T:C1.LiveLinq.Indexing.IIndexedSource`1">IIndexedSource&lt;TResult&gt;</see> whose elements are the result of invoking the transform function on each element of <i>source</i>.</returns>
    </member>
    <member name="M:C1.LiveLinq.IndexedQueryExtensions.SelectMany``3(C1.LiveLinq.Indexing.IIndexedSource{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Collections.Generic.IEnumerable{``1}}},System.Linq.Expressions.Expression{System.Func{``0,``1,``2}})">
      <summary>
            Projects each element of a collection to a sequence of collections, flattens the resulting collections into one collection,
            and invokes a result selector function on each element therein.
            </summary>
      <typeparam name="TSource">The type of the elements of <i>source</i>.</typeparam>
      <typeparam name="TCollection">The type of the intermediate elements collected by <i>collectionSelector</i>.</typeparam>
      <typeparam name="TResult">The type of the elements of the resulting collection.</typeparam>
      <param name="source">A collection of values to project.</param>
      <param name="collectionSelector">A transform function to apply to each element of the input collection.</param>
      <param name="resultSelector">A transform function to apply to each element of the intermediate sequence.</param>
      <returns>An <see cref="T:C1.LiveLinq.Indexing.IIndexedSource`1">IIndexedSource&lt;TResult&gt;</see> whose elements are the result of invoking the one-to-many transform function
            <i>collectionSelector</i> on each element of <i>source</i> and then mapping each of those sequence elements and their
            corresponding source element to a result element.</returns>
    </member>
    <member name="M:C1.LiveLinq.IndexedQueryExtensions.SelectMany``2(C1.LiveLinq.Indexing.IIndexedSource{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Collections.Generic.IEnumerable{``1}}})">
      <summary>
            Projects each element of a collection to a sequence of collections and flattens the resulting collections into one collection.
            </summary>
      <typeparam name="TSource">The type of the elements of <i>source</i>.</typeparam>
      <typeparam name="TResult">The type of the elements of the sequence returned by <i>selector</i>.</typeparam>
      <param name="source">A collection of values to project.</param>
      <param name="selector">A transform function to apply to each element.</param>
      <returns>An <see cref="T:C1.LiveLinq.Indexing.IIndexedSource`1">IIndexedSource&lt;TResult&gt;</see> whose elements are the result of invoking the one-to-many transform function
            on each element of the source collection.</returns>
    </member>
    <member name="M:C1.LiveLinq.IndexedQueryExtensions.Join``4(C1.LiveLinq.Indexing.IIndexedSource{``0},System.Collections.Generic.IEnumerable{``1},System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``1,``2}},System.Linq.Expressions.Expression{System.Func{``0,``1,``3}})">
      <summary>
            Correlates the elements of two collections based on matching keys.
            </summary>
      <typeparam name="TOuter">The type of the elements of the first collection.</typeparam>
      <typeparam name="TInner">The type of the elements of the second collection.</typeparam>
      <typeparam name="TKey">The type of the keys returned by the key selector functions.</typeparam>
      <typeparam name="TResult">The type of the result elements.</typeparam>
      <param name="outer">The first collection to join.</param>
      <param name="inner">The second collection to join.</param>
      <param name="outerKeySelector">A function to extract the join key from each element of the first collection.</param>
      <param name="innerKeySelector">A function to extract the join key from each element of the second collection.</param>
      <param name="resultSelector">A function to create a result element from two matching elements.</param>
      <returns>An <see cref="T:C1.LiveLinq.Indexing.IIndexedSource`1">IIndexedSource&lt;TResult&gt;</see> that has elements of type <i>TResult</i> that are obtained by performing an inner join on two collections.</returns>
    </member>
    <member name="M:C1.LiveLinq.IndexedQueryExtensions.Join``4(System.Collections.Generic.IEnumerable{``0},C1.LiveLinq.Indexing.IIndexedSource{``1},System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``1,``2}},System.Linq.Expressions.Expression{System.Func{``0,``1,``3}})">
      <summary>
            Correlates the elements of two collections based on matching keys.
            </summary>
      <typeparam name="TOuter">The type of the elements of the first collection.</typeparam>
      <typeparam name="TInner">The type of the elements of the second collection.</typeparam>
      <typeparam name="TKey">The type of the keys returned by the key selector functions.</typeparam>
      <typeparam name="TResult">The type of the result elements.</typeparam>
      <param name="outer">The first collection to join.</param>
      <param name="inner">The second collection to join.</param>
      <param name="outerKeySelector">A function to extract the join key from each element of the first collection.</param>
      <param name="innerKeySelector">A function to extract the join key from each element of the second collection.</param>
      <param name="resultSelector">A function to create a result element from two matching elements.</param>
      <returns>An <see cref="T:C1.LiveLinq.Indexing.IIndexedSource`1">IIndexedSource&lt;TResult&gt;</see> that has elements of type <i>TResult</i> that are obtained by performing an inner join on two collections.</returns>
    </member>
    <member name="M:C1.LiveLinq.IndexedQueryExtensions.Join``4(C1.LiveLinq.Indexing.IIndexedSource{``0},C1.LiveLinq.Indexing.IIndexedSource{``1},System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``1,``2}},System.Linq.Expressions.Expression{System.Func{``0,``1,``3}})">
      <summary>
            Correlates the elements of two collections based on matching keys.
            </summary>
      <typeparam name="TOuter">The type of the elements of the first collection.</typeparam>
      <typeparam name="TInner">The type of the elements of the second collection.</typeparam>
      <typeparam name="TKey">The type of the keys returned by the key selector functions.</typeparam>
      <typeparam name="TResult">The type of the result elements.</typeparam>
      <param name="outer">The first collection to join.</param>
      <param name="inner">The second collection to join.</param>
      <param name="outerKeySelector">A function to extract the join key from each element of the first collection.</param>
      <param name="innerKeySelector">A function to extract the join key from each element of the second collection.</param>
      <param name="resultSelector">A function to create a result element from two matching elements.</param>
      <returns>An <see cref="T:C1.LiveLinq.Indexing.IIndexedSource`1">IIndexedSource&lt;TResult&gt;</see> that has elements of type <i>TResult</i> that are obtained by performing an inner join on two collections.</returns>
    </member>
    <member name="M:C1.LiveLinq.IndexedQueryExtensions.OrderBy``2(C1.LiveLinq.Indexing.IIndexedSource{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}})">
      <summary>Sorts the elements of a collection in ascending order.</summary>
      <typeparam name="T">The type of the elements of <i>source</i>.</typeparam>
      <typeparam name="TKey">The type of the key returned by <i>keySelector</i>.</typeparam>
      <param name="source">A collection of values to order.</param>
      <param name="keySelector">A function to extract a key from an element.</param>
      <returns>An <see cref="T:C1.LiveLinq.Indexing.IIndexedSource`1" /> whose elements are sorted according to a key.</returns>
    </member>
    <member name="M:C1.LiveLinq.IndexedQueryExtensions.OrderByDescending``2(C1.LiveLinq.Indexing.IIndexedSource{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}})">
      <summary>Sorts the elements of a collection in descending order.</summary>
      <typeparam name="T">The type of the elements of <i>source</i>.</typeparam>
      <typeparam name="TKey">The type of the key returned by <i>keySelector</i>.</typeparam>
      <param name="source">A collection of values to order.</param>
      <param name="keySelector">A function to extract a key from an element.</param>
      <returns>An <see cref="T:C1.LiveLinq.Indexing.IIndexedSource`1" /> whose elements are sorted in descending order according to a key.</returns>
    </member>
    <member name="M:C1.LiveLinq.IndexedQueryExtensions.GroupBy``4(C1.LiveLinq.Indexing.IIndexedSource{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``1,System.Collections.Generic.IEnumerable{``2},``3}})">
      <summary>
            Groups the elements of a collection according to a specified key selector function and creates a result value
            from each group and its key. The elements of each group are projected by using a specified function.
            </summary>
      <typeparam name="TSource">The type of the elements of <i>source</i>.</typeparam>
      <typeparam name="TKey">The type of the key returned by <i>keySelector</i>.</typeparam>
      <typeparam name="TElement">The type of the elements in the <see cref="T:System.Linq.IGrouping`2" />.</typeparam>
      <typeparam name="TResult">The type of the result value returned by <i>resultSelector</i></typeparam>
      <param name="source">An <see cref="T:C1.LiveLinq.Indexing.IIndexedSource`1" /> whose elements to group</param>
      <param name="keySelector">A function to extract the key for each element.</param>
      <param name="elementSelector">A function to map each source element to an element in the <see cref="T:System.Linq.IGrouping`2" />.</param>
      <param name="resultSelector">A function to create a result value from each group.</param>
      <returns>A collection of elements of type <i>TResult</i> where each element represents a projection over a group and its key.</returns>
    </member>
    <member name="M:C1.LiveLinq.IndexedQueryExtensions.GroupBy``3(C1.LiveLinq.Indexing.IIndexedSource{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Linq.Expressions.Expression{System.Func{``0,``2}})">
      <summary>
            Groups the elements of a collection according to a specified key selector function and projects the elements for each group by using a specified function.
            </summary>
      <typeparam name="TSource">The type of the elements of <i>source</i>.</typeparam>
      <typeparam name="TKey">The type of the key returned by <i>keySelector</i>.</typeparam>
      <typeparam name="TElement">The type of the elements in the <see cref="T:System.Linq.IGrouping`2" />.</typeparam>
      <param name="source">An <see cref="T:C1.LiveLinq.Indexing.IIndexedSource`1" /> whose elements to group</param>
      <param name="keySelector">A function to extract the key for each element.</param>
      <param name="elementSelector">A function to map each source element to an element in the <see cref="T:System.Linq.IGrouping`2" />.</param>
      <returns> A collection of <see cref="T:System.Linq.IGrouping`2" /> objects each containing a collection of objects of type
            <i>TElement</i> and a key.</returns>
    </member>
    <member name="M:C1.LiveLinq.IndexedQueryExtensions.GroupBy``3(C1.LiveLinq.Indexing.IIndexedSource{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Linq.Expressions.Expression{System.Func{``1,System.Collections.Generic.IEnumerable{``0},``2}})">
      <summary>
            Groups the elements of a collection according to a specified key selector function and creates a result value from each group and its key.
            </summary>
      <typeparam name="TSource">The type of the elements of <i>source</i>.</typeparam>
      <typeparam name="TKey">The type of the key returned by <i>keySelector</i>.</typeparam>
      <typeparam name="TResult">The type of the result value returned by <i>resultSelector</i></typeparam>
      <param name="source">An <see cref="T:C1.LiveLinq.Indexing.IIndexedSource`1" /> whose elements to group</param>
      <param name="keySelector">A function to extract the key for each element.</param>
      <param name="resultSelector">A function to create a result value from each group.</param>
      <returns>A collection of elements of type <i>TResult</i> where each element represents a projection over a group and its key.</returns>
    </member>
    <member name="M:C1.LiveLinq.IndexedQueryExtensions.GroupBy``2(C1.LiveLinq.Indexing.IIndexedSource{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}})">
      <summary>Groups the elements of a collection according to a specified key selector function.</summary>
      <typeparam name="TSource">The type of the elements of <i>source</i>.</typeparam>
      <typeparam name="TKey">The type of the key returned by <i>keySelector</i>.</typeparam>
      <param name="source">An <see cref="T:C1.LiveLinq.Indexing.IIndexedSource`1" /> whose elements to group</param>
      <param name="keySelector">A function to extract the key for each element.</param>
      <returns>A collection of <see cref="T:System.Linq.IGrouping`2" /> objects each containing a sequence of objects and a key.</returns>
    </member>
    <member name="M:C1.LiveLinq.IndexedQueryExtensions.GroupJoin``4(C1.LiveLinq.Indexing.IIndexedSource{``0},System.Collections.Generic.IEnumerable{``1},System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``1,``2}},System.Linq.Expressions.Expression{System.Func{``0,System.Collections.Generic.IEnumerable{``1},``3}})">
      <summary>Correlates the elements of two collections based on equality of keys and groups the results.</summary>
      <typeparam name="TOuter">The type of the elements of the first collection.</typeparam>
      <typeparam name="TInner">The type of the elements of the second collection.</typeparam>
      <typeparam name="TKey">The type of the keys returned by the key selector functions.</typeparam>
      <typeparam name="TResult">The type of the result elements.</typeparam>
      <param name="outer">The first collection to join.</param>
      <param name="inner">The collection to join to the first collection.</param>
      <param name="outerKeySelector">A function to extract the join key from each element of the first collection.</param>
      <param name="innerKeySelector">A function to extract the join key from each element of the second collection.</param>
      <param name="resultSelector">A function to create a result element from an element 
            from the first collection and a collection of matching elements from the second collection.</param>
      <returns>An <see cref="T:C1.LiveLinq.Indexing.IIndexedSource`1">IIndexedSource&lt;TResult&gt;</see> that contains elements of type <i>TResult</i>
            that are obtained by performing a grouped join on two collections.</returns>
    </member>
    <member name="T:C1.LiveLinq.Collections.IndexedCollection`1">
      <summary>
            Data collection class recommended for use in LiveLinq to Objects.
            </summary>
      <remarks>
        <para>If you don't have preexisting collection classes and need to create your own,
            the best choice is to use the built-in LiveLinq collection class <b>IndexedCollection&lt;T&gt;.</b>
            It is specifically optimized for LiveLinq use.</para>
        <para>Usually, the element class <b>T</b> must implement the property change notification interface
            <see cref="T:System.ComponentModel.INotifyPropertyChanged" />.
            The easiest way to implement <see cref="T:System.ComponentModel.INotifyPropertyChanged" /> is to derive the element class from
            <see cref="T:C1.LiveLinq.Collections.IndexableObject" />.</para>
        <para>In rare cases where implementing <see cref="T:System.ComponentModel.INotifyPropertyChanged" /> is impossible, a custom <see cref="T:C1.LiveLinq.Listeners.PropertyChangeListener`1" />
            can be provided instead.</para>
        <para>For details, see <span style="C1H Jump">Using the built-in collection class IndexedCollection(T) (LiveLinq to Objects)</span>.</para>
        <para>For alternative options in LiveLinq to Objects, see
            <span style="C1H Jump">LiveLinq to Objects: IndexedCollection(T) and other collection classes</span></para>
        <para>The <b>IndexedCollection&lt;T&gt;</b> class is not needed in LiveLinq to DataSet and LiveLinq to XML,
            because in those cases LiveLinq works with collections that already exist in ADO.NET and XML.</para>
      </remarks>
      <typeparam name="T">The type of the elements in the collection.</typeparam>
    </member>
    <member name="M:C1.LiveLinq.Collections.IndexedCollection`1.#ctor">
      <summary>Initializes a new instance of the <see cref="T:C1.LiveLinq.Collections.IndexedCollection`1" /> class.</summary>
    </member>
    <member name="M:C1.LiveLinq.Collections.IndexedCollection`1.#ctor(System.Collections.Generic.IList{`0})">
      <summary>Initializes a new instance of the <see cref="T:C1.LiveLinq.Collections.IndexedCollection`1" /> class that contains elements copied from the specified list.</summary>
      <param name="list">The collection whose elements are copied to the new instance.</param>
    </member>
    <member name="M:C1.LiveLinq.Collections.IndexedCollection`1.#ctor(System.Collections.Generic.IList{`0},C1.LiveLinq.Listeners.PropertyChangeListener{`0})">
      <summary>
            Initializes a new instance of the <see cref="T:C1.LiveLinq.Collections.IndexedCollection`1" /> class that contains elements copied from the specified list,
            and provides a custom <see cref="T:C1.LiveLinq.Listeners.PropertyChangeListener`1" />.
            </summary>
      <param name="list">The collection whose elements are copied to the new instance.</param>
      <param name="itemPropertyChangeListener">The custom <see cref="T:C1.LiveLinq.Listeners.PropertyChangeListener`1" /> to use with the collection.</param>
      <remarks>
            This constructor is intended for the rare cases where implementing <see cref="T:System.ComponentModel.INotifyPropertyChanged" /> in the 
            class of the elements of the collection is impossible
            </remarks>
    </member>
    <member name="M:C1.LiveLinq.Collections.IndexedCollection`1.AddRange(System.Collections.Generic.IEnumerable{`0})">
      <summary>Adds the elements of the specified collection to the end of the <see cref="T:C1.LiveLinq.Collections.IndexedCollection`1" /></summary>
      <param name="items">The collection whose elements should be added to the end of the <see cref="T:C1.LiveLinq.Collections.IndexedCollection`1" /></param>
    </member>
    <member name="M:C1.LiveLinq.Collections.IndexedCollection`1.OnChanged(C1.LiveLinq.SourceChangeEventArgs{`0})">
      <summary>Raises the <see cref="E:C1.LiveLinq.Collections.IndexedCollection`1.Changed" /> event.</summary>
      <param name="e">Event data.</param>
    </member>
    <member name="M:C1.LiveLinq.Collections.IndexedCollection`1.InsertItem(System.Int32,`0)">
      <summary>Inserts an element into the <see cref="T:C1.LiveLinq.Collections.IndexedCollection`1" /> at the specified ordinal position.</summary>
      <param name="ordinal">The zero-based ordinal at which the item must be inserted.</param>
      <param name="item">The object to insert.</param>
    </member>
    <member name="M:C1.LiveLinq.Collections.IndexedCollection`1.ClearItems">
      <summary>Removes all elements from the <see cref="T:C1.LiveLinq.Collections.IndexedCollection`1" /></summary>
    </member>
    <member name="M:C1.LiveLinq.Collections.IndexedCollection`1.RemoveItem(System.Int32)">
      <summary>Removes the element of the <see cref="T:C1.LiveLinq.Collections.IndexedCollection`1" /> at the specified ordinal position.</summary>
      <param name="ordinal">The zero-based ordinal of the element to remove.</param>
    </member>
    <member name="M:C1.LiveLinq.Collections.IndexedCollection`1.SetItem(System.Int32,`0)">
      <summary>Replaces the element at the specified ordinal position.</summary>
      <param name="ordinal">The zero-based ordinal of the element to replace.</param>
      <param name="newItem">The new value for the element at the specified ordinal. The value can be null for reference types.</param>
    </member>
    <member name="M:C1.LiveLinq.Collections.IndexedCollection`1.BeginUpdate">
      <summary>Suspends notifications while massive changes are being made to the <see cref="T:C1.LiveLinq.Collections.IndexedCollection`1" />.</summary>
      <remarks>
        <para>This method must be followed by <see cref="M:C1.LiveLinq.Collections.IndexedCollection`1.EndUpdate" />.</para>
        <para>Use this method when you already have indexes built over the <see cref="T:C1.LiveLinq.Collections.IndexedCollection`1" /> or live views based on it,
            and you need to re-populate this <see cref="T:C1.LiveLinq.Collections.IndexedCollection`1" /> or perform other massive changes to items of this collection.
            Without this method, every single change you make causes LiveLinq to perform necessary operations
            for maintaining your indexes and live views dependent on this collection. In case of massive changes,
            this can be slower than to wait until the massive changes are done and rebuild the indexes and live views.</para>
        <para> Between <b>BeginUpdate</b> and <see cref="M:C1.LiveLinq.Collections.IndexedCollection`1.EndUpdate" /> calls, indexes, live views, bound controls
            and other change notification listeners are not updated, they don't receive change notifications.</para>
        <para>When <see cref="M:C1.LiveLinq.Collections.IndexedCollection`1.EndUpdate" /> is called, a 
            <see cref="T:C1.LiveLinq.SourceChangeType">SourceChangeType.Modify</see> or <see cref="T:C1.LiveLinq.SourceChangeType">SourceChangeType.Reset</see>
            notification is sent, depending on whether the change affected a single item or multiple items of the collection.
            Even when you change a single item, it may make sense to enclose your changes in <b>BeginUpdate/EndUpdate</b> if
            you change multiple properties of the item. In that case a <see cref="T:C1.LiveLinq.SourceChangeType">SourceChangeType.Modify</see>
            notification is sent. If more than one item was changed, a <see cref="T:C1.LiveLinq.SourceChangeType">SourceChangeType.Reset</see>
            notification is sent, meaning all indexes, live views and other collections dependent on this data table
            must be rebuilt from scratch.</para>
      </remarks>
    </member>
    <member name="M:C1.LiveLinq.Collections.IndexedCollection`1.EndUpdate">
      <summary>Ends notification suspension started with <see cref="M:C1.LiveLinq.Collections.IndexedCollection`1.BeginUpdate" />.</summary>
    </member>
    <member name="P:C1.LiveLinq.Collections.IndexedCollection`1.Indexes">
      <summary>The collection of indexes for this <see cref="T:C1.LiveLinq.Collections.IndexedCollection`1" /></summary>
    </member>
    <member name="E:C1.LiveLinq.Collections.IndexedCollection`1.Changed">
      <summary>Occurs after the collection has changed.</summary>
    </member>
    <member name="P:C1.LiveLinq.Collections.IndexedCollection`1.CreateNew">
      <summary>
            Gets or sets a delegate that is used to create new items.
            If it is null, a public parameterless constructor of type <b>T</b> is used.
            </summary>
    </member>
    <member name="T:C1.LiveLinq.Indexing.Index`1">
      <summary>
            Base class for the <see cref="T:C1.LiveLinq.Indexing.Index`2" /> class.
            </summary>
      <typeparam name="T">The type of the elements of the collection to index.</typeparam>
      <seealso cref="T:C1.LiveLinq.Indexing.Index`2" />
      <remarks>
            You don't typically use the <b>Index&lt;T&gt;</b> class directly. It provides functionality of the <see cref="T:C1.LiveLinq.Indexing.Index`2" /> class that does not depend on the
            index key type. The base class <b>Index&lt;T&gt;</b> is needed only if the index key type is not known, usually in general-purpose code intended for reuse with different key types.
            </remarks>
    </member>
    <member name="T:C1.LiveLinq.Indexing.IndexDefinition`1">
      <summary>
            Contains common part of the <see cref="T:C1.LiveLinq.Indexing.Index`2">Index</see> and <see cref="T:C1.LiveLinq.Indexing.Subindex`2">Subindex</see> classes.
            </summary>
      <typeparam name="T">The type of the elements of indexed collection.</typeparam>
      <seealso cref="T:C1.LiveLinq.Indexing.Index`2" />
      <remarks>
            This class serves as the base class of two classes: <see cref="T:C1.LiveLinq.Indexing.Index`1">Index</see> and <see cref="T:C1.LiveLinq.Indexing.Subindex`1">Subindex</see>.
            It contains properties common to these two classes.
            </remarks>
    </member>
    <member name="P:C1.LiveLinq.Indexing.IndexDefinition`1.KeySelector">
      <summary>
            Gets the expression used to obtain key value from an element of the indexed collection.
            </summary>
      <value>An expression calculating the key value from an item (element of the collection).
            Typically, this is a field or a property in the item class, although more complex expressions can also be used.</value>
    </member>
    <member name="P:C1.LiveLinq.Indexing.IndexDefinition`1.KeyIsUnique">
      <summary>
            Gets a value that indicates whether the key used in this index is a unique key for the collection.
            </summary>
      <value>
        <b>true</b> if the key is unique; otherwise, <b>false</b></value>
      <remarks>
        <para>A unique index occupies less memory and performs better than a non-unique index (although the difference isn't dramatic).
            Therefore, for unique keys, it's recommended to specify the corresponding index as unique in the
            <see cref="M:C1.LiveLinq.Indexing.IndexCollection`1.Add``1(System.Linq.Expressions.Expression{System.Func{`0,``0}})">IndexCollection.Add</see> method.</para>
        <para>But do that only if you are sure that the key is indeed unique, as it imposes a uniqueness constraint on the collection.
            An attempt to modify the collection violating the uniqueness throws an <see cref="T:System.InvalidOperationException" />.</para>
      </remarks>
    </member>
    <member name="P:C1.LiveLinq.Indexing.IndexDefinition`1.Locale">
      <summary>
            Gets the locale information used to compare strings in the index.
            </summary>
      <value>A <see cref="T:System.Globalization.CultureInfo" /> that contains data about the user's locale. The default is <see cref="P:System.Globalization.CultureInfo.CurrentCulture" />.</value>
    </member>
    <member name="P:C1.LiveLinq.Indexing.IndexDefinition`1.Algorithm">
      <summary>
            Gets the indexing algorithm used by the index.
            </summary>
      <value>An <see cref="T:C1.LiveLinq.Indexing.IndexingAlgorithm" /> used by the index. In the current version, only one algorithm 
            is supported, RedBlackTree. Later versions may support other algorithms, such as bitmap or hash indexes.</value>
    </member>
    <member name="P:C1.LiveLinq.Indexing.IndexDefinition`1.KeyType">
      <summary>
            Gets the type of the index key.
            </summary>
      <value>The type of the result of the <see cref="P:C1.LiveLinq.Indexing.IndexDefinition`1.KeySelector" /> expression.</value>
      <remarks>
            This type is the same as the TKey type parameter for <see cref="T:C1.LiveLinq.Indexing.Index`2" /> and <see cref="T:C1.LiveLinq.Indexing.Subindex`2" /> objects.
            </remarks>
    </member>
    <member name="P:C1.LiveLinq.Indexing.IndexDefinition`1.Root">
      <summary>
            Gets the root index in an index/subindex hierarchy.
            </summary>
      <value>For a subindex, this is an <see cref="T:C1.LiveLinq.Indexing.Index`1" /> to which the subindex belongs (maybe indirectly,
            through several levels of parent subindexes).
            For an index, this is always the same object as the index itself.
            </value>
    </member>
    <member name="P:C1.LiveLinq.Indexing.IndexDefinition`1.Subindexes">
      <summary>
            Gets the collection of subindexes added to this index.
            </summary>
      <value>The <see cref="T:C1.LiveLinq.Indexing.SubindexCollection`1" /> that contains the subindexes of this index.</value>
    </member>
    <member name="T:C1.LiveLinq.Indexing.Search.IIndexScanner`1">
      <summary>Represents an index or a subindex in its capacity of scanning through data. Provides methods for searching data items.</summary>
      <typeparam name="T">The type of the elements of the indexed collection.</typeparam>
      <remarks>
        <para>This interface is implemented by <see cref="T:C1.LiveLinq.Indexing.Index`1" />. It is also used by subindexes, but there it is not directly implemented by 
            <see cref="T:C1.LiveLinq.Indexing.Subindex`1" />, but rather returned by the <see cref="M:C1.LiveLinq.Indexing.Search.IndexQuery`1.Subindex(C1.LiveLinq.Indexing.Subindex{`0})">IndexQuery&lt;T&gt;.Subindex</see> method because it depends on 
            the item found by an index or a subindex that is the parent of that subindex.</para>
        <para>
          <see cref="T:C1.LiveLinq.Indexing.Search.IIndexScanner`1" /> has a typed key counterpart <see cref="T:C1.LiveLinq.Indexing.Search.IIndexScanner`2" />
            that is used with typed key classes <see cref="T:C1.LiveLinq.Indexing.Index`2" /> and <see cref="T:C1.LiveLinq.Indexing.Subindex`2" /></para>
      </remarks>
    </member>
    <member name="M:C1.LiveLinq.Indexing.Search.IIndexScanner`1.All(C1.LiveLinq.Order)">
      <summary>Gets all items in the indexed collection.</summary>
      <param name="order">Specifies the order of the key values to sort the result.</param>
      <returns>An object enumerating all items of the collection in the specified order of their key values.</returns>
    </member>
    <member name="M:C1.LiveLinq.Indexing.Search.IIndexScanner`1.ContainsKey(System.Object)">
      <summary>Returns a value that indicates whether the collection contains an item with the given key value.</summary>
      <param name="key">The key value to search for</param>
      <returns>
        <b>true</b> if the collection contains an element with the specified key value; otherwise, <b>false</b>.</returns>
    </member>
    <member name="M:C1.LiveLinq.Indexing.Search.IIndexScanner`1.Find(System.Object)">
      <summary>
            Finds items with the specified key value.
            </summary>
      <param name="key">The key value to search for.</param>
      <returns>An object enumerating items having the specified key value.</returns>
    </member>
    <member name="M:C1.LiveLinq.Indexing.Search.IIndexScanner`1.FindKeys(System.Collections.IEnumerable,C1.LiveLinq.Order)">
      <summary>
            Finds items containing any of the specified key values.
            </summary>
      <param name="keys">The key values to search for.</param>
      <param name="order">Optionally specifies the order of the key values to sort the result (<see cref="T:C1.LiveLinq.Order" />.<b>Unordered</b> if sorting is not required).</param>
      <returns>An object enumerating all items whose key values belong to the specified key value collection.</returns>
    </member>
    <member name="M:C1.LiveLinq.Indexing.Search.IIndexScanner`1.FindGreater(System.Object,System.Boolean,C1.LiveLinq.Order)">
      <summary>
            Finds items with keys greater than the specified value.
            </summary>
      <param name="key">Minimum key value to search for.</param>
      <param name="inclusive">If <b>true</b>, the result includes items with the 
            specified key value. Otherwise, the result only includes those with keys strictly greater than the specified value.</param>
      <param name="order">Optionally specifies the order of the key values to sort the result (<see cref="T:C1.LiveLinq.Order" />.<b>Unordered</b> if sorting is not required).</param>
      <returns>An object enumerating all items whose key values are greater than the specified value.</returns>
    </member>
    <member name="M:C1.LiveLinq.Indexing.Search.IIndexScanner`1.FindLess(System.Object,System.Boolean,C1.LiveLinq.Order)">
      <summary>
            Finds items with keys less than the specified value.
            </summary>
      <param name="key">Maximum key value to search for.</param>
      <param name="inclusive">If <b>true</b>, the result includes items with the 
            specified key value. Otherwise, the result only includes those with keys strictly less than the specified value.</param>
      <param name="order">Optionally specifies the order of the key values to sort the result (<see cref="T:C1.LiveLinq.Order" />.<b>Unordered</b> if sorting is not required).</param>
      <returns>An object enumerating all items whose key values are less than the specified value.</returns>
    </member>
    <member name="M:C1.LiveLinq.Indexing.Search.IIndexScanner`1.FindBetween(System.Object,System.Boolean,System.Object,System.Boolean,C1.LiveLinq.Order)">
      <summary>
            Finds items with key values in the interval between the specified values.
            </summary>
      <param name="min">Minimum key value to search for.</param>
      <param name="minInclusive">If <b>true</b>, the result includes items with the minimum key value.</param>
      <param name="max">Maximum key value to search for.</param>
      <param name="maxInclusive">If <b>true</b>, the result includes items with the maximum key value.</param>
      <param name="order">Optionally specifies the order of the key values to sort the result (<see cref="T:C1.LiveLinq.Order" />.<b>Unordered</b> if sorting is not required).</param>
      <returns>An object enumerating all items with key values within the specified limits.</returns>
    </member>
    <member name="M:C1.LiveLinq.Indexing.Search.IIndexScanner`1.FindStartingWith(System.String,System.Func{System.String,System.Boolean},C1.LiveLinq.Order)">
      <summary>
            Finds items with string key values starting with the specified string.
            </summary>
      <param name="value">The string to search for as the beginning of key value strings.</param>
      <param name="keyPredicate">An optional condition that found items must satisfy.</param>
      <param name="order">Optionally specifies the order of the key values to sort the result (<see cref="T:C1.LiveLinq.Order" />.<b>Unordered</b> if sorting is not required).</param>
      <returns>An object enumerating all items whose key values are strings that have a beginning matching the specified string and satisfy the optional condition.</returns>
    </member>
    <member name="M:C1.LiveLinq.Indexing.Search.IIndexScanner`1.Join``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Object},System.Func{`0,``0,``1},C1.LiveLinq.Indexing.Search.JoinOperator)">
      <summary>
            Correlates the items of this indexed collection with the items of another sequence and returns the combined items with matching keys.
            </summary>
      <param name="source">The second sequence to join to this collection.</param>
      <param name="keySelector">A function to extract from an item of the second sequence the value to match against this collection's key value.</param>
      <param name="resultSelector">A function to create a result element from two matching elements.</param>
      <param name="op">A comparison operator to match elements.</param>
      <typeparam name="T2">The type of the elements of the second sequence.</typeparam>
      <typeparam name="TResult">The type of the result elements.</typeparam>
      <returns>Enumeration of objects obtained by applying the result selector to pairs of joined elements of the two collections.</returns>
    </member>
    <member name="M:C1.LiveLinq.Indexing.Search.IIndexScanner`1.Join``2(C1.LiveLinq.Indexing.Search.IIndexScanner{``0},System.Func{`0,``0,``1},C1.LiveLinq.Indexing.Search.JoinOperator)">
      <summary>
            Correlates the items of this indexed collection with the items of another indexed collection and returns the combined items with matching keys.
            </summary>
      <param name="source">The second indexed collection to join to this collection.</param>
      <param name="resultSelector">A function to create a result element from two matching elements.</param>
      <param name="op">A comparison operator to match elements.</param>
      <typeparam name="T2">The type of the elements of the second collection.</typeparam>
      <typeparam name="TResult">The type of the result elements.</typeparam>
      <returns>Enumeration of objects obtained by applying the result selector to pairs of joined elements of the two collections.</returns>
      <remarks>Matching of two elements is performed by matching their keys.</remarks>
    </member>
    <member name="M:C1.LiveLinq.Indexing.Search.IIndexScanner`1.GroupJoin``2(C1.LiveLinq.Indexing.Search.IIndexScanner{``0},System.Func{`0,System.Collections.Generic.IEnumerable{``0},``1})">
      <summary>
            Correlates the items of this indexed collection with the items of another indexed collection and groups the results by the item of this collection.
            </summary>
      <param name="source">The second indexed collection to join to this collection.</param>
      <param name="resultSelector">A function to create a result element from an element from this collection and a collection of matching elements from the second collection.</param>
      <typeparam name="T2">The type of the elements of the second collection.</typeparam>
      <typeparam name="TResult">The type of the result elements.</typeparam>
      <returns>Enumeration of objects obtained by applying the result selector to group pairs,
            where each pair consists of an item of this collection and the corresponding enumeration of the items of the second collection joined to it.</returns>
      <remarks>Matching of two elements is performed by matching their keys.</remarks>
    </member>
    <member name="M:C1.LiveLinq.Indexing.Search.IIndexScanner`1.GroupJoin``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Object},System.Func{System.Collections.Generic.IEnumerable{`0},``0,``1})">
      <summary>
            Correlates the items of this indexed collection with the items of another sequence and groups the results by the item of the second sequence.
            </summary>
      <param name="source">The second sequence to join to this collection.</param>
      <param name="keySelector">A function to extract from an item of the second sequence the value to match against this collection's key value.</param>
      <param name="resultSelector">A function to create a result element from an element of the second sequence and the collection of matching elements from this collection.</param>
      <typeparam name="T2">The type of the elements of the second sequence.</typeparam>
      <typeparam name="TResult">The type of the result elements.</typeparam>
      <returns>Enumeration of objects obtained by applying the result selector to group pairs,
            where each pair consists of an item of the second collection and the corresponding enumeration of the items of this collection joined to it.</returns>
    </member>
    <member name="M:C1.LiveLinq.Indexing.Search.IIndexScanner`1.GroupJoin``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Object},System.Func{`0,System.Collections.Generic.IEnumerable{``0},``1})">
      <summary>
            Correlates the items of this indexed collection with the items of another sequence and groups the results by the item of this collection.
            </summary>
      <param name="source">The second sequence to join to this collection.</param>
      <param name="keySelector">A function to extract from an item of the second sequence the value to match against this collection's key value.</param>
      <param name="resultSelector">A function to create a result element from an element from this collection and a collection of matching elements from the second sequence.</param>
      <typeparam name="T2">The type of the elements of the second sequence.</typeparam>
      <typeparam name="TResult">The type of the result elements.</typeparam>
      <returns>Enumeration of objects obtained by applying the result selector to group pairs,
            where each pair consists of an item of this collection and the corresponding enumeration of the items of the second sequence joined to it.</returns>
    </member>
    <member name="P:C1.LiveLinq.Indexing.Search.IIndexScanner`1.ParentScanner">
      <summary>Gets an index or a subindex scanner that is the parent of a subindex scanner.</summary>
      <value>Parent scanner for a subindex scanner; <b>null</b> for an index scanner.</value>
    </member>
    <member name="P:C1.LiveLinq.Indexing.Search.IIndexScanner`1.Definition">
      <summary>Gets an <see cref="T:C1.LiveLinq.Indexing.Index`1" /> or a <see cref="T:C1.LiveLinq.Indexing.Subindex`1" /> definition on which the scanner is based.</summary>
      <value>For a subindex scanner, returns a <see cref="T:C1.LiveLinq.Indexing.Subindex`1" />. For an index scanner, returns the same <see cref="T:C1.LiveLinq.Indexing.Index`1" /> 
            object as the scanner itself.</value>
    </member>
    <member name="P:C1.LiveLinq.Indexing.Search.IIndexScanner`1.KeyCount">
      <summary>Gets the number of distinct key values in all items of this collection.</summary>
      <value>Number of distinct key values in the collection.</value>
      <remarks>This number is not the same as the number of elements in the collection, unless the index key 
            is a unique key of that collection, see <see cref="P:C1.LiveLinq.Indexing.IndexDefinition`1.KeyIsUnique" />.</remarks>
    </member>
    <member name="M:C1.LiveLinq.Indexing.Index`1.ContainsKey(System.Object)">
      <summary>
        <para>Returns a value that indicates whether the indexed collection contains an item with the given key value.</para>
        <para>Implements <see cref="M:C1.LiveLinq.Indexing.Search.IIndexScanner`1.ContainsKey(System.Object)">IIndexScanner(T).ContainsKey(object)</see></para>
      </summary>
      <param name="key">The key value to search for.</param>
      <returns>
        <b>true</b> if the indexed collection contains an element with the specified key value; otherwise, <b>false</b>.</returns>
    </member>
    <member name="M:C1.LiveLinq.Indexing.Index`1.Find(System.Object)">
      <summary>
        <para>Finds items with the specified key value.</para>
        <para>Implements <see cref="M:C1.LiveLinq.Indexing.Search.IIndexScanner`1.Find(System.Object)">IIndexScanner(T).Find(object)</see></para>
      </summary>
      <param name="key">The key value to search for.</param>
      <returns>An object enumerating items having the specified key value.</returns>
    </member>
    <member name="M:C1.LiveLinq.Indexing.Index`1.FindKeys(System.Collections.IEnumerable,C1.LiveLinq.Order)">
      <summary>
        <para>Finds items containing any of the specified key values.</para>
        <para>Implements <see cref="M:C1.LiveLinq.Indexing.Search.IIndexScanner`1.FindKeys(System.Collections.IEnumerable,C1.LiveLinq.Order)">FindKeys(IEnumerable,Order)</see></para>
      </summary>
      <param name="keys">The key values to search for.</param>
      <param name="order">Optionally specifies the order of the key values to sort the result (<see cref="T:C1.LiveLinq.Order" />.<b>Unordered</b> if sorting is not required).</param>
      <returns>An object enumerating all items whose key values belong to the specified key value collection.</returns>
    </member>
    <member name="M:C1.LiveLinq.Indexing.Index`1.FindGreater(System.Object,System.Boolean,C1.LiveLinq.Order)">
      <summary>
        <para>Finds items with keys greater than the specified value.</para>
        <para>Implements <see cref="M:C1.LiveLinq.Indexing.Search.IIndexScanner`1.FindGreater(System.Object,System.Boolean,C1.LiveLinq.Order)">IIndexScanner(T).FindGreater(object,bool,Order)</see></para>
      </summary>
      <param name="key">Minimum key value to search for.</param>
      <param name="inclusive">If <b>true</b>, the result includes items with the 
            specified key value. Otherwise, the result only includes those with keys strictly greater than the specified value.</param>
      <param name="order">Optionally specifies the order of the key values to sort the result (<see cref="T:C1.LiveLinq.Order" />.<b>Unordered</b> if sorting is not required).</param>
      <returns>An object enumerating all items whose key values are greater than the specified value.</returns>
    </member>
    <member name="M:C1.LiveLinq.Indexing.Index`1.FindLess(System.Object,System.Boolean,C1.LiveLinq.Order)">
      <summary>
        <para>Finds items with keys less than the specified value.</para>
        <para>Implements <see cref="M:C1.LiveLinq.Indexing.Search.IIndexScanner`1.FindLess(System.Object,System.Boolean,C1.LiveLinq.Order)">IIndexScanner(T).FindLess(object,bool,Order)</see></para>
      </summary>
      <param name="key">Maximum key value to search for.</param>
      <param name="inclusive">If <b>true</b>, the result includes items with the 
            specified key value. Otherwise, the result only includes those with keys strictly less than the specified value.</param>
      <param name="order">Optionally specifies the order of the key values to sort the result (<see cref="T:C1.LiveLinq.Order" />.<b>Unordered</b> if sorting is not required).</param>
      <returns>An object enumerating all items whose key values are less than the specified value.</returns>
    </member>
    <member name="M:C1.LiveLinq.Indexing.Index`1.FindBetween(System.Object,System.Boolean,System.Object,System.Boolean,C1.LiveLinq.Order)">
      <summary>
        <para>Finds items with key values in the interval between the specified values.</para>
        <para>Implements <see cref="M:C1.LiveLinq.Indexing.Search.IIndexScanner`1.FindBetween(System.Object,System.Boolean,System.Object,System.Boolean,C1.LiveLinq.Order)">IIndexScanner(T).FindBetween(object,bool,object,bool,Order)</see></para>
      </summary>
      <param name="min">Minimum key value to search for.</param>
      <param name="minInclusive">If <b>true</b>, the result includes items with the minimum key value.</param>
      <param name="max">Maximum key value to search for.</param>
      <param name="maxInclusive">If <b>true</b>, the result includes items with the maximum key value.</param>
      <param name="order">Optionally specifies the order of the key values to sort the result (<see cref="T:C1.LiveLinq.Order" />.<b>Unordered</b> if sorting is not required).</param>
      <returns>An object enumerating all items with key values within the specified limits.</returns>
    </member>
    <member name="M:C1.LiveLinq.Indexing.Index`1.FindStartingWith(System.String,System.Func{System.String,System.Boolean},C1.LiveLinq.Order)">
      <summary>
        <para>Finds items with string key values starting with the specified string.</para>
        <para>Implements <see cref="M:C1.LiveLinq.Indexing.Search.IIndexScanner`1.FindStartingWith(System.String,System.Func{System.String,System.Boolean},C1.LiveLinq.Order)">IIndexScanner(T).FindStartingWith(string,Func(string, bool),Order)</see></para>
      </summary>
      <param name="value">The string to search for as the beginning of key value strings.</param>
      <param name="keyPredicate">An optional condition that found items must satisfy.</param>
      <param name="order">Optionally specifies the order of the key values to sort the result (<see cref="T:C1.LiveLinq.Order" />.<b>Unordered</b> if sorting is not required).</param>
      <returns>An object enumerating all items whose key values are strings that have a beginning matching the specified string and satisfy the optional condition.</returns>
    </member>
    <member name="M:C1.LiveLinq.Indexing.Index`1.Join``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Object},System.Func{`0,``0,``1},C1.LiveLinq.Indexing.Search.JoinOperator)">
      <summary>
        <para>Correlates the items of this indexed collection with the items of another sequence and returns the combined items with matching keys.</para>
        <para>Implements <see cref="M:C1.LiveLinq.Indexing.Search.IIndexScanner`1.Join``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Object},System.Func{`0,``0,``1},C1.LiveLinq.Indexing.Search.JoinOperator)">IIndexScanner(T).Join</see></para>
      </summary>
      <param name="source">The second sequence to join to this collection.</param>
      <param name="keySelector">A function to extract from a second sequence's item the value to match against this collection's key value.</param>
      <param name="resultSelector">A function to create a result element from two matching elements.</param>
      <param name="op">A comparison operator to match elements.</param>
      <typeparam name="T2">The type of the elements of the second sequence.</typeparam>
      <typeparam name="TResult">The type of the result elements.</typeparam>
      <returns>Enumeration of objects obtained by applying the result selector to pairs of joined elements of the two collections.</returns>
    </member>
    <member name="M:C1.LiveLinq.Indexing.Index`1.Join``2(C1.LiveLinq.Indexing.Search.IIndexScanner{``0},System.Func{`0,``0,``1},C1.LiveLinq.Indexing.Search.JoinOperator)">
      <summary>
        <para>Correlates the items of this indexed collection with the items of another indexed collection and returns the combined items with matching keys.</para>
        <para>Implements <see cref="M:C1.LiveLinq.Indexing.Search.IIndexScanner`1.Join``2(C1.LiveLinq.Indexing.Search.IIndexScanner{``0},System.Func{`0,``0,``1},C1.LiveLinq.Indexing.Search.JoinOperator)">IIndexScanner(T).Join</see></para>
      </summary>
      <param name="source">The second indexed collection to join to this collection.</param>
      <param name="resultSelector">A function to create a result element from two matching elements.</param>
      <param name="op">A comparison operator to match elements.</param>
      <typeparam name="T2">The type of the elements of the second collection.</typeparam>
      <typeparam name="TResult">The type of the result elements.</typeparam>
      <returns>Enumeration of objects obtained by applying the result selector to pairs of joined elements of the two collections.</returns>
      <remarks>Matching of two elements is performed by matching their keys.</remarks>
    </member>
    <member name="M:C1.LiveLinq.Indexing.Index`1.GroupJoin``2(C1.LiveLinq.Indexing.Search.IIndexScanner{``0},System.Func{`0,System.Collections.Generic.IEnumerable{``0},``1})">
      <summary>
        <para>Correlates the items of this indexed collection with the items of another indexed collection and groups the results by the item of this collection.</para>
        <para>Implements <see cref="M:C1.LiveLinq.Indexing.Search.IIndexScanner`1.GroupJoin``2(C1.LiveLinq.Indexing.Search.IIndexScanner{``0},System.Func{`0,System.Collections.Generic.IEnumerable{``0},``1})">IIndexScanner(T).GroupJoin</see></para>
      </summary>
      <param name="source">The second indexed collection to join to this collection.</param>
      <param name="resultSelector">A function to create a result element from an element from this collection and a collection of matching elements from the second collection.</param>
      <typeparam name="T2">The type of the elements of the second collection.</typeparam>
      <typeparam name="TResult">The type of the result elements.</typeparam>
      <returns>Enumeration of objects obtained by applying the result selector to group pairs,
            where each pair consists of an item of this collection and the corresponding enumeration of the items of the second collection joined to it.</returns>
      <remarks>Matching of two elements is performed by matching their keys.</remarks>
    </member>
    <member name="M:C1.LiveLinq.Indexing.Index`1.GroupJoin``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Object},System.Func{System.Collections.Generic.IEnumerable{`0},``0,``1})">
      <summary>
        <para>Correlates the items of this indexed collection with the items of another sequence and groups the results by the item of the second sequence.</para>
        <para>Implements <see cref="M:C1.LiveLinq.Indexing.Search.IIndexScanner`1.GroupJoin``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Object},System.Func{System.Collections.Generic.IEnumerable{`0},``0,``1})">IIndexScanner(T).GroupJoin</see></para>
      </summary>
      <param name="source">The second sequence to join to this collection.</param>
      <param name="keySelector">A function to extract from an item of the second sequence the value to match against this collection's key value.</param>
      <param name="resultSelector">A function to create a result element from an element of the second sequence and the collection of matching elements from this collection.</param>
      <typeparam name="T2">The type of the elements of the second sequence.</typeparam>
      <typeparam name="TResult">The type of the result elements.</typeparam>
      <returns>Enumeration of objects obtained by applying the result selector to group pairs,
            where each pair consists of an item of the second collection and the corresponding enumeration of the items of this collection joined to it.</returns>
    </member>
    <member name="M:C1.LiveLinq.Indexing.Index`1.GroupJoin``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Object},System.Func{`0,System.Collections.Generic.IEnumerable{``0},``1})">
      <summary>
        <para>Correlates the items of this indexed collection with the items of another sequence and groups the results by the item of this collection.</para>
        <para>Implements <see cref="M:C1.LiveLinq.Indexing.Search.IIndexScanner`1.GroupJoin``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Object},System.Func{`0,System.Collections.Generic.IEnumerable{``0},``1})">IIndexScanner(T).GroupJoin</see></para>
      </summary>
      <param name="source">The second sequence to join to this collection.</param>
      <param name="keySelector">A function to extract from an item of the second sequence the value to match against this collection's key value.</param>
      <param name="resultSelector">A function to create a result element from an element from this collection and a collection of matching elements from the second sequence.</param>
      <typeparam name="T2">The type of the elements of the second sequence.</typeparam>
      <typeparam name="TResult">The type of the result elements.</typeparam>
      <returns>Enumeration of objects obtained by applying the result selector to group pairs,
            where each pair consists of an item of this collection and the corresponding enumeration of the items of the second sequence joined to it.</returns>
    </member>
    <member name="P:C1.LiveLinq.Indexing.Index`1.ItemCount">
      <summary>Gets the number of elements in the indexed collection.</summary>
      <value>The number of elements in the indexed collection.</value>
    </member>
    <member name="P:C1.LiveLinq.Indexing.Index`1.KeyCount">
      <summary>Gets the number of distinct key values in all items of this collection.</summary>
      <value>Number of distinct key values in the collection.</value>
      <remarks>This number is not the same as <see cref="P:C1.LiveLinq.Indexing.Index`1.ItemCount" />, unless the index key
            is a unique key of that collection, see <see cref="P:C1.LiveLinq.Indexing.IndexDefinition`1.KeyIsUnique" />.</remarks>
    </member>
    <member name="T:C1.LiveLinq.SourceChangeEventArgs`1">
      <summary>Provides data for the <see cref="E:C1.LiveLinq.IObservableSource`1.Changed" /> event.</summary>
      <typeparam name="T">Type of the changed object.</typeparam>
    </member>
    <member name="M:C1.LiveLinq.SourceChangeEventArgs`1.#ctor(`0,C1.LiveLinq.SourceChangeType,System.Int32)">
      <summary>Initializes a new instance of the <see cref="T:C1.LiveLinq.SourceChangeEventArgs`1" /> class.</summary>
      <param name="item">Changed object.</param>
      <param name="changeType">Type of change.</param>
      <param name="ordinal">Ordinal position of the changed item.</param>
    </member>
    <member name="M:C1.LiveLinq.SourceChangeEventArgs`1.Equals(System.Object)">
      <summary>Determines whether the specified object is equal to the current object.</summary>
      <param name="obj">The object to compare with the current object.</param>
      <returns>
        <b>true</b> if the specified object is equal to the current one; otherwise, false.</returns>
    </member>
    <member name="M:C1.LiveLinq.SourceChangeEventArgs`1.GetHashCode">
      <summary>Return a hash code for this instance.</summary>
      <returns>A 32-bit signed integer hash code.</returns>
    </member>
    <member name="M:C1.LiveLinq.SourceChangeEventArgs`1.Equals(C1.LiveLinq.SourceChangeEventArgs{`0})">
      <summary>
            Determines whether the specified object is equal to the current object.
            </summary>
      <remarks>
            Two <see cref="T:C1.LiveLinq.SourceChangeEventArgs`1" /> are considered equal if the values of
            their <see cref="P:C1.LiveLinq.SourceChangeEventArgs`1.Item" /> and <see cref="P:C1.LiveLinq.SourceChangeEventArgs`1.ChangeType" /> properties are equal.
            </remarks>
      <param name="args">The object to compare with the current object.</param>
      <returns>
        <b>true</b> if the specified object is equal to the current one; otherwise, false.</returns>
    </member>
    <member name="M:C1.LiveLinq.SourceChangeEventArgs`1.ToString">
      <summary>Returns a string that represents this instance of <see cref="T:C1.LiveLinq.SourceChangeEventArgs`1" />. </summary>
    </member>
    <member name="P:C1.LiveLinq.SourceChangeEventArgs`1.Item">
      <summary>Gets the object that is being changed.</summary>
    </member>
    <member name="P:C1.LiveLinq.SourceChangeEventArgs`1.ChangeType">
      <summary>Gets the type of change.</summary>
    </member>
    <member name="P:C1.LiveLinq.SourceChangeEventArgs`1.Ordinal">
      <summary> Gets the ordinal position of the collection item that is being changed.</summary>
      <remarks> This property can return -1 (ordinal unknown) if the collection cannot provide this information
            (if <see cref="P:C1.LiveLinq.IObservableSource`1.SupportsItemOrdinals" /> returns <b>false</b>).
            </remarks>
    </member>
    <member name="T:C1.LiveLinq.SourceChangeType">
      <summary>
            Describes a change occurring in a collection.
            </summary>
    </member>
    <member name="F:C1.LiveLinq.SourceChangeType.Add">
      <summary>
            An item is added to the collection.
            </summary>
    </member>
    <member name="F:C1.LiveLinq.SourceChangeType.Modify">
      <summary>
            At least one of the properties of an item has changed its value.
            </summary>
    </member>
    <member name="F:C1.LiveLinq.SourceChangeType.Remove">
      <summary>
            An item is removed from the collection.
            </summary>
    </member>
    <member name="F:C1.LiveLinq.SourceChangeType.Reset">
      <summary>
            Multiple items have changed in the collection. Indexes must be rebuilt.
            </summary>
    </member>
    <member name="T:C1.LiveLinq.Indexing.Index`2">
      <summary>
            Indexes a collection by an expression (typically, by a field), providing fast access to items having particular
            values (or range of values) of that expression.
            </summary>
      <typeparam name="T">The type of the elements of the collection to index.</typeparam>
      <typeparam name="TKey">The type of the index key.</typeparam>
      <remarks>
        <para>Indexes can be created and added to a
            collection explicitly in code by calling <see cref="M:C1.LiveLinq.Indexing.IndexCollection`1.Add``1(System.Linq.Expressions.Expression{System.Func{`0,``0}})">IndexCollection.Add</see>, or their creation
            can be enforced in LINQ queries by using the <see cref="M:C1.LiveLinq.Hints.Indexed``1(``0,C1.LiveLinq.IndexingHintAction)">Indexed</see> hint.</para>
        <para>In LINQ queries, indexes are used for optimizing query performance if that is specified
            with an <see cref="M:C1.LiveLinq.Hints.Indexed``1(``0,C1.LiveLinq.IndexingHintAction)">Indexed</see> hint. Usually, hints are not required, because LiveLinq can
            automatically determine that an index can be used to speedup a query, but using hints 
            helps to ensure this optimization.</para>
        <para>Indexes can also be used programmatically in code, without LINQ syntax, by using the methods 
            of the <see cref="T:C1.LiveLinq.Indexing.Search.IIndexScanner`2" /> interface that is implemented by the <see cref="T:C1.LiveLinq.Indexing.Index`2" /> class.
            For example, you can call such methods as <see cref="M:C1.LiveLinq.Indexing.Index`2.Find(`1)">Find</see> directly for an <see cref="T:C1.LiveLinq.Indexing.Index`2" /> object.</para>
        <para>It must be kept in mind that every index you create
            introduces a trade-off: it can dramatically speed up searches, but it consumes memory and adds some (usually, small)
            overhead every time the indexed collection (or any of the items, its elements) is modified. This is why
            indexes should generally be kept only while you need them for queries.
            To delete an index, use <see cref="M:C1.LiveLinq.Indexing.IndexCollection`1.Remove(System.Linq.Expressions.LambdaExpression)">IndexCollection.Remove</see>.</para>
        <para>An index can have subindexes, see <see cref="T:C1.LiveLinq.Indexing.Subindex`2" />. Subindexes are optional,
            not required for any indexing tasks, but can provide additional optimization and help minimize memory requirements when a collection is 
            indexed by multiple keys. In presence of subindexes, an index is the root level of a tree of subindexes.</para>
      </remarks>
    </member>
    <member name="T:C1.LiveLinq.Indexing.Search.IIndexScanner`2">
      <summary>
            Represents an index or a subindex in its capacity of scanning through data. Provides methods for searching data items.
            </summary>
      <typeparam name="T">The type of the elements of the indexed collection.</typeparam>
      <typeparam name="TKey">The type of the index key.</typeparam>
      <remarks>
        <para>This interface is implemented by <see cref="T:C1.LiveLinq.Indexing.Index`2" />. It is also used by subindexes, but there it is not directly implemented by 
            <see cref="T:C1.LiveLinq.Indexing.Subindex`2" />, but rather returned by the <see cref="M:C1.LiveLinq.Indexing.Search.IndexQuery`1.Subindex(C1.LiveLinq.Indexing.Subindex{`0})">IndexQuery&lt;T&gt;.Subindex</see> method because it depends on 
            the item found by an index or a subindex that is the parent of that subindex.</para>
        <para>
          <see cref="T:C1.LiveLinq.Indexing.Search.IIndexScanner`2" /> has an untyped key counterpart <see cref="T:C1.LiveLinq.Indexing.Search.IIndexScanner`1" />
            that is used with untyped key classes <see cref="T:C1.LiveLinq.Indexing.Index`1" /> and <see cref="T:C1.LiveLinq.Indexing.Subindex`1" /></para>
      </remarks>
    </member>
    <member name="M:C1.LiveLinq.Indexing.Search.IIndexScanner`2.All(C1.LiveLinq.Order)">
      <summary>Gets all items in the indexed collection.</summary>
      <param name="order">Specifies the order of the key values to sort the result.</param>
      <returns>All items of the collection in the specified order of their key values.</returns>
    </member>
    <member name="M:C1.LiveLinq.Indexing.Search.IIndexScanner`2.Keys(C1.LiveLinq.Order)">
      <summary>Gets distinct key values in all items of this collection.</summary>
      <param name="order">Specifies the order of the key values to sort the result.</param>
      <returns>All distinct key values contained in the items of the collection in the specified order.</returns>
    </member>
    <member name="M:C1.LiveLinq.Indexing.Search.IIndexScanner`2.ContainsKey(`1)">
      <summary>Returns a value that indicates whether the collection contains an item with the given key value.</summary>
      <param name="key">The key value to search for</param>
      <returns>
        <b>true</b> if the collection contains an element with the specified key value; otherwise, <b>false</b>.</returns>
    </member>
    <member name="M:C1.LiveLinq.Indexing.Search.IIndexScanner`2.Find(`1)">
      <summary>
            Finds items with the specified key value.
            </summary>
      <param name="key">The key value to search for.</param>
      <returns>An object enumerating items having the specified key value.</returns>
    </member>
    <member name="M:C1.LiveLinq.Indexing.Search.IIndexScanner`2.FindKeys(System.Collections.Generic.IEnumerable{`1},C1.LiveLinq.Order)">
      <summary>
            Finds items containing any of the specified key values.
            </summary>
      <param name="keys">The key values to search for.</param>
      <param name="order">Optionally specifies the order of the key values to sort the result (<see cref="T:C1.LiveLinq.Order" />.<b>Unordered</b> if sorting is not required).</param>
      <returns>An object enumerating all items whose key values belong to the specified key value collection.</returns>
    </member>
    <member name="M:C1.LiveLinq.Indexing.Search.IIndexScanner`2.FindGreater(`1,System.Boolean,System.Func{`1,System.Boolean},C1.LiveLinq.Order)">
      <summary>
            Finds items with keys greater than the specified value.
            </summary>
      <param name="key">Minimum key value to search for.</param>
      <param name="inclusive">If <b>true</b>, the result includes items with the 
            specified key value. Otherwise, the result only includes those with keys strictly greater than the specified value.</param>
      <param name="keyPredicate">An optional condition that found items must satisfy.</param>
      <param name="order">Optionally specifies the order of the key values to sort the result (<see cref="T:C1.LiveLinq.Order" />.<b>Unordered</b> if sorting is not required).</param>
      <returns>An object enumerating all items whose key values are greater than the specified value.</returns>
    </member>
    <member name="M:C1.LiveLinq.Indexing.Search.IIndexScanner`2.FindLess(`1,System.Boolean,System.Func{`1,System.Boolean},C1.LiveLinq.Order)">
      <summary>
            Finds items with keys less than the specified value.
            </summary>
      <param name="key">Maximum key value to search for.</param>
      <param name="inclusive">If <b>true</b>, the result includes items with the 
            specified key value. Otherwise, the result only includes those with keys strictly less than the specified value.</param>
      <param name="keyPredicate">An optional condition that found items must satisfy.</param>
      <param name="order">Optionally specifies the order of the key values to sort the result (<see cref="T:C1.LiveLinq.Order" />.<b>Unordered</b> if sorting is not required).</param>
      <returns>An object enumerating all items whose key values are less than the specified value.</returns>
    </member>
    <member name="M:C1.LiveLinq.Indexing.Search.IIndexScanner`2.FindBetween(`1,System.Boolean,`1,System.Boolean,System.Func{`1,System.Boolean},C1.LiveLinq.Order)">
      <summary>
            Finds items with key values in the interval between the specified values.
            </summary>
      <param name="min">Minimum key value to search for.</param>
      <param name="minInclusive">If <b>true</b>, the result includes items with the minimum key value.</param>
      <param name="max">Maximum key value to search for.</param>
      <param name="maxInclusive">If <b>true</b>, the result includes items with the maximum key value.</param>
      <param name="keyPredicate">An optional condition that found items must satisfy.</param>
      <param name="order">Optionally specifies the order of the key values to sort the result (<see cref="T:C1.LiveLinq.Order" />.<b>Unordered</b> if sorting is not required).</param>
      <returns>An object enumerating all items with key values within the specified limits.</returns>
    </member>
    <member name="M:C1.LiveLinq.Indexing.Search.IIndexScanner`2.Join``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,`1},System.Func{`0,``0,``1},C1.LiveLinq.Indexing.Search.JoinOperator)">
      <summary>
            Correlates the items of this indexed collection with the items of another sequence and returns the combined items with matching keys.
            </summary>
      <param name="source">The second sequence to join to this collection.</param>
      <param name="keySelector">A function to extract from an item of the second sequence the value to match against this collection's key value.</param>
      <param name="resultSelector">A function to create a result element from two matching elements.</param>
      <param name="op">A comparison operator to match elements.</param>
      <typeparam name="T2">The type of the elements of the second sequence.</typeparam>
      <typeparam name="TResult">The type of the result elements.</typeparam>
      <returns>Enumeration of objects obtained by applying the result selector to pairs of joined elements of the two collections.</returns>
    </member>
    <member name="M:C1.LiveLinq.Indexing.Search.IIndexScanner`2.Join``2(C1.LiveLinq.Indexing.Search.IIndexScanner{``0,`1},System.Func{`0,``0,``1},C1.LiveLinq.Indexing.Search.JoinOperator)">
      <summary>
            Correlates the items of this indexed collection with the items of another indexed collection and returns the combined items with matching keys.
            </summary>
      <param name="source">The second indexed collection to join to this collection.</param>
      <param name="resultSelector">A function to create a result element from two matching elements.</param>
      <param name="op">A comparison operator to match elements.</param>
      <typeparam name="T2">The type of the elements of the second collection.</typeparam>
      <typeparam name="TResult">The type of the result elements.</typeparam>
      <returns>Enumeration of objects obtained by applying the result selector to pairs of joined elements of the two collections.</returns>
      <remarks>Matching of two elements is performed by matching their keys.</remarks>
    </member>
    <member name="M:C1.LiveLinq.Indexing.Search.IIndexScanner`2.GroupJoin``2(C1.LiveLinq.Indexing.Search.IIndexScanner{``0,`1},System.Func{`0,System.Collections.Generic.IEnumerable{``0},``1})">
      <summary>
            Correlates the items of this indexed collection with the items of another indexed collection and groups the results by the item of this collection.
            </summary>
      <param name="source">The second indexed collection to join to this collection.</param>
      <param name="resultSelector">A function to create a result element from an element from this collection and a collection of matching elements from the second collection.</param>
      <typeparam name="T2">The type of the elements of the second collection.</typeparam>
      <typeparam name="TResult">The type of the result elements.</typeparam>
      <returns>Enumeration of objects obtained by applying the result selector to group pairs,
            where each pair consists of an item of this collection and the corresponding enumeration of the items of the second collection joined to it.</returns>
      <remarks>Matching of two elements is performed by matching their keys.</remarks>
    </member>
    <member name="M:C1.LiveLinq.Indexing.Search.IIndexScanner`2.GroupJoin``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,`1},System.Func{System.Collections.Generic.IEnumerable{`0},``0,``1})">
      <summary>
            Correlates the items of this indexed collection with the items of another sequence and groups the results by the item of the second sequence.
            </summary>
      <param name="source">The second sequence to join to this collection.</param>
      <param name="keySelector">A function to extract from an item of the second sequence the value to match against this collection's key value.</param>
      <param name="resultSelector">A function to create a result element from an element of the second sequence and the collection of matching elements from this collection.</param>
      <typeparam name="T2">The type of the elements of the second sequence.</typeparam>
      <typeparam name="TResult">The type of the result elements.</typeparam>
      <returns>Enumeration of objects obtained by applying the result selector to group pairs,
            where each pair consists of an item of the second collection and the corresponding enumeration of the items of this collection joined to it.</returns>
    </member>
    <member name="M:C1.LiveLinq.Indexing.Search.IIndexScanner`2.GroupJoin``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,`1},System.Func{`0,System.Collections.Generic.IEnumerable{``0},``1})">
      <summary>
            Correlates the items of this indexed collection with the items of another sequence and groups the results by the item of this collection.
            </summary>
      <param name="source">The second sequence to join to this collection.</param>
      <param name="keySelector">A function to extract from an item of the second sequence the value to match against this collection's key value.</param>
      <param name="resultSelector">A function to create a result element from an element from this collection and a collection of matching elements from the second sequence.</param>
      <typeparam name="T2">The type of the elements of the second sequence.</typeparam>
      <typeparam name="TResult">The type of the result elements.</typeparam>
      <returns>Enumeration of objects obtained by applying the result selector to group pairs,
            where each pair consists of an item of this collection and the corresponding enumeration of the items of the second sequence joined to it.</returns>
    </member>
    <member name="M:C1.LiveLinq.Indexing.Index`2.All(C1.LiveLinq.Order)">
      <summary>Gets all items in the indexed collection.</summary>
      <param name="order">Specifies the order of the key values to sort the result.</param>
      <returns>An object enumerating all items of the collection in the specified order of their key values.</returns>
    </member>
    <member name="M:C1.LiveLinq.Indexing.Index`2.ContainsKey(`1)">
      <summary>Returns a value that indicates whether the collection contains an item with the given key value.</summary>
      <param name="key">The key value to search for.</param>
      <returns>
        <b>true</b> if the collection contains an element with the specified key value; otherwise, <b>false</b>.</returns>
    </member>
    <member name="M:C1.LiveLinq.Indexing.Index`2.Keys(C1.LiveLinq.Order)">
      <summary>Gets distinct key values in all items of the indexed collection.</summary>
      <param name="order">Specifies the order of the key values to sort the result.</param>
      <returns>All distinct key values contained in the items of the collection in the specified order.</returns>
    </member>
    <member name="M:C1.LiveLinq.Indexing.Index`2.Find(`1)">
      <summary>Finds items with the specified key value.</summary>
      <param name="key">The key value to search for.</param>
      <returns>An object enumerating items having the specified key value.</returns>
    </member>
    <member name="M:C1.LiveLinq.Indexing.Index`2.FindSingle(`1)">
      <summary>Finds the only item with the specified key value and throws an exception if there is not exactly one item with that key value.</summary>
      <param name="key">The key value to search for.</param>
      <returns>The item of the collection that contains the specified key value, if found.</returns>
    </member>
    <member name="M:C1.LiveLinq.Indexing.Index`2.FindKeys(System.Collections.Generic.IEnumerable{`1},C1.LiveLinq.Order)">
      <summary>
            Finds items containing any of the specified key values.
            </summary>
      <param name="keys">The key values to search for.</param>
      <param name="order">Optionally specifies the order of the key values to sort the result (<see cref="T:C1.LiveLinq.Order" />.<b>Unordered</b> if sorting is not required).</param>
      <returns>An object enumerating all items whose key values belong to the specified key value collection.</returns>
    </member>
    <member name="M:C1.LiveLinq.Indexing.Index`2.FindGreater(`1,System.Boolean,System.Func{`1,System.Boolean},C1.LiveLinq.Order)">
      <summary>
            Finds items with keys greater than the specified value.
            </summary>
      <param name="key">Minimum key value to search for.</param>
      <param name="inclusive">If <b>true</b>, the result includes items with the 
            specified key value. Otherwise, the result only includes those with keys strictly greater than the specified value.</param>
      <param name="keyPredicate">An optional condition that found items must satisfy.</param>
      <param name="order">Optionally specifies the order of the key values to sort the result (<see cref="T:C1.LiveLinq.Order" />.<b>Unordered</b> if sorting is not required).</param>
      <returns>An object enumerating all items whose key values are greater than the specified value.</returns>
    </member>
    <member name="M:C1.LiveLinq.Indexing.Index`2.FindLess(`1,System.Boolean,System.Func{`1,System.Boolean},C1.LiveLinq.Order)">
      <summary>
            Finds items with keys less than the specified value.
            </summary>
      <param name="key">Maximum key value to search for.</param>
      <param name="inclusive">If <b>true</b>, the result includes items with the 
            specified key value. Otherwise, the result only includes those with keys strictly less than the specified value.</param>
      <param name="keyPredicate">An optional condition that found items must satisfy.</param>
      <param name="order">Optionally specifies the order of the key values to sort the result (<see cref="T:C1.LiveLinq.Order" />.<b>Unordered</b> if sorting is not required).</param>
      <returns>An object enumerating all items whose key values are less than the specified value.</returns>
    </member>
    <member name="M:C1.LiveLinq.Indexing.Index`2.FindBetween(`1,System.Boolean,`1,System.Boolean,System.Func{`1,System.Boolean},C1.LiveLinq.Order)">
      <summary>
            Finds items with key values in the interval between the specified values.
            </summary>
      <param name="min">Minimum key value to search for.</param>
      <param name="minInclusive">If <b>true</b>, the result includes items with the minimum key value.</param>
      <param name="max">Maximum key value to search for.</param>
      <param name="maxInclusive">If <b>true</b>, the result includes items with the maximum key value.</param>
      <param name="keyPredicate">An optional condition that found items must satisfy.</param>
      <param name="order">Optionally specifies the order of the key values to sort the result (<see cref="T:C1.LiveLinq.Order" />.<b>Unordered</b> if sorting is not required).</param>
      <returns>An object enumerating all items with key values within the specified limits.</returns>
    </member>
    <member name="M:C1.LiveLinq.Indexing.Index`2.Join``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,`1},System.Func{`0,``0,``1},C1.LiveLinq.Indexing.Search.JoinOperator)">
      <summary>
        <para>Correlates the items of this indexed collection with the items of another sequence and returns the combined items with matching keys.</para>
        <para>Implements <see cref="M:C1.LiveLinq.Indexing.Search.IIndexScanner`2.Join``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,`1},System.Func{`0,``0,``1},C1.LiveLinq.Indexing.Search.JoinOperator)">IIndexScanner(T,TKey).Join</see></para>
      </summary>
      <param name="source">The second sequence to join to this collection.</param>
      <param name="keySelector">A function to extract from a second sequence's item the value to match against this collection's key value.</param>
      <param name="resultSelector">A function to create a result element from two matching elements.</param>
      <param name="op">A comparison operator to match elements.</param>
      <typeparam name="T2">The type of the elements of the second sequence.</typeparam>
      <typeparam name="TResult">The type of the result elements.</typeparam>
      <returns>Enumeration of objects obtained by applying the result selector to pairs of joined elements of the two collections.</returns>
    </member>
    <member name="M:C1.LiveLinq.Indexing.Index`2.Join``2(C1.LiveLinq.Indexing.Search.IIndexScanner{``0,`1},System.Func{`0,``0,``1},C1.LiveLinq.Indexing.Search.JoinOperator)">
      <summary>
        <para>Correlates the items of this indexed collection with the items of another indexed collection and returns the combined items with matching keys.</para>
        <para>Implements <see cref="M:C1.LiveLinq.Indexing.Search.IIndexScanner`2.Join``2(C1.LiveLinq.Indexing.Search.IIndexScanner{``0,`1},System.Func{`0,``0,``1},C1.LiveLinq.Indexing.Search.JoinOperator)">IIndexScanner(T,TKey).Join</see></para>
      </summary>
      <param name="source">The second indexed collection to join to this collection.</param>
      <param name="resultSelector">A function to create a result element from two matching elements.</param>
      <param name="op">A comparison operator to match elements.</param>
      <typeparam name="T2">The type of the elements of the second collection.</typeparam>
      <typeparam name="TResult">The type of the result elements.</typeparam>
      <returns>Enumeration of objects obtained by applying the result selector to pairs of joined elements of the two collections.</returns>
      <remarks>Matching of two elements is performed by matching their keys.</remarks>
    </member>
    <member name="M:C1.LiveLinq.Indexing.Index`2.GroupJoin``2(C1.LiveLinq.Indexing.Search.IIndexScanner{``0,`1},System.Func{`0,System.Collections.Generic.IEnumerable{``0},``1})">
      <summary>
        <para>Correlates the items of this indexed collection with the items of another indexed collection and groups the results by the item of this collection.</para>
        <para>Implements <see cref="M:C1.LiveLinq.Indexing.Search.IIndexScanner`2.GroupJoin``2(C1.LiveLinq.Indexing.Search.IIndexScanner{``0,`1},System.Func{`0,System.Collections.Generic.IEnumerable{``0},``1})">IIndexScanner(T,TKey).GroupJoin</see></para>
      </summary>
      <param name="source">The second indexed collection to join to this collection.</param>
      <param name="resultSelector">A function to create a result element from an element from this collection and a collection of matching elements from the second collection.</param>
      <typeparam name="T2">The type of the elements of the second collection.</typeparam>
      <typeparam name="TResult">The type of the result elements.</typeparam>
      <returns>Enumeration of objects obtained by applying the result selector to group pairs,
            where each pair consists of an item of this collection and the corresponding enumeration of the items of the second collection joined to it.</returns>
      <remarks>Matching of two elements is performed by matching their keys.</remarks>
    </member>
    <member name="M:C1.LiveLinq.Indexing.Index`2.GroupJoin``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,`1},System.Func{System.Collections.Generic.IEnumerable{`0},``0,``1})">
      <summary>
        <para>Correlates the items of this indexed collection with the items of another sequence and groups the results by the item of the second sequence.</para>
        <para>Implements <see cref="M:C1.LiveLinq.Indexing.Search.IIndexScanner`2.GroupJoin``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,`1},System.Func{System.Collections.Generic.IEnumerable{`0},``0,``1})">IIndexScanner(T,TKey).GroupJoin</see></para>
      </summary>
      <param name="source">The second sequence to join to this collection.</param>
      <param name="keySelector">A function to extract from an item of the second sequence the value to match against this collection's key value.</param>
      <param name="resultSelector">A function to create a result element from an element of the second sequence and the collection of matching elements from this collection.</param>
      <typeparam name="T2">The type of the elements of the second sequence.</typeparam>
      <typeparam name="TResult">The type of the result elements.</typeparam>
      <returns>Enumeration of objects obtained by applying the result selector to group pairs,
            where each pair consists of an item of the second collection and the corresponding enumeration of the items of this collection joined to it.</returns>
    </member>
    <member name="M:C1.LiveLinq.Indexing.Index`2.GroupJoin``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,`1},System.Func{`0,System.Collections.Generic.IEnumerable{``0},``1})">
      <summary>
        <para>Correlates the items of this indexed collection with the items of another sequence and groups the results by the item of this collection.</para>
        <para>Implements <see cref="M:C1.LiveLinq.Indexing.Search.IIndexScanner`2.GroupJoin``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,`1},System.Func{`0,System.Collections.Generic.IEnumerable{``0},``1})">IIndexScanner(T,TKey).GroupJoin</see></para>
      </summary>
      <param name="source">The second sequence to join to this collection.</param>
      <param name="keySelector">A function to extract from an item of the second sequence the value to match against this collection's key value.</param>
      <param name="resultSelector">A function to create a result element from an element from this collection and a collection of matching elements from the second sequence.</param>
      <typeparam name="T2">The type of the elements of the second sequence.</typeparam>
      <typeparam name="TResult">The type of the result elements.</typeparam>
      <returns>Enumeration of objects obtained by applying the result selector to group pairs,
            where each pair consists of an item of this collection and the corresponding enumeration of the items of the second sequence joined to it.</returns>
    </member>
    <member name="P:C1.LiveLinq.Indexing.Index`2.KeySelector">
      <summary>
            Gets the expression used to obtain key value from an element of the indexed collection.
            </summary>
      <returns>An expression calculating the key value from an item (element of the collection).
            Typically, this is a field or a property in the item class, although more complex expressions can also be used.</returns>
    </member>
    <member name="T:C1.LiveLinq.Indexing.Search.IndexQuery`2">
      <summary>
            Represents a collection that is the result of an index search. Objects of this class are returned by the
            <see cref="T:C1.LiveLinq.Indexing.Search.IIndexScanner`2" /> search methods.
            </summary>
      <typeparam name="T">The type of the elements of the indexed collection.</typeparam>
      <typeparam name="TKey">The type of the index key.</typeparam>
      <seealso cref="T:C1.LiveLinq.Indexing.Search.IndexQuery`1" />
    </member>
    <member name="T:C1.LiveLinq.Indexing.Search.IndexQuery`1">
      <summary>
            Represents a collection that is the result of an index search. Objects of this class are returned by the
            <see cref="T:C1.LiveLinq.Indexing.Search.IIndexScanner`1" /> search methods. This class has a derived class <see cref="T:C1.LiveLinq.Indexing.Search.IndexQuery`2" />
            with specific type of the key used for the index search.
            </summary>
      <typeparam name="T">The type of the elements of the indexed collection.</typeparam>
      <seealso cref="T:C1.LiveLinq.Indexing.Search.IndexQuery`2" />
    </member>
    <member name="M:C1.LiveLinq.Indexing.Search.IndexQuery`1.Subindex``1(C1.LiveLinq.Indexing.Subindex{`0,``0})">
      <summary>Used to apply subindex search to the result of a search operation.</summary>
      <typeparam name="TKey">Type of the subindex key.</typeparam>
      <remarks>
            A subindex can be used to further narrow the result of a search operation,
            if the corresponding subindex exists in the index or subindex used to perform that search operation. For example,
            <code>
            var idxByCity = customers.Indexes(c =&gt; c.City);
            var subindexByContactTitle = idxByCity.Subindexes(c =&gt; c.ContactTitle);
            var ownersInLondon = idxByCity.Find("London").Subindex(subindexByContactTitle).Find("Owner");
            </code></remarks>
      <param name="definition">Subindex to use for narrowing the search.</param>
      <returns>An <see cref="T:C1.LiveLinq.Indexing.Search.IIndexScanner`2" /> collection indexed by the subindex that can be used to perform search operations narrowing the collection.</returns>
    </member>
    <member name="M:C1.LiveLinq.Indexing.Search.IndexQuery`1.Subindex(C1.LiveLinq.Indexing.Subindex{`0})">
      <summary>Used to apply subindex search to the result of a search operation.</summary>
      <remarks>
            A subindex can be used to further narrow the result of a search operation,
            if the corresponding subindex exists in the index or subindex used to perform that search operation. For example,
            <code>
            var idxByCity = customers.Indexes(c =&gt; c.City);
            var subindexByContactTitle = idxByCity.Subindexes(c =&gt; c.ContactTitle);
            var ownersInLondon = idxByCity.Find("London").Subindex&lt;string&gt;(subindexByContactTitle).Find("Owner");
            </code></remarks>
      <param name="definition">Subindex to use for narrowing the search.</param>
      <returns>An <see cref="T:C1.LiveLinq.Indexing.Search.IIndexScanner`1" /> collection indexed by the subindex that can be used to perform search operations narrowing the collection.</returns>
    </member>
    <member name="M:C1.LiveLinq.Indexing.Search.IndexQuery`1.GroupByUntypedKey">
      <summary>Groups the collection of search results by its search key.</summary>
      <seealso cref="T:C1.LiveLinq.Indexing.Search.IndexedGroup`1" />
      <seealso cref="M:C1.LiveLinq.Indexing.Search.IndexQuery`2.GroupByKey" />
      <returns>Search result collection grouped by its search key.</returns>
    </member>
    <member name="M:C1.LiveLinq.Indexing.Search.IndexQuery`1.GetEnumerator">
      <summary>Returns an enumerator that iterates through the <see cref="T:C1.LiveLinq.Indexing.Search.IndexQuery`1" />.</summary>
    </member>
    <member name="P:C1.LiveLinq.Indexing.Search.IndexQuery`1.Indexes">
      <summary>The collection of subindexes for this <see cref="T:C1.LiveLinq.Indexing.Search.IndexQuery`1" />.</summary>
    </member>
    <member name="T:C1.LiveLinq.Indexing.ScannerCollection`1">
      <summary>
            Represents a collection of indexes or subindexes.
            </summary>
      <remarks>
        <para>Any indexed collection (implementing the <see cref="T:C1.LiveLinq.Indexing.IIndexedSource`1" /> interface) has a 
            collection of indexes attached to it. <b>ScannerCollection&lt;T&gt;</b> is the base class 
            for the collection of indexes, <see cref="T:C1.LiveLinq.Indexing.IndexCollection`1" /></para>
        <para>The <see cref="T:C1.LiveLinq.Indexing.ScannerCollection`1" /> class is also used in the <see cref="P:C1.LiveLinq.Indexing.Search.IndexQuery`1.Indexes">Indexes</see>
            property of the <see cref="T:C1.LiveLinq.Indexing.Search.IndexQuery`1" /> class,
            the result of an indexing search operation such as <see cref="M:C1.LiveLinq.Indexing.Index`2.Find(`1)">Index.Find</see>
            and others, where it contains subindexes.</para>
      </remarks>
      <typeparam name="T">The type of the elements of the indexed collection.</typeparam>
    </member>
    <member name="M:C1.LiveLinq.Indexing.ScannerCollection`1.Add``1(System.Linq.Expressions.Expression{System.Func{`0,``0}},System.Boolean,System.Boolean,C1.LiveLinq.Indexing.IndexingAlgorithm,System.Globalization.CultureInfo)">
      <summary>Creates a new index and adds it to the collection of indexes.</summary>
      <typeparam name="TKey">The type of the index key.</typeparam>
      <param name="keySelector">Key selector expression of the index, see <see cref="P:C1.LiveLinq.Indexing.IndexDefinition`1.KeySelector" />.</param>
      <param name="keyIsUnique">Specifies whether the key used in this index is a unique key for the indexed collection (default: <b>false</b>).</param>
      <param name="onlyOnce">Specifies whether it is required that the index does not exist prior to this method call (default: <b>false</b>).
            If an index with this <i>keySelector</i> already exists, an exception is thrown if it is <b>true</b>,
            and this method call is ignored if it is <b>false</b>.</param>
      <param name="algorithm">An <see cref="T:C1.LiveLinq.Indexing.IndexingAlgorithm" /> used by the index. In the current version, only one algorithm 
            is supported, RedBlackTree. Later versions may support other algorithms, such as bitmap or hash indexes.</param>
      <param name="locale">Locale information used to compare strings in the index (default: <see cref="P:System.Globalization.CultureInfo.CurrentCulture">CultureInfo.CurrentCulture</see>).</param>
      <returns>The new index added to the collection of indexes.</returns>
      <remarks>
        <para>A unique index occupies less memory and performs better than a non-unique index (although the difference isn't dramatic).
            Therefore, for unique keys, it's recommended to specify the corresponding index as unique.</para>
        <para>But do that only if you are sure that the key is indeed unique, as it imposes a uniqueness constraint on the indexed collection.
            An attempt to modify the indexed collection violating the uniqueness throws an <see cref="T:System.InvalidOperationException" />.</para>
      </remarks>
    </member>
    <member name="M:C1.LiveLinq.Indexing.ScannerCollection`1.Add``1(System.Linq.Expressions.Expression{System.Func{`0,``0}},System.Boolean,System.Boolean,System.Globalization.CultureInfo)">
      <summary>Creates a new index and adds it to the collection of indexes.</summary>
      <typeparam name="TKey">The type of the index key.</typeparam>
      <param name="keySelector">Key selector expression of the index, see <see cref="P:C1.LiveLinq.Indexing.IndexDefinition`1.KeySelector" />.</param>
      <param name="keyIsUnique">Specifies whether the key used in this index is a unique key for the indexed collection (default: <b>false</b>).</param>
      <param name="onlyOnce">Specifies whether it is required that the index does not exist prior to this method call (default: <b>false</b>).
            If an index with this <i>keySelector</i> already exists, an exception is thrown if it is <b>true</b>,
            and this method call is ignored if it is <b>false</b>.</param>
      <param name="locale">Locale information used to compare strings in the index (default: <see cref="P:System.Globalization.CultureInfo.CurrentCulture">CultureInfo.CurrentCulture</see>).</param>
      <returns>The new index added to the collection of indexes.</returns>
      <remarks>
        <para>A unique index occupies less memory and performs better than a non-unique index (although the difference isn't dramatic).
            Therefore, for unique keys, it's recommended to specify the corresponding index as unique.</para>
        <para>But do that only if you are sure that the key is indeed unique, as it imposes a uniqueness constraint on the indexed collection.
            An attempt to modify the indexed collection violating the uniqueness throws an <see cref="T:System.InvalidOperationException" />.</para>
      </remarks>
    </member>
    <member name="M:C1.LiveLinq.Indexing.ScannerCollection`1.Add``1(System.Linq.Expressions.Expression{System.Func{`0,``0}},System.Boolean,System.Boolean)">
      <summary>Creates a new index and adds it to the collection of indexes.</summary>
      <typeparam name="TKey">The type of the index key.</typeparam>
      <param name="keySelector">Key selector expression of the index, see <see cref="P:C1.LiveLinq.Indexing.IndexDefinition`1.KeySelector" />.</param>
      <param name="keyIsUnique">Specifies whether the key used in this index is a unique key for the indexed collection (default: <b>false</b>).</param>
      <param name="onlyOnce">Specifies whether it is required that the index does not exist prior to this method call (default: <b>false</b>).
            If an index with this <i>keySelector</i> already exists, an exception is thrown if it is <b>true</b>,
            and this method call is ignored if it is <b>false</b>.</param>
      <returns>The new index added to the collection of indexes.</returns>
      <remarks>
        <para>A unique index occupies less memory and performs better than a non-unique index (although the difference isn't dramatic).
            Therefore, for unique keys, it's recommended to specify the corresponding index as unique.</para>
        <para>But do that only if you are sure that the key is indeed unique, as it imposes a uniqueness constraint on the indexed collection.
            An attempt to modify the indexed collection violating the uniqueness throws an <see cref="T:System.InvalidOperationException" />.</para>
      </remarks>
    </member>
    <member name="M:C1.LiveLinq.Indexing.ScannerCollection`1.Add``1(System.Linq.Expressions.Expression{System.Func{`0,``0}},System.Boolean)">
      <summary>Creates a new index and adds it to the collection of indexes.</summary>
      <typeparam name="TKey">The type of the index key.</typeparam>
      <param name="keySelector">Key selector expression of the index, see <see cref="P:C1.LiveLinq.Indexing.IndexDefinition`1.KeySelector" />.</param>
      <param name="keyIsUnique">Specifies whether the key used in this index is a unique key for the indexed collection (default: <b>false</b>).</param>
      <returns>The new index added to the collection of indexes.</returns>
      <remarks>
        <para>A unique index occupies less memory and performs better than a non-unique index (although the difference isn't dramatic).
            Therefore, for unique keys, it's recommended to specify the corresponding index as unique.</para>
        <para>But do that only if you are sure that the key is indeed unique, as it imposes a uniqueness constraint on the indexed collection.
            An attempt to modify the indexed collection violating the uniqueness throws an <see cref="T:System.InvalidOperationException" />.</para>
      </remarks>
    </member>
    <member name="M:C1.LiveLinq.Indexing.ScannerCollection`1.Add``1(System.Linq.Expressions.Expression{System.Func{`0,``0}})">
      <summary>Creates a new index and adds it to the collection of indexes.</summary>
      <typeparam name="TKey">The type of the index key.</typeparam>
      <param name="keySelector">Key selector expression of the index, see <see cref="P:C1.LiveLinq.Indexing.IndexDefinition`1.KeySelector" />.</param>
      <returns>The new index added to the collection of indexes.</returns>
    </member>
    <member name="M:C1.LiveLinq.Indexing.ScannerCollection`1.Add(System.Linq.Expressions.LambdaExpression,System.Boolean,System.Boolean,C1.LiveLinq.Indexing.IndexingAlgorithm,System.Globalization.CultureInfo)">
      <summary>Creates a new index and adds it to the collection of indexes.</summary>
      <param name="keySelector">Key selector expression of the index, see <see cref="P:C1.LiveLinq.Indexing.IndexDefinition`1.KeySelector" />.</param>
      <param name="keyIsUnique">Specifies whether the key used in this index is a unique key for the indexed collection (default: <b>false</b>).</param>
      <param name="onlyOnce">Specifies whether it is required that the index does not exist prior to this method call.
            If an index with this <i>keySelector</i> already exists, an exception is thrown if it is <b>true</b>,
            and this method call is ignored if it is <b>false</b>.</param>
      <param name="algorithm">An <see cref="T:C1.LiveLinq.Indexing.IndexingAlgorithm" /> used by the index. In the current version, only one algorithm 
            is supported, RedBlackTree. Later versions may support other algorithms, such as bitmap or hash indexes.</param>
      <param name="locale">Locale information used to compare strings in the index (default: <see cref="P:System.Globalization.CultureInfo.CurrentCulture">CultureInfo.CurrentCulture</see>).</param>
      <returns>The new index added to the collection of indexes.</returns>
      <remarks>
        <para>A unique index occupies less memory and performs better than a non-unique index (although the difference isn't dramatic).
            Therefore, for unique keys, it's recommended to specify the corresponding index as unique.</para>
        <para>But do that only if you are sure that the key is indeed unique, as it imposes a uniqueness constraint on the indexed collection.
            An attempt to modify the indexed collection violating the uniqueness throws an <see cref="T:System.InvalidOperationException" />.</para>
      </remarks>
    </member>
    <member name="M:C1.LiveLinq.Indexing.ScannerCollection`1.Find(System.Linq.Expressions.LambdaExpression)">
      <summary>Finds an index in the collection by its key selector.</summary>
      <param name="keySelector">Key selector expression of an index, see <see cref="P:C1.LiveLinq.Indexing.IndexDefinition`1.KeySelector" />.</param>
      <returns>An index with the given key selector, if it is found; otherwise, <b>null</b>.</returns>
    </member>
    <member name="M:C1.LiveLinq.Indexing.ScannerCollection`1.Find``1(System.Linq.Expressions.Expression{System.Func{`0,``0}})">
      <summary>Finds an index in the collection by its key selector.</summary>
      <typeparam name="TKey">The type of the index key.</typeparam>
      <param name="keySelector">Key selector expression of an index, see <see cref="P:C1.LiveLinq.Indexing.IndexDefinition`1.KeySelector" />.</param>
      <returns>An index with the given key selector, if it is found; otherwise, <b>null</b>.</returns>
    </member>
    <member name="M:C1.LiveLinq.Indexing.ScannerCollection`1.Contains(System.Linq.Expressions.LambdaExpression)">
      <summary>Determines whether an index with the specified key selector exists in the collection.</summary>
      <param name="keySelector">Key selector expression of an index, see <see cref="P:C1.LiveLinq.Indexing.IndexDefinition`1.KeySelector" />.</param>
      <returns>
        <b>true</b> if an index with the specified key selector is found in the collection; otherwise, <b>false</b>.</returns>
    </member>
    <member name="M:C1.LiveLinq.Indexing.ScannerCollection`1.Contains``1(System.Linq.Expressions.Expression{System.Func{`0,``0}})">
      <summary>Determines whether an index with the specified key selector exists in the collection.</summary>
      <typeparam name="TKey">The type of the index key.</typeparam>
      <param name="keySelector">Key selector expression of an index, see <see cref="P:C1.LiveLinq.Indexing.IndexDefinition`1.KeySelector" />.</param>
      <returns>
        <b>true</b> if an index with the specified key selector is found in the collection; otherwise, <b>false</b>.</returns>
    </member>
    <member name="M:C1.LiveLinq.Indexing.ScannerCollection`1.Remove(System.Linq.Expressions.LambdaExpression)">
      <summary>Removes an index from the collection.</summary>
      <param name="keySelector">Key selector expression of an index, see <see cref="P:C1.LiveLinq.Indexing.IndexDefinition`1.KeySelector" />.</param>
      <returns>
        <b>true</b> if an index has been removed; <b>false</b> if there is no index with the given key selector in the collection.</returns>
    </member>
    <member name="M:C1.LiveLinq.Indexing.ScannerCollection`1.Remove``1(System.Linq.Expressions.Expression{System.Func{`0,``0}})">
      <summary>Removes an index from the collection.</summary>
      <typeparam name="TKey">The type of the index key.</typeparam>
      <param name="keySelector">Key selector expression of an index, see <see cref="P:C1.LiveLinq.Indexing.IndexDefinition`1.KeySelector" />.</param>
      <returns>
        <b>true</b> if an index has been removed; <b>false</b> if there is no index with the given key selector in the collection.</returns>
    </member>
    <member name="M:C1.LiveLinq.Indexing.ScannerCollection`1.GetEnumerator">
      <summary>Returns an enumerator that iterates through the <see cref="T:C1.LiveLinq.Indexing.ScannerCollection`1" />.</summary>
    </member>
    <member name="M:C1.LiveLinq.Indexing.ScannerCollection`1.Clear">
      <summary>Clears the collection of all indexes. All indexes are detached from the indexed collection and destroyed.</summary>
    </member>
    <member name="P:C1.LiveLinq.Indexing.ScannerCollection`1.Count">
      <summary>Gets the number of indexes in the collection.</summary>
      <value>The number of indexes in the collection.</value>
    </member>
    <member name="M:C1.LiveLinq.Indexing.Search.IndexQuery`2.GroupByKey">
      <summary>Groups the collection of search results by its search key.</summary>
      <seealso cref="T:C1.LiveLinq.Indexing.Search.IndexedGroup`2" />
      <seealso cref="M:C1.LiveLinq.Indexing.Search.IndexQuery`1.GroupByUntypedKey" />
      <returns>Search result collection grouped by its search key.</returns>
    </member>
    <member name="M:C1.LiveLinq.Indexing.Search.IndexQuery`2.GroupByUntypedKey">
      <summary>Groups the collection of search results by its search key.</summary>
      <seealso cref="T:C1.LiveLinq.Indexing.Search.IndexedGroup`1" />
      <seealso cref="M:C1.LiveLinq.Indexing.Search.IndexQuery`2.GroupByKey" />
      <returns>Search result collection grouped by its search key.</returns>
    </member>
    <member name="T:C1.LiveLinq.Indexing.Search.GroupingQuery`1">
      <summary>
            Represents a collection of <see cref="T:C1.LiveLinq.Indexing.Search.IndexedGroup`1" />, groups of elements with the same key, resulting from a search operation with grouping.
            This class has a derived class <see cref="T:C1.LiveLinq.Indexing.Search.GroupingQuery`2" /> with specific type of the key used for the index search.
            </summary>
      <remarks>
            The result of any index search operation, <see cref="T:C1.LiveLinq.Indexing.Search.IndexQuery`1" /> can be grouped by applying <see cref="M:C1.LiveLinq.Indexing.Search.IndexQuery`1.GroupByUntypedKey" />.
            It is grouped by the key that was used to perform the search operation. For example,
            <code>
            customers.Indexes(c =&gt; c.City).All().GroupByUntypedKey();
            customers.Indexes(c =&gt; c.City).FindBetween("A", "Z").GroupByUntypedKey();
            </code></remarks>
      <typeparam name="T">The type of the elements of the indexed collection.</typeparam>
      <seealso cref="T:C1.LiveLinq.Indexing.Search.IndexedGroup`2" />
    </member>
    <member name="M:C1.LiveLinq.Indexing.Search.GroupingQuery`1.GetEnumerator">
      <summary>Returns an enumerator that iterates through the <see cref="T:C1.LiveLinq.Indexing.Search.GroupingQuery`1" />.</summary>
    </member>
    <member name="T:C1.LiveLinq.Indexing.Search.GroupingQuery`2">
      <summary>
            Represents a collection of <see cref="T:C1.LiveLinq.Indexing.Search.IndexedGroup`2" />, groups of elements with the same key, resulting from a search operation with grouping.
            </summary>
      <remarks>
            The result of any index search operation, <see cref="T:C1.LiveLinq.Indexing.Search.IndexQuery`2" /> can be grouped by applying <see cref="M:C1.LiveLinq.Indexing.Search.IndexQuery`2.GroupByKey" />.
            It is grouped by the key that was used to perform the search operation. For example,
            <code>
            customers.Indexes(c =&gt; c.City).All().GroupByKey();
            customers.Indexes(c =&gt; c.City).FindBetween("A", "Z").GroupByKey();
            </code></remarks>
      <typeparam name="T">The type of the elements of the indexed collection.</typeparam>
      <seealso cref="T:C1.LiveLinq.Indexing.Search.IndexedGroup`1" />
      <typeparam name="TKey">The type of the index key.</typeparam>
    </member>
    <member name="M:C1.LiveLinq.Indexing.Search.GroupingQuery`2.GetEnumerator">
      <summary>Returns an enumerator that iterates through the <see cref="T:C1.LiveLinq.Indexing.Search.GroupingQuery`2" />.</summary>
    </member>
    <member name="T:C1.LiveLinq.Indexing.Search.IndexedGroup`2">
      <summary>
            Represents a group of elements with the same key belonging to a collection of groups resulting from a search operation with grouping.
            </summary>
      <typeparam name="T">The type of the elements of the indexed collection.</typeparam>
      <typeparam name="TKey">The type of the index key.</typeparam>
      <seealso cref="T:C1.LiveLinq.Indexing.Search.GroupingQuery`2" />
      <seealso cref="T:C1.LiveLinq.Indexing.Search.IndexedGroup`1" />
    </member>
    <member name="T:C1.LiveLinq.Indexing.Search.IndexedGroup`1">
      <summary>
            Represents a group of elements with the same key belonging to a collection of groups resulting from a search operation with grouping.
            This class has a derived class <see cref="T:C1.LiveLinq.Indexing.Search.IndexedGroup`2" /> with specific key type.
            </summary>
      <typeparam name="T">The type of the elements of the indexed collection.</typeparam>
      <seealso cref="T:C1.LiveLinq.Indexing.Search.GroupingQuery`1" />
      <seealso cref="T:C1.LiveLinq.Indexing.Search.IndexedGroup`2" />
    </member>
    <member name="P:C1.LiveLinq.Indexing.Search.IndexedGroup`1.Key">
      <summary>Gets the key of the <see cref="T:C1.LiveLinq.Indexing.Search.IndexedGroup`1" />.</summary>
      <returns>The key of the <see cref="T:C1.LiveLinq.Indexing.Search.IndexedGroup`1" />.</returns>
    </member>
    <member name="P:C1.LiveLinq.Indexing.Search.IndexedGroup`1.KeyType">
      <summary>Gets the type of the key of the <see cref="T:C1.LiveLinq.Indexing.Search.IndexedGroup`1" />.</summary>
      <returns>Type of the key of the <see cref="T:C1.LiveLinq.Indexing.Search.IndexedGroup`1" />.</returns>
    </member>
    <member name="P:C1.LiveLinq.Indexing.Search.IndexedGroup`2.KeyType">
      <summary>Gets the type of the key of the <see cref="T:C1.LiveLinq.Indexing.Search.IndexedGroup`2" />.</summary>
      <returns>The same type as the <i>TKey</i> type parameter of the class.</returns>
    </member>
    <member name="P:C1.LiveLinq.Indexing.Search.IndexedGroup`2.Key">
      <summary>Gets the key of the <see cref="T:C1.LiveLinq.Indexing.Search.IndexedGroup`2" />.</summary>
      <returns>The key of the <see cref="T:C1.LiveLinq.Indexing.Search.IndexedGroup`2" />.</returns>
    </member>
    <member name="T:C1.LiveLinq.Indexing.Subindex`2">
      <summary>Defines a subindex, an index definition subordinate to another index definition, its parent.</summary>
      <typeparam name="T">The type of the elements of the collection to index.</typeparam>
      <typeparam name="TKey">The type of the index key.</typeparam>
      <remarks>
        <para>An index (<see cref="T:C1.LiveLinq.Indexing.Index`2" />) can have subindexes. Subindexes are optional,
            not required for any indexing tasks, but can provide additional optimization and help minimize memory requirements when a collection is 
            indexed by multi-level (multi-field) keys.</para>
        <para>
            Suppose we want to index a Customers table by two fields, (City, Rating), perhaps for speeding up queries like
            <code>from c in Customers where c.City == "London" &amp;&amp; c.Rating == 1 select c</code>
            We can do it by defining an index with key selector <c>c =&gt; new { c.City, c.Rating }</c> , that will index the table by two fields, creating a multi-field index.
            Such index will suffice for optimizing the query above, but it will not optimize, for example, the following query:
            <code>from c in Customers where c.City == "London" &amp;&amp; c.Rating &gt; 2 select c</code>
            Also, multi-field indexes occupy more memory than necessary because they have to store repeated field values.
            </para>
        <para>
            Subindexes provide a better alternative for optimizing multi-field searches. In the example above, we can define an index by City
            and create a subindex of that index, by Rating. Using subindexes becomes even more effective when, as it is often happens,
            we also need queries to search by additional fields, like, for example, if we need to search by ContactTitle inside a city
            in addition to the search by Rating inside a city:
            <code>from c in Customers where c.City == "London" &amp;&amp; c.ContactTitle == "Owner" select c</code>
            All we have to do now is to add a second subindex to the index by City, a subindex by ContactTitle.
            </para>
      </remarks>
    </member>
    <member name="T:C1.LiveLinq.Indexing.Subindex`1">
      <summary>
            Base class for the <see cref="T:C1.LiveLinq.Indexing.Subindex`2" /> class.
            </summary>
      <typeparam name="T">The type of the elements of the collection to index.</typeparam>
      <remarks>
            You don't typically use the <see cref="T:C1.LiveLinq.Indexing.Subindex`1" /> class directly. It provides functionality of the <see cref="T:C1.LiveLinq.Indexing.Subindex`2" /> class that does not depend on the
            index key type. The base class <see cref="T:C1.LiveLinq.Indexing.Subindex`1" /> is needed only if the index key type is not known, usually in general-purpose code intended for reuse with different key types.
            </remarks>
    </member>
    <member name="P:C1.LiveLinq.Indexing.Subindex`1.Parent">
      <summary>Parent of this subindex definition in the index/subindexes hierarchy.</summary>
    </member>
    <member name="P:C1.LiveLinq.Indexing.Subindex`2.KeySelector">
      <summary>
            Gets the expression used to obtain key value from an element of the indexed collection.
            </summary>
      <value>An expression calculating the key value from an item (element of the collection).
            Typically, this is a field or a property in the item class, although more complex expressions can also be used.</value>
    </member>
    <member name="T:C1.LiveLinq.Indexing.Search.JoinOperator">
      <summary> A comparison operator to match elements in a join operation. </summary>
    </member>
    <member name="F:C1.LiveLinq.Indexing.Search.JoinOperator.Equal">
      <summary>
        <b>a</b> is equal to <b>b</b> (<b>a</b> == <b>b</b>)</summary>
    </member>
    <member name="F:C1.LiveLinq.Indexing.Search.JoinOperator.Less">
      <summary>
        <b>a</b> is less than <b>b</b> (<b>a</b> &lt; <b>b</b>)</summary>
    </member>
    <member name="F:C1.LiveLinq.Indexing.Search.JoinOperator.LessOrEqual">
      <summary>
        <b>a</b> is less than or equal to <b>b</b> (<b>a</b> &lt;= <b>b</b>)</summary>
    </member>
    <member name="F:C1.LiveLinq.Indexing.Search.JoinOperator.Greater">
      <summary>
        <b>a</b> is greater than <b>b</b> (<b>a</b> &gt; <b>b</b>)</summary>
    </member>
    <member name="F:C1.LiveLinq.Indexing.Search.JoinOperator.GreaterOrEqual">
      <summary>
        <b>a</b> is greater than or equal to <b>b</b> (<b>a</b> &gt;= <b>b</b>)</summary>
    </member>
    <member name="T:C1.LiveLinq.QueryOptimizationException">
      <summary>
            Represents an exception that is thrown when <see cref="T:C1.LiveLinq.Hints" /> in a query require
            using a certain mandatory optimization which is impossible in the current query context.
            </summary>
    </member>
    <member name="M:C1.LiveLinq.QueryOptimizationException.#ctor">
      <summary>Initializes a new instance of the <see cref="T:C1.LiveLinq.QueryOptimizationException" /> class. This is the default constructor.</summary>
    </member>
    <member name="M:C1.LiveLinq.QueryOptimizationException.#ctor(System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:C1.LiveLinq.QueryOptimizationException" /> class with the specified string.
            </summary>
      <param name="message">The string to display when the exception is thrown.</param>
    </member>
    <member name="M:C1.LiveLinq.QueryOptimizationException.#ctor(System.String,System.Exception)">
      <summary>Initializes a new instance of the <see cref="T:C1.LiveLinq.QueryOptimizationException" /> class using the specified string and inner exception.</summary>
      <param name="message">The string to display when the exception is thrown.</param>
      <param name="inner">Gets the <b>Exception</b> instance that caused the current exception.</param>
    </member>
    <member name="M:C1.LiveLinq.QueryOptimizationException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>Initializes a new instance of the <see cref="T:C1.LiveLinq.QueryOptimizationException" /> class from serialized data.</summary>
      <param name="info">The object that holds the serialized object data.</param>
      <param name="context">The contextual information about the source or destination.</param>
    </member>
    <member name="T:C1.LiveLinq.LiveViewExtensions">
      <summary>
            Provides a set of static (extension) methods used in queries to define live views.
            </summary>
    </member>
    <member name="M:C1.LiveLinq.LiveViewExtensions.LiveAggregate``1(C1.LiveLinq.LiveViews.View{``0},System.Linq.Expressions.Expression{System.Func{``0,``0,``0}},System.Linq.Expressions.Expression{System.Func{``0,``0,``0}},System.Linq.Expressions.Expression{System.Func{``0,``0,System.Boolean}})">
      <summary>Applies an accumulator function over a view.</summary>
      <typeparam name="TSource">The type of the elements of <i>source.</i></typeparam>
      <param name="source">A view to aggregate over.</param>
      <param name="funcAdd">An accumulator function to be invoked on each element that is added to the source view.</param>
      <param name="funcRemove">A function to be applied to the accumulated value and to an element
            to obtain the changed accumulated value, when an element is removed from the source view.</param>
      <param name="funcRemoveDefined">A function used to determine whether <i>funcRemove</i> must be applied when an element
            is removed from the source view, or the accumulated value is not affected by its removal.</param>
      <returns>A view representing the final accumulator value.</returns>
      <remarks>It is possible to use standard LINQ query operator <b>Aggregate</b> instead of <b>LiveAggregate</b>.
            Both are "live" in the sense that they are recomputed automatically when any change occurs in the source.
            The difference is that <b>Aggregate</b> will every time loop through the entire source collection and aggregate it from scratch,
            whereas <b>LiveAggregate</b> will use a more performant algorithm, will maintain its value incrementally,
            processing only those source items that actually changed. </remarks>
    </member>
    <member name="M:C1.LiveLinq.LiveViewExtensions.LiveAggregate``2(C1.LiveLinq.LiveViews.View{``0},``1,System.Linq.Expressions.Expression{System.Func{``1,``0,``1}},System.Linq.Expressions.Expression{System.Func{``1,``0,``1}},System.Linq.Expressions.Expression{System.Func{``1,``0,System.Boolean}})">
      <summary>Applies an accumulator function over a view. The specified seed value is used as the initial accumulator value.</summary>
      <typeparam name="TSource">The type of the elements of <i>source.</i></typeparam>
      <typeparam name="TAccumulate">The type of the accumulator value.</typeparam>
      <param name="source">A view to aggregate over.</param>
      <param name="seed">The initial accumulator value.</param>
      <param name="funcAdd">An accumulator function to be invoked on each element that is added to the source view.</param>
      <param name="funcRemove">A function to be applied to the accumulated value and to an element
            to obtain the changed accumulated value, when an element is removed from the source view.</param>
      <param name="funcRemoveDefined">A function used to determine whether <i>funcRemove</i> must be applied when an element
            is removed from the source view, or the accumulated value is not affected by its removal.</param>
      <returns>A view representing the final accumulator value.</returns>
      <remarks>It is possible to use standard LINQ query operator <b>Aggregate</b> instead of <b>LiveAggregate</b>.
            Both are "live" in the sense that they are recomputed automatically when any change occurs in the source.
            The difference is that <b>Aggregate</b> will every time loop through the entire source collection and aggregate it from scratch,
            whereas <b>LiveAggregate</b> will use a more performant algorithm, will maintain its value incrementally,
            processing only those source items that actually changed. </remarks>
    </member>
    <member name="M:C1.LiveLinq.LiveViewExtensions.LiveAggregate``3(C1.LiveLinq.LiveViews.View{``0},``1,System.Linq.Expressions.Expression{System.Func{``1,``0,``1}},System.Linq.Expressions.Expression{System.Func{``1,``0,``1}},System.Linq.Expressions.Expression{System.Func{``1,``0,System.Boolean}},System.Linq.Expressions.Expression{System.Func{``1,``2}})">
      <summary>
            Applies an accumulator function over a view. The specified seed value is used as the initial accumulator value, and the specified function is used to select the result value.
            </summary>
      <typeparam name="TSource">The type of the elements of <i>source.</i></typeparam>
      <typeparam name="TAccumulate">The type of the accumulator value.</typeparam>
      <typeparam name="TResult">The type of the resulting value.</typeparam>
      <param name="source">A view to aggregate over.</param>
      <param name="seed">The initial accumulator value.</param>
      <param name="funcAdd">An accumulator function to be invoked on each element that is added to the source view.</param>
      <param name="funcRemove">A function to be applied to the accumulated value and to an element
            to obtain the changed accumulated value, when an element is removed from the source view.</param>
      <param name="funcRemoveDefined">A function used to determine whether <i>funcRemove</i> must be applied when an element
            is removed from the source view, or the accumulated value is not affected by its removal.</param>
      <param name="resultSelector">A function to transform the final accumulator value into the result value.</param>
      <returns>A view representing the final accumulator value.</returns>
      <remarks>It is possible to use standard LINQ query operator <b>Aggregate</b> instead of <b>LiveAggregate</b>.
            Both are "live" in the sense that they are recomputed automatically when any change occurs in the source.
            The difference is that <b>Aggregate</b> will every time loop through the entire source collection and aggregate it from scratch,
            whereas <b>LiveAggregate</b> will use a more performant algorithm, will maintain its value incrementally,
            processing only those source items that actually changed. </remarks>
    </member>
    <member name="M:C1.LiveLinq.LiveViewExtensions.LiveAverage(C1.LiveLinq.LiveViews.View{System.Int32})">
      <summary>Computes the average of a view of <see cref="T:System.Int32" /> values.</summary>
      <param name="source">A view containing the values to calculate the average of.</param>
      <returns>A view representing the average of the values.</returns>
      <remarks>
        <para>If the <i>source</i> is empty or contains only nulls, an <see cref="T:System.InvalidOperationException" /> is thrown.</para>
        <para>It is possible to use standard LINQ query operator <b>Average</b> instead of <b>LiveAverage</b>.
            Both are "live" in the sense that they are recomputed automatically when any change occurs in the source.
            The difference is that <b>Average</b> will every time loop through the entire source collection and aggregate it from scratch,
            whereas <b>LiveAverage</b> will use a more performant algorithm, will maintain its value incrementally,
            processing only those source items that actually changed.</para>
      </remarks>
    </member>
    <member name="M:C1.LiveLinq.LiveViewExtensions.LiveAverage(C1.LiveLinq.LiveViews.View{System.Nullable{System.Int32}})">
      <summary>Computes the average of a view of nullable <see cref="T:System.Int32" /> values.</summary>
      <param name="source">A view containing the values to calculate the average of.</param>
      <returns>A view representing the average of the values.</returns>
      <remarks>
        <para>If the <i>source</i> is empty or contains only nulls, the average value is null.</para>
        <para>It is possible to use standard LINQ query operator <b>Average</b> instead of <b>LiveAverage</b>.
            Both are "live" in the sense that they are recomputed automatically when any change occurs in the source.
            The difference is that <b>Average</b> will every time loop through the entire source collection and aggregate it from scratch,
            whereas <b>LiveAverage</b> will use a more performant algorithm, will maintain its value incrementally,
            processing only those source items that actually changed.</para>
      </remarks>
    </member>
    <member name="M:C1.LiveLinq.LiveViewExtensions.LiveAverage``1(C1.LiveLinq.LiveViews.View{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Int32}})">
      <summary>Computes the average of a view of <see cref="T:System.Int32" /> values that are obtained 
            by invoking a transform function on each element of the source view.</summary>
      <typeparam name="TSource">The type of the elements of <i>source</i>.</typeparam>
      <param name="source">A view containing the values to calculate the average of.</param>
      <param name="selector">A transform function to apply to each element.</param>
      <returns>A view representing the average of the values.</returns>
      <remarks>
        <para>If the <i>source</i> is empty, an <see cref="T:System.InvalidOperationException" /> is thrown.</para>
        <para>It is possible to use standard LINQ query operator <b>Average</b> instead of <b>LiveAverage</b>.
            Both are "live" in the sense that they are recomputed automatically when any change occurs in the source.
            The difference is that <b>Average</b> will every time loop through the entire source collection and aggregate it from scratch,
            whereas <b>LiveAverage</b> will use a more performant algorithm, will maintain its value incrementally,
            processing only those source items that actually changed.</para>
      </remarks>
    </member>
    <member name="M:C1.LiveLinq.LiveViewExtensions.LiveAverage``1(C1.LiveLinq.LiveViews.View{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Nullable{System.Int32}}})">
      <summary>Computes the average of a view of nullable <see cref="T:System.Int32" /> values that are obtained 
            by invoking a transform function on each element of the source view.</summary>
      <typeparam name="TSource">The type of the elements of <i>source</i>.</typeparam>
      <param name="source">A view containing the values to calculate the average of.</param>
      <param name="selector">A transform function to apply to each element.</param>
      <returns>A view representing the average of the values.</returns>
      <remarks>
        <para>If the <i>source</i> is empty, the average value is null.</para>
        <para>It is possible to use standard LINQ query operator <b>Average</b> instead of <b>LiveAverage</b>.
            Both are "live" in the sense that they are recomputed automatically when any change occurs in the source.
            The difference is that <b>Average</b> will every time loop through the entire source collection and aggregate it from scratch,
            whereas <b>LiveAverage</b> will use a more performant algorithm, will maintain its value incrementally,
            processing only those source items that actually changed.</para>
      </remarks>
    </member>
    <member name="M:C1.LiveLinq.LiveViewExtensions.LiveAverage(C1.LiveLinq.LiveViews.View{System.Int64})">
      <summary>Computes the average of a view of <see cref="T:System.Int64" /> values.</summary>
      <param name="source">A view containing the values to calculate the average of.</param>
      <returns>A view representing the average of the values.</returns>
      <remarks>
        <para>If the <i>source</i> is empty or contains only nulls, an <see cref="T:System.InvalidOperationException" /> is thrown.</para>
        <para>It is possible to use standard LINQ query operator <b>Average</b> instead of <b>LiveAverage</b>.
            Both are "live" in the sense that they are recomputed automatically when any change occurs in the source.
            The difference is that <b>Average</b> will every time loop through the entire source collection and aggregate it from scratch,
            whereas <b>LiveAverage</b> will use a more performant algorithm, will maintain its value incrementally,
            processing only those source items that actually changed.</para>
      </remarks>
    </member>
    <member name="M:C1.LiveLinq.LiveViewExtensions.LiveAverage(C1.LiveLinq.LiveViews.View{System.Nullable{System.Int64}})">
      <summary>Computes the average of a view of nullable <see cref="T:System.Int64" /> values.</summary>
      <param name="source">A view containing the values to calculate the average of.</param>
      <returns>A view representing the average of the values.</returns>
      <remarks>
        <para>If the <i>source</i> is empty or contains only nulls, the average value is null.</para>
        <para>It is possible to use standard LINQ query operator <b>Average</b> instead of <b>LiveAverage</b>.
            Both are "live" in the sense that they are recomputed automatically when any change occurs in the source.
            The difference is that <b>Average</b> will every time loop through the entire source collection and aggregate it from scratch,
            whereas <b>LiveAverage</b> will use a more performant algorithm, will maintain its value incrementally,
            processing only those source items that actually changed.</para>
      </remarks>
    </member>
    <member name="M:C1.LiveLinq.LiveViewExtensions.LiveAverage``1(C1.LiveLinq.LiveViews.View{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Int64}})">
      <summary>Computes the average of a view of <see cref="T:System.Int64" /> values that are obtained 
            by invoking a transform function on each element of the source view.</summary>
      <typeparam name="TSource">The type of the elements of <i>source</i>.</typeparam>
      <param name="source">A view containing the values to calculate the average of.</param>
      <param name="selector">A transform function to apply to each element.</param>
      <returns>A view representing the average of the values.</returns>
      <remarks>
        <para>If the <i>source</i> is empty, an <see cref="T:System.InvalidOperationException" /> is thrown.</para>
        <para>It is possible to use standard LINQ query operator <b>Average</b> instead of <b>LiveAverage</b>.
            Both are "live" in the sense that they are recomputed automatically when any change occurs in the source.
            The difference is that <b>Average</b> will every time loop through the entire source collection and aggregate it from scratch,
            whereas <b>LiveAverage</b> will use a more performant algorithm, will maintain its value incrementally,
            processing only those source items that actually changed.</para>
      </remarks>
    </member>
    <member name="M:C1.LiveLinq.LiveViewExtensions.LiveAverage``1(C1.LiveLinq.LiveViews.View{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Nullable{System.Int64}}})">
      <summary>Computes the average of a view of nullable <see cref="T:System.Int64" /> values that are obtained 
            by invoking a transform function on each element of the source view.</summary>
      <typeparam name="TSource">The type of the elements of <i>source</i>.</typeparam>
      <param name="source">A view containing the values to calculate the average of.</param>
      <param name="selector">A transform function to apply to each element.</param>
      <returns>A view representing the average of the values.</returns>
      <remarks>
        <para>If the <i>source</i> is empty, the average value is null.</para>
        <para>It is possible to use standard LINQ query operator <b>Average</b> instead of <b>LiveAverage</b>.
            Both are "live" in the sense that they are recomputed automatically when any change occurs in the source.
            The difference is that <b>Average</b> will every time loop through the entire source collection and aggregate it from scratch,
            whereas <b>LiveAverage</b> will use a more performant algorithm, will maintain its value incrementally,
            processing only those source items that actually changed.</para>
      </remarks>
    </member>
    <member name="M:C1.LiveLinq.LiveViewExtensions.LiveAverage(C1.LiveLinq.LiveViews.View{System.Decimal})">
      <summary>Computes the average of a view of <see cref="T:System.Decimal" /> values.</summary>
      <param name="source">A view containing the values to calculate the average of.</param>
      <returns>A view representing the average of the values.</returns>
      <remarks>
        <para>If the <i>source</i> is empty or contains only nulls, an <see cref="T:System.InvalidOperationException" /> is thrown.</para>
        <para>It is possible to use standard LINQ query operator <b>Average</b> instead of <b>LiveAverage</b>.
            Both are "live" in the sense that they are recomputed automatically when any change occurs in the source.
            The difference is that <b>Average</b> will every time loop through the entire source collection and aggregate it from scratch,
            whereas <b>LiveAverage</b> will use a more performant algorithm, will maintain its value incrementally,
            processing only those source items that actually changed.</para>
      </remarks>
    </member>
    <member name="M:C1.LiveLinq.LiveViewExtensions.LiveAverage(C1.LiveLinq.LiveViews.View{System.Nullable{System.Decimal}})">
      <summary>Computes the average of a view of nullable <see cref="T:System.Decimal" /> values.</summary>
      <param name="source">A view containing the values to calculate the average of.</param>
      <returns>A view representing the average of the values.</returns>
      <remarks>
        <para>If the <i>source</i> is empty or contains only nulls, the average value is null.</para>
        <para>It is possible to use standard LINQ query operator <b>Average</b> instead of <b>LiveAverage</b>.
            Both are "live" in the sense that they are recomputed automatically when any change occurs in the source.
            The difference is that <b>Average</b> will every time loop through the entire source collection and aggregate it from scratch,
            whereas <b>LiveAverage</b> will use a more performant algorithm, will maintain its value incrementally,
            processing only those source items that actually changed.</para>
      </remarks>
    </member>
    <member name="M:C1.LiveLinq.LiveViewExtensions.LiveAverage``1(C1.LiveLinq.LiveViews.View{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Decimal}})">
      <summary>Computes the average of a view of <see cref="T:System.Decimal" /> values that are obtained 
            by invoking a transform function on each element of the source view.</summary>
      <typeparam name="TSource">The type of the elements of <i>source</i>.</typeparam>
      <param name="source">A view containing the values to calculate the average of.</param>
      <param name="selector">A transform function to apply to each element.</param>
      <returns>A view representing the average of the values.</returns>
      <remarks>
        <para>If the <i>source</i> is empty, an <see cref="T:System.InvalidOperationException" /> is thrown.</para>
        <para>It is possible to use standard LINQ query operator <b>Average</b> instead of <b>LiveAverage</b>.
            Both are "live" in the sense that they are recomputed automatically when any change occurs in the source.
            The difference is that <b>Average</b> will every time loop through the entire source collection and aggregate it from scratch,
            whereas <b>LiveAverage</b> will use a more performant algorithm, will maintain its value incrementally,
            processing only those source items that actually changed.</para>
      </remarks>
    </member>
    <member name="M:C1.LiveLinq.LiveViewExtensions.LiveAverage``1(C1.LiveLinq.LiveViews.View{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Nullable{System.Decimal}}})">
      <summary>Computes the average of a view of nullable <see cref="T:System.Decimal" /> values that are obtained 
            by invoking a transform function on each element of the source view.</summary>
      <typeparam name="TSource">The type of the elements of <i>source</i>.</typeparam>
      <param name="source">A view containing the values to calculate the average of.</param>
      <param name="selector">A transform function to apply to each element.</param>
      <returns>A view representing the average of the values.</returns>
      <remarks>
        <para>If the <i>source</i> is empty, the average value is null.</para>
        <para>It is possible to use standard LINQ query operator <b>Average</b> instead of <b>LiveAverage</b>.
            Both are "live" in the sense that they are recomputed automatically when any change occurs in the source.
            The difference is that <b>Average</b> will every time loop through the entire source collection and aggregate it from scratch,
            whereas <b>LiveAverage</b> will use a more performant algorithm, will maintain its value incrementally,
            processing only those source items that actually changed.</para>
      </remarks>
    </member>
    <member name="M:C1.LiveLinq.LiveViewExtensions.LiveAverage(C1.LiveLinq.LiveViews.View{System.Double})">
      <summary>Computes the average of a view of <see cref="T:System.Double" /> values.</summary>
      <param name="source">A view containing the values to calculate the average of.</param>
      <returns>A view representing the average of the values.</returns>
      <remarks>
        <para>If the <i>source</i> is empty or contains only nulls, an <see cref="T:System.InvalidOperationException" /> is thrown.</para>
        <para>It is possible to use standard LINQ query operator <b>Average</b> instead of <b>LiveAverage</b>.
            Both are "live" in the sense that they are recomputed automatically when any change occurs in the source.
            The difference is that <b>Average</b> will every time loop through the entire source collection and aggregate it from scratch,
            whereas <b>LiveAverage</b> will use a more performant algorithm, will maintain its value incrementally,
            processing only those source items that actually changed.</para>
      </remarks>
    </member>
    <member name="M:C1.LiveLinq.LiveViewExtensions.LiveAverage(C1.LiveLinq.LiveViews.View{System.Nullable{System.Double}})">
      <summary>Computes the average of a view of nullable <see cref="T:System.Double" /> values.</summary>
      <param name="source">A view containing the values to calculate the average of.</param>
      <returns>A view representing the average of the values.</returns>
      <remarks>
        <para>If the <i>source</i> is empty or contains only nulls, the average value is null.</para>
        <para>It is possible to use standard LINQ query operator <b>Average</b> instead of <b>LiveAverage</b>.
            Both are "live" in the sense that they are recomputed automatically when any change occurs in the source.
            The difference is that <b>Average</b> will every time loop through the entire source collection and aggregate it from scratch,
            whereas <b>LiveAverage</b> will use a more performant algorithm, will maintain its value incrementally,
            processing only those source items that actually changed.</para>
      </remarks>
    </member>
    <member name="M:C1.LiveLinq.LiveViewExtensions.LiveAverage``1(C1.LiveLinq.LiveViews.View{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Double}})">
      <summary>Computes the average of a view of <see cref="T:System.Double" /> values that are obtained 
            by invoking a transform function on each element of the source view.</summary>
      <typeparam name="TSource">The type of the elements of <i>source</i>.</typeparam>
      <param name="source">A view containing the values to calculate the average of.</param>
      <param name="selector">A transform function to apply to each element.</param>
      <returns>A view representing the average of the values.</returns>
      <remarks>
        <para>If the <i>source</i> is empty, an <see cref="T:System.InvalidOperationException" /> is thrown.</para>
        <para>It is possible to use standard LINQ query operator <b>Average</b> instead of <b>LiveAverage</b>.
            Both are "live" in the sense that they are recomputed automatically when any change occurs in the source.
            The difference is that <b>Average</b> will every time loop through the entire source collection and aggregate it from scratch,
            whereas <b>LiveAverage</b> will use a more performant algorithm, will maintain its value incrementally,
            processing only those source items that actually changed.</para>
      </remarks>
    </member>
    <member name="M:C1.LiveLinq.LiveViewExtensions.LiveAverage``1(C1.LiveLinq.LiveViews.View{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Nullable{System.Double}}})">
      <summary>Computes the average of a view of nullable <see cref="T:System.Double" /> values that are obtained 
            by invoking a transform function on each element of the source view.</summary>
      <typeparam name="TSource">The type of the elements of <i>source</i>.</typeparam>
      <param name="source">A view containing the values to calculate the average of.</param>
      <param name="selector">A transform function to apply to each element.</param>
      <returns>A view representing the average of the values.</returns>
      <remarks>
        <para>If the <i>source</i> is empty, the average value is null.</para>
        <para>It is possible to use standard LINQ query operator <b>Average</b> instead of <b>LiveAverage</b>.
            Both are "live" in the sense that they are recomputed automatically when any change occurs in the source.
            The difference is that <b>Average</b> will every time loop through the entire source collection and aggregate it from scratch,
            whereas <b>LiveAverage</b> will use a more performant algorithm, will maintain its value incrementally,
            processing only those source items that actually changed.</para>
      </remarks>
    </member>
    <member name="M:C1.LiveLinq.LiveViewExtensions.LiveAverage(C1.LiveLinq.LiveViews.View{System.Single})">
      <summary>Computes the average of a view of <see cref="T:System.Single" /> values.</summary>
      <param name="source">A view containing the values to calculate the average of.</param>
      <returns>A view representing the average of the values.</returns>
      <remarks>
        <para>If the <i>source</i> is empty or contains only nulls, an <see cref="T:System.InvalidOperationException" /> is thrown.</para>
        <para>It is possible to use standard LINQ query operator <b>Average</b> instead of <b>LiveAverage</b>.
            Both are "live" in the sense that they are recomputed automatically when any change occurs in the source.
            The difference is that <b>Average</b> will every time loop through the entire source collection and aggregate it from scratch,
            whereas <b>LiveAverage</b> will use a more performant algorithm, will maintain its value incrementally,
            processing only those source items that actually changed.</para>
      </remarks>
    </member>
    <member name="M:C1.LiveLinq.LiveViewExtensions.LiveAverage(C1.LiveLinq.LiveViews.View{System.Nullable{System.Single}})">
      <summary>Computes the average of a view of nullable <see cref="T:System.Single" /> values.</summary>
      <param name="source">A view containing the values to calculate the average of.</param>
      <returns>A view representing the average of the values.</returns>
      <remarks>
        <para>If the <i>source</i> is empty or contains only nulls, the average value is null.</para>
        <para>It is possible to use standard LINQ query operator <b>Average</b> instead of <b>LiveAverage</b>.
            Both are "live" in the sense that they are recomputed automatically when any change occurs in the source.
            The difference is that <b>Average</b> will every time loop through the entire source collection and aggregate it from scratch,
            whereas <b>LiveAverage</b> will use a more performant algorithm, will maintain its value incrementally,
            processing only those source items that actually changed.</para>
      </remarks>
    </member>
    <member name="M:C1.LiveLinq.LiveViewExtensions.LiveAverage``1(C1.LiveLinq.LiveViews.View{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Single}})">
      <summary>Computes the average of a view of <see cref="T:System.Single" /> values that are obtained 
            by invoking a transform function on each element of the source view.</summary>
      <typeparam name="TSource">The type of the elements of <i>source</i>.</typeparam>
      <param name="source">A view containing the values to calculate the average of.</param>
      <param name="selector">A transform function to apply to each element.</param>
      <returns>A view representing the average of the values.</returns>
      <remarks>
        <para>If the <i>source</i> is empty, an <see cref="T:System.InvalidOperationException" /> is thrown.</para>
        <para>It is possible to use standard LINQ query operator <b>Average</b> instead of <b>LiveAverage</b>.
            Both are "live" in the sense that they are recomputed automatically when any change occurs in the source.
            The difference is that <b>Average</b> will every time loop through the entire source collection and aggregate it from scratch,
            whereas <b>LiveAverage</b> will use a more performant algorithm, will maintain its value incrementally,
            processing only those source items that actually changed.</para>
      </remarks>
    </member>
    <member name="M:C1.LiveLinq.LiveViewExtensions.LiveAverage``1(C1.LiveLinq.LiveViews.View{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Nullable{System.Single}}})">
      <summary>Computes the average of a view of nullable <see cref="T:System.Single" /> values that are obtained 
            by invoking a transform function on each element of the source view.</summary>
      <typeparam name="TSource">The type of the elements of <i>source</i>.</typeparam>
      <param name="source">A view containing the values to calculate the average of.</param>
      <param name="selector">A transform function to apply to each element.</param>
      <returns>A view representing the average of the values.</returns>
      <remarks>
        <para>If the <i>source</i> is empty, the average value is null.</para>
        <para>It is possible to use standard LINQ query operator <b>Average</b> instead of <b>LiveAverage</b>.
            Both are "live" in the sense that they are recomputed automatically when any change occurs in the source.
            The difference is that <b>Average</b> will every time loop through the entire source collection and aggregate it from scratch,
            whereas <b>LiveAverage</b> will use a more performant algorithm, will maintain its value incrementally,
            processing only those source items that actually changed.</para>
      </remarks>
    </member>
    <member name="M:C1.LiveLinq.LiveViewExtensions.LiveCount``1(C1.LiveLinq.LiveViews.View{``0})">
      <summary>A view representing the number of elements in a view.</summary>
      <typeparam name="T">The type of the elements of <i>source</i>.</typeparam>
      <param name="source">A view that contains elements to be counted.</param>
      <remarks>It is possible to use standard LINQ query operator <b>Count</b> instead of <b>LiveCount</b>.
            Both are "live" in the sense that they are recomputed automatically when any change occurs in the source.
            The difference is that <b>Count</b> will every time loop through the entire source collection and aggregate it from scratch,
            whereas <b>LiveCount</b> will use a more performant algorithm, will maintain its value incrementally,
            processing only those source items that actually changed. </remarks>
    </member>
    <member name="M:C1.LiveLinq.LiveViewExtensions.LiveCount``1(C1.LiveLinq.LiveViews.View{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})">
      <summary>A view representing the number of elements of the specified view satisfying a condition.</summary>
      <typeparam name="T">The type of the elements of <i>source</i>.</typeparam>
      <param name="source">A view that contains elements to be tested and counted.</param>
      <param name="predicate">A function to test each element for a condition.</param>
      <remarks>It is possible to use standard LINQ query operator <b>Count</b> instead of <b>LiveCount</b>.
            Both are "live" in the sense that they are recomputed automatically when any change occurs in the source.
            The difference is that <b>Count</b> will every time loop through the entire source collection and aggregate it from scratch,
            whereas <b>LiveCount</b> will use a more performant algorithm, will maintain its value incrementally,
            processing only those source items that actually changed. </remarks>
    </member>
    <member name="M:C1.LiveLinq.LiveViewExtensions.LiveMin(C1.LiveLinq.LiveViews.View{System.Int32})">
      <summary>Computes the minimum value of a view of <see cref="T:System.Int32" /> values.</summary>
      <param name="source">A view containing the values to determine the minimum value of.</param>
      <returns>A view representing the minimum of the values.</returns>
      <remarks>
        <para>If the <i>source</i> is empty or contains only nulls, an <see cref="T:System.InvalidOperationException" /> is thrown.</para>
        <para>It is possible to use standard LINQ query operator <b>Min</b> instead of <b>LiveMin</b>.
            Both are "live" in the sense that they are recomputed automatically when any change occurs in the source.
            The difference is that <b>Min</b> will every time loop through the entire source collection and aggregate it from scratch,
            whereas <b>LiveMin</b> will use a more performant algorithm, will maintain its value incrementally,
            processing only those source items that actually changed.</para>
      </remarks>
    </member>
    <member name="M:C1.LiveLinq.LiveViewExtensions.LiveMin(C1.LiveLinq.LiveViews.View{System.Nullable{System.Int32}})">
      <summary>Computes the minimum value of a view of nullable <see cref="T:System.Int32" /> values.</summary>
      <param name="source">A view containing the values to determine the minimum value of.</param>
      <returns>A view representing the minimum of the values.</returns>
      <remarks>
        <para>If the <i>source</i> is empty or contains only nulls, the minimum value is null.</para>
        <para>It is possible to use standard LINQ query operator <b>Min</b> instead of <b>LiveMin</b>.
            Both are "live" in the sense that they are recomputed automatically when any change occurs in the source.
            The difference is that <b>Min</b> will every time loop through the entire source collection and aggregate it from scratch,
            whereas <b>LiveMin</b> will use a more performant algorithm, will maintain its value incrementally,
            processing only those source items that actually changed.</para>
      </remarks>
    </member>
    <member name="M:C1.LiveLinq.LiveViewExtensions.LiveMin``1(C1.LiveLinq.LiveViews.View{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Int32}})">
      <summary>Computes the minimum value of a view of <see cref="T:System.Int32" /> values that are obtained 
            by invoking a transform function on each element of the source view.</summary>
      <typeparam name="TSource">The type of the elements of <i>source</i>.</typeparam>
      <param name="source">A view containing the values to determine the minimum value of.</param>
      <param name="selector">A transform function to apply to each element.</param>
      <returns>A view representing the minimum of the values.</returns>
      <remarks>
        <para>If the <i>source</i> is empty, an <see cref="T:System.InvalidOperationException" /> is thrown.</para>
        <para>It is possible to use standard LINQ query operator <b>Min</b> instead of <b>LiveMin</b>.
            Both are "live" in the sense that they are recomputed automatically when any change occurs in the source.
            The difference is that <b>Min</b> will every time loop through the entire source collection and aggregate it from scratch,
            whereas <b>LiveMin</b> will use a more performant algorithm, will maintain its value incrementally,
            processing only those source items that actually changed.</para>
      </remarks>
    </member>
    <member name="M:C1.LiveLinq.LiveViewExtensions.LiveMin``1(C1.LiveLinq.LiveViews.View{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Nullable{System.Int32}}})">
      <summary>Computes the minimum value of a view of nullable <see cref="T:System.Int32" /> values that are obtained 
            by invoking a transform function on each element of the source view.</summary>
      <typeparam name="TSource">The type of the elements of <i>source</i>.</typeparam>
      <param name="source">A view containing the values to determine the minimum value of.</param>
      <param name="selector">A transform function to apply to each element.</param>
      <returns>A view representing the minimum of the values.</returns>
      <remarks>
        <para>If the <i>source</i> is empty or contains only nulls, the minimum value is null.</para>
        <para>It is possible to use standard LINQ query operator <b>Min</b> instead of <b>LiveMin</b>.
            Both are "live" in the sense that they are recomputed automatically when any change occurs in the source.
            The difference is that <b>Min</b> will every time loop through the entire source collection and aggregate it from scratch,
            whereas <b>LiveMin</b> will use a more performant algorithm, will maintain its value incrementally,
            processing only those source items that actually changed.</para>
      </remarks>
    </member>
    <member name="M:C1.LiveLinq.LiveViewExtensions.LiveMax(C1.LiveLinq.LiveViews.View{System.Int32})">
      <summary>Computes the maximum value of a view of <see cref="T:System.Int32" /> values.</summary>
      <param name="source">A view containing the values to determine the maximum value of.</param>
      <returns>A view representing the maximum of the values.</returns>
      <remarks>
        <para>If the <i>source</i> is empty or contains only nulls, an <see cref="T:System.InvalidOperationException" /> is thrown.</para>
        <para>It is possible to use standard LINQ query operator <b>Max</b> instead of <b>LiveMax</b>.
            Both are "live" in the sense that they are recomputed automatically when any change occurs in the source.
            The difference is that <b>Max</b> will every time loop through the entire source collection and aggregate it from scratch,
            whereas <b>LiveMax</b> will use a more performant algorithm, will maintain its value incrementally,
            processing only those source items that actually changed.</para>
      </remarks>
    </member>
    <member name="M:C1.LiveLinq.LiveViewExtensions.LiveMax(C1.LiveLinq.LiveViews.View{System.Nullable{System.Int32}})">
      <summary>Computes the maximum value of a view of nullable <see cref="T:System.Int32" /> values.</summary>
      <param name="source">A view containing the values to determine the maximum value of.</param>
      <returns>A view representing the maximum of the values.</returns>
      <remarks>
        <para>If the <i>source</i> is empty or contains only nulls, the maximum value is null.</para>
        <para>It is possible to use standard LINQ query operator <b>Max</b> instead of <b>LiveMax</b>.
            Both are "live" in the sense that they are recomputed automatically when any change occurs in the source.
            The difference is that <b>Max</b> will every time loop through the entire source collection and aggregate it from scratch,
            whereas <b>LiveMax</b> will use a more performant algorithm, will maintain its value incrementally,
            processing only those source items that actually changed.</para>
      </remarks>
    </member>
    <member name="M:C1.LiveLinq.LiveViewExtensions.LiveMax``1(C1.LiveLinq.LiveViews.View{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Int32}})">
      <summary>Computes the maximum value of a view of <see cref="T:System.Int32" /> values that are obtained 
            by invoking a transform function on each element of the source view.</summary>
      <typeparam name="TSource">The type of the elements of <i>source</i>.</typeparam>
      <param name="source">A view containing the values to determine the maximum value of.</param>
      <param name="selector">A transform function to apply to each element.</param>
      <returns>A view representing the maximum of the values.</returns>
      <remarks>
        <para>If the <i>source</i> is empty, an <see cref="T:System.InvalidOperationException" /> is thrown.</para>
        <para>It is possible to use standard LINQ query operator <b>Max</b> instead of <b>LiveMax</b>.
            Both are "live" in the sense that they are recomputed automatically when any change occurs in the source.
            The difference is that <b>Max</b> will every time loop through the entire source collection and aggregate it from scratch,
            whereas <b>LiveMax</b> will use a more performant algorithm, will maintain its value incrementally,
            processing only those source items that actually changed.</para>
      </remarks>
    </member>
    <member name="M:C1.LiveLinq.LiveViewExtensions.LiveMax``1(C1.LiveLinq.LiveViews.View{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Nullable{System.Int32}}})">
      <summary>Computes the maximum value of a view of nullable <see cref="T:System.Int32" /> values that are obtained 
            by invoking a transform function on each element of the source view.</summary>
      <typeparam name="TSource">The type of the elements of <i>source</i>.</typeparam>
      <param name="source">A view containing the values to determine the maximum value of.</param>
      <param name="selector">A transform function to apply to each element.</param>
      <returns>A view representing the maximum of the values.</returns>
      <remarks>
        <para>If the <i>source</i> is empty or contains only nulls, the maximum value is null.</para>
        <para>It is possible to use standard LINQ query operator <b>Max</b> instead of <b>LiveMax</b>.
            Both are "live" in the sense that they are recomputed automatically when any change occurs in the source.
            The difference is that <b>Max</b> will every time loop through the entire source collection and aggregate it from scratch,
            whereas <b>LiveMax</b> will use a more performant algorithm, will maintain its value incrementally,
            processing only those source items that actually changed.</para>
      </remarks>
    </member>
    <member name="M:C1.LiveLinq.LiveViewExtensions.LiveMin(C1.LiveLinq.LiveViews.View{System.Decimal})">
      <summary>Computes the minimum value of a view of <see cref="T:System.Decimal" /> values.</summary>
      <param name="source">A view containing the values to determine the minimum value of.</param>
      <returns>A view representing the minimum of the values.</returns>
      <remarks>
        <para>If the <i>source</i> is empty or contains only nulls, an <see cref="T:System.InvalidOperationException" /> is thrown.</para>
        <para>It is possible to use standard LINQ query operator <b>Min</b> instead of <b>LiveMin</b>.
            Both are "live" in the sense that they are recomputed automatically when any change occurs in the source.
            The difference is that <b>Min</b> will every time loop through the entire source collection and aggregate it from scratch,
            whereas <b>LiveMin</b> will use a more performant algorithm, will maintain its value incrementally,
            processing only those source items that actually changed.</para>
      </remarks>
    </member>
    <member name="M:C1.LiveLinq.LiveViewExtensions.LiveMin(C1.LiveLinq.LiveViews.View{System.Nullable{System.Decimal}})">
      <summary>Computes the minimum value of a view of nullable <see cref="T:System.Decimal" /> values.</summary>
      <param name="source">A view containing the values to determine the minimum value of.</param>
      <returns>A view representing the minimum of the values.</returns>
      <remarks>
        <para>If the <i>source</i> is empty or contains only nulls, the minimum value is null.</para>
        <para>It is possible to use standard LINQ query operator <b>Min</b> instead of <b>LiveMin</b>.
            Both are "live" in the sense that they are recomputed automatically when any change occurs in the source.
            The difference is that <b>Min</b> will every time loop through the entire source collection and aggregate it from scratch,
            whereas <b>LiveMin</b> will use a more performant algorithm, will maintain its value incrementally,
            processing only those source items that actually changed.</para>
      </remarks>
    </member>
    <member name="M:C1.LiveLinq.LiveViewExtensions.LiveMin``1(C1.LiveLinq.LiveViews.View{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Decimal}})">
      <summary>Computes the minimum value of a view of <see cref="T:System.Decimal" /> values that are obtained 
            by invoking a transform function on each element of the source view.</summary>
      <typeparam name="TSource">The type of the elements of <i>source</i>.</typeparam>
      <param name="source">A view containing the values to determine the minimum value of.</param>
      <param name="selector">A transform function to apply to each element.</param>
      <returns>A view representing the minimum of the values.</returns>
      <remarks>
        <para>If the <i>source</i> is empty, an <see cref="T:System.InvalidOperationException" /> is thrown.</para>
        <para>It is possible to use standard LINQ query operator <b>Min</b> instead of <b>LiveMin</b>.
            Both are "live" in the sense that they are recomputed automatically when any change occurs in the source.
            The difference is that <b>Min</b> will every time loop through the entire source collection and aggregate it from scratch,
            whereas <b>LiveMin</b> will use a more performant algorithm, will maintain its value incrementally,
            processing only those source items that actually changed.</para>
      </remarks>
    </member>
    <member name="M:C1.LiveLinq.LiveViewExtensions.LiveMin``1(C1.LiveLinq.LiveViews.View{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Nullable{System.Decimal}}})">
      <summary>Computes the minimum value of a view of nullable <see cref="T:System.Decimal" /> values that are obtained 
            by invoking a transform function on each element of the source view.</summary>
      <typeparam name="TSource">The type of the elements of <i>source</i>.</typeparam>
      <param name="source">A view containing the values to determine the minimum value of.</param>
      <param name="selector">A transform function to apply to each element.</param>
      <returns>A view representing the minimum of the values.</returns>
      <remarks>
        <para>If the <i>source</i> is empty or contains only nulls, the minimum value is null.</para>
        <para>It is possible to use standard LINQ query operator <b>Min</b> instead of <b>LiveMin</b>.
            Both are "live" in the sense that they are recomputed automatically when any change occurs in the source.
            The difference is that <b>Min</b> will every time loop through the entire source collection and aggregate it from scratch,
            whereas <b>LiveMin</b> will use a more performant algorithm, will maintain its value incrementally,
            processing only those source items that actually changed.</para>
      </remarks>
    </member>
    <member name="M:C1.LiveLinq.LiveViewExtensions.LiveMax(C1.LiveLinq.LiveViews.View{System.Decimal})">
      <summary>Computes the maximum value of a view of <see cref="T:System.Decimal" /> values.</summary>
      <param name="source">A view containing the values to determine the maximum value of.</param>
      <returns>A view representing the maximum of the values.</returns>
      <remarks>
        <para>If the <i>source</i> is empty or contains only nulls, an <see cref="T:System.InvalidOperationException" /> is thrown.</para>
        <para>It is possible to use standard LINQ query operator <b>Max</b> instead of <b>LiveMax</b>.
            Both are "live" in the sense that they are recomputed automatically when any change occurs in the source.
            The difference is that <b>Max</b> will every time loop through the entire source collection and aggregate it from scratch,
            whereas <b>LiveMax</b> will use a more performant algorithm, will maintain its value incrementally,
            processing only those source items that actually changed.</para>
      </remarks>
    </member>
    <member name="M:C1.LiveLinq.LiveViewExtensions.LiveMax(C1.LiveLinq.LiveViews.View{System.Nullable{System.Decimal}})">
      <summary>Computes the maximum value of a view of nullable <see cref="T:System.Decimal" /> values.</summary>
      <param name="source">A view containing the values to determine the maximum value of.</param>
      <returns>A view representing the maximum of the values.</returns>
      <remarks>
        <para>If the <i>source</i> is empty or contains only nulls, the maximum value is null.</para>
        <para>It is possible to use standard LINQ query operator <b>Max</b> instead of <b>LiveMax</b>.
            Both are "live" in the sense that they are recomputed automatically when any change occurs in the source.
            The difference is that <b>Max</b> will every time loop through the entire source collection and aggregate it from scratch,
            whereas <b>LiveMax</b> will use a more performant algorithm, will maintain its value incrementally,
            processing only those source items that actually changed.</para>
      </remarks>
    </member>
    <member name="M:C1.LiveLinq.LiveViewExtensions.LiveMax``1(C1.LiveLinq.LiveViews.View{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Decimal}})">
      <summary>Computes the maximum value of a view of <see cref="T:System.Decimal" /> values that are obtained 
            by invoking a transform function on each element of the source view.</summary>
      <typeparam name="TSource">The type of the elements of <i>source</i>.</typeparam>
      <param name="source">A view containing the values to determine the maximum value of.</param>
      <param name="selector">A transform function to apply to each element.</param>
      <returns>A view representing the maximum of the values.</returns>
      <remarks>
        <para>If the <i>source</i> is empty, an <see cref="T:System.InvalidOperationException" /> is thrown.</para>
        <para>It is possible to use standard LINQ query operator <b>Max</b> instead of <b>LiveMax</b>.
            Both are "live" in the sense that they are recomputed automatically when any change occurs in the source.
            The difference is that <b>Max</b> will every time loop through the entire source collection and aggregate it from scratch,
            whereas <b>LiveMax</b> will use a more performant algorithm, will maintain its value incrementally,
            processing only those source items that actually changed.</para>
      </remarks>
    </member>
    <member name="M:C1.LiveLinq.LiveViewExtensions.LiveMax``1(C1.LiveLinq.LiveViews.View{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Nullable{System.Decimal}}})">
      <summary>Computes the maximum value of a view of nullable <see cref="T:System.Decimal" /> values that are obtained 
            by invoking a transform function on each element of the source view.</summary>
      <typeparam name="TSource">The type of the elements of <i>source</i>.</typeparam>
      <param name="source">A view containing the values to determine the maximum value of.</param>
      <param name="selector">A transform function to apply to each element.</param>
      <returns>A view representing the maximum of the values.</returns>
      <remarks>
        <para>If the <i>source</i> is empty or contains only nulls, the maximum value is null.</para>
        <para>It is possible to use standard LINQ query operator <b>Max</b> instead of <b>LiveMax</b>.
            Both are "live" in the sense that they are recomputed automatically when any change occurs in the source.
            The difference is that <b>Max</b> will every time loop through the entire source collection and aggregate it from scratch,
            whereas <b>LiveMax</b> will use a more performant algorithm, will maintain its value incrementally,
            processing only those source items that actually changed.</para>
      </remarks>
    </member>
    <member name="M:C1.LiveLinq.LiveViewExtensions.LiveMin(C1.LiveLinq.LiveViews.View{System.Int64})">
      <summary>Computes the minimum value of a view of <see cref="T:System.Int64" /> values.</summary>
      <param name="source">A view containing the values to determine the minimum value of.</param>
      <returns>A view representing the minimum of the values.</returns>
      <remarks>
        <para>If the <i>source</i> is empty or contains only nulls, an <see cref="T:System.InvalidOperationException" /> is thrown.</para>
        <para>It is possible to use standard LINQ query operator <b>Min</b> instead of <b>LiveMin</b>.
            Both are "live" in the sense that they are recomputed automatically when any change occurs in the source.
            The difference is that <b>Min</b> will every time loop through the entire source collection and aggregate it from scratch,
            whereas <b>LiveMin</b> will use a more performant algorithm, will maintain its value incrementally,
            processing only those source items that actually changed.</para>
      </remarks>
    </member>
    <member name="M:C1.LiveLinq.LiveViewExtensions.LiveMin(C1.LiveLinq.LiveViews.View{System.Nullable{System.Int64}})">
      <summary>Computes the minimum value of a view of nullable <see cref="T:System.Int64" /> values.</summary>
      <param name="source">A view containing the values to determine the minimum value of.</param>
      <returns>A view representing the minimum of the values.</returns>
      <remarks>
        <para>If the <i>source</i> is empty or contains only nulls, the minimum value is null.</para>
        <para>It is possible to use standard LINQ query operator <b>Min</b> instead of <b>LiveMin</b>.
            Both are "live" in the sense that they are recomputed automatically when any change occurs in the source.
            The difference is that <b>Min</b> will every time loop through the entire source collection and aggregate it from scratch,
            whereas <b>LiveMin</b> will use a more performant algorithm, will maintain its value incrementally,
            processing only those source items that actually changed.</para>
      </remarks>
    </member>
    <member name="M:C1.LiveLinq.LiveViewExtensions.LiveMin``1(C1.LiveLinq.LiveViews.View{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Int64}})">
      <summary>Computes the minimum value of a view of <see cref="T:System.Int64" /> values that are obtained 
            by invoking a transform function on each element of the source view.</summary>
      <typeparam name="TSource">The type of the elements of <i>source</i>.</typeparam>
      <param name="source">A view containing the values to determine the minimum value of.</param>
      <param name="selector">A transform function to apply to each element.</param>
      <returns>A view representing the minimum of the values.</returns>
      <remarks>
        <para>If the <i>source</i> is empty, an <see cref="T:System.InvalidOperationException" /> is thrown.</para>
        <para>It is possible to use standard LINQ query operator <b>Min</b> instead of <b>LiveMin</b>.
            Both are "live" in the sense that they are recomputed automatically when any change occurs in the source.
            The difference is that <b>Min</b> will every time loop through the entire source collection and aggregate it from scratch,
            whereas <b>LiveMin</b> will use a more performant algorithm, will maintain its value incrementally,
            processing only those source items that actually changed.</para>
      </remarks>
    </member>
    <member name="M:C1.LiveLinq.LiveViewExtensions.LiveMin``1(C1.LiveLinq.LiveViews.View{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Nullable{System.Int64}}})">
      <summary>Computes the minimum value of a view of nullable <see cref="T:System.Int64" /> values that are obtained 
            by invoking a transform function on each element of the source view.</summary>
      <typeparam name="TSource">The type of the elements of <i>source</i>.</typeparam>
      <param name="source">A view containing the values to determine the minimum value of.</param>
      <param name="selector">A transform function to apply to each element.</param>
      <returns>A view representing the minimum of the values.</returns>
      <remarks>
        <para>If the <i>source</i> is empty or contains only nulls, the minimum value is null.</para>
        <para>It is possible to use standard LINQ query operator <b>Min</b> instead of <b>LiveMin</b>.
            Both are "live" in the sense that they are recomputed automatically when any change occurs in the source.
            The difference is that <b>Min</b> will every time loop through the entire source collection and aggregate it from scratch,
            whereas <b>LiveMin</b> will use a more performant algorithm, will maintain its value incrementally,
            processing only those source items that actually changed.</para>
      </remarks>
    </member>
    <member name="M:C1.LiveLinq.LiveViewExtensions.LiveMax(C1.LiveLinq.LiveViews.View{System.Int64})">
      <summary>Computes the maximum value of a view of <see cref="T:System.Int64" /> values.</summary>
      <param name="source">A view containing the values to determine the maximum value of.</param>
      <returns>A view representing the maximum of the values.</returns>
      <remarks>
        <para>If the <i>source</i> is empty or contains only nulls, an <see cref="T:System.InvalidOperationException" /> is thrown.</para>
        <para>It is possible to use standard LINQ query operator <b>Max</b> instead of <b>LiveMax</b>.
            Both are "live" in the sense that they are recomputed automatically when any change occurs in the source.
            The difference is that <b>Max</b> will every time loop through the entire source collection and aggregate it from scratch,
            whereas <b>LiveMax</b> will use a more performant algorithm, will maintain its value incrementally,
            processing only those source items that actually changed.</para>
      </remarks>
    </member>
    <member name="M:C1.LiveLinq.LiveViewExtensions.LiveMax(C1.LiveLinq.LiveViews.View{System.Nullable{System.Int64}})">
      <summary>Computes the maximum value of a view of nullable <see cref="T:System.Int64" /> values.</summary>
      <param name="source">A view containing the values to determine the maximum value of.</param>
      <returns>A view representing the maximum of the values.</returns>
      <remarks>
        <para>If the <i>source</i> is empty or contains only nulls, the maximum value is null.</para>
        <para>It is possible to use standard LINQ query operator <b>Max</b> instead of <b>LiveMax</b>.
            Both are "live" in the sense that they are recomputed automatically when any change occurs in the source.
            The difference is that <b>Max</b> will every time loop through the entire source collection and aggregate it from scratch,
            whereas <b>LiveMax</b> will use a more performant algorithm, will maintain its value incrementally,
            processing only those source items that actually changed.</para>
      </remarks>
    </member>
    <member name="M:C1.LiveLinq.LiveViewExtensions.LiveMax``1(C1.LiveLinq.LiveViews.View{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Int64}})">
      <summary>Computes the maximum value of a view of <see cref="T:System.Int64" /> values that are obtained 
            by invoking a transform function on each element of the source view.</summary>
      <typeparam name="TSource">The type of the elements of <i>source</i>.</typeparam>
      <param name="source">A view containing the values to determine the maximum value of.</param>
      <param name="selector">A transform function to apply to each element.</param>
      <returns>A view representing the maximum of the values.</returns>
      <remarks>
        <para>If the <i>source</i> is empty, an <see cref="T:System.InvalidOperationException" /> is thrown.</para>
        <para>It is possible to use standard LINQ query operator <b>Max</b> instead of <b>LiveMax</b>.
            Both are "live" in the sense that they are recomputed automatically when any change occurs in the source.
            The difference is that <b>Max</b> will every time loop through the entire source collection and aggregate it from scratch,
            whereas <b>LiveMax</b> will use a more performant algorithm, will maintain its value incrementally,
            processing only those source items that actually changed.</para>
      </remarks>
    </member>
    <member name="M:C1.LiveLinq.LiveViewExtensions.LiveMax``1(C1.LiveLinq.LiveViews.View{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Nullable{System.Int64}}})">
      <summary>Computes the maximum value of a view of nullable <see cref="T:System.Int64" /> values that are obtained 
            by invoking a transform function on each element of the source view.</summary>
      <typeparam name="TSource">The type of the elements of <i>source</i>.</typeparam>
      <param name="source">A view containing the values to determine the maximum value of.</param>
      <param name="selector">A transform function to apply to each element.</param>
      <returns>A view representing the maximum of the values.</returns>
      <remarks>
        <para>If the <i>source</i> is empty or contains only nulls, the maximum value is null.</para>
        <para>It is possible to use standard LINQ query operator <b>Max</b> instead of <b>LiveMax</b>.
            Both are "live" in the sense that they are recomputed automatically when any change occurs in the source.
            The difference is that <b>Max</b> will every time loop through the entire source collection and aggregate it from scratch,
            whereas <b>LiveMax</b> will use a more performant algorithm, will maintain its value incrementally,
            processing only those source items that actually changed.</para>
      </remarks>
    </member>
    <member name="M:C1.LiveLinq.LiveViewExtensions.LiveMin(C1.LiveLinq.LiveViews.View{System.Double})">
      <summary>Computes the minimum value of a view of <see cref="T:System.Double" /> values.</summary>
      <param name="source">A view containing the values to determine the minimum value of.</param>
      <returns>A view representing the minimum of the values.</returns>
      <remarks>
        <para>If the <i>source</i> is empty or contains only nulls, an <see cref="T:System.InvalidOperationException" /> is thrown.</para>
        <para>It is possible to use standard LINQ query operator <b>Min</b> instead of <b>LiveMin</b>.
            Both are "live" in the sense that they are recomputed automatically when any change occurs in the source.
            The difference is that <b>Min</b> will every time loop through the entire source collection and aggregate it from scratch,
            whereas <b>LiveMin</b> will use a more performant algorithm, will maintain its value incrementally,
            processing only those source items that actually changed.</para>
      </remarks>
    </member>
    <member name="M:C1.LiveLinq.LiveViewExtensions.LiveMin(C1.LiveLinq.LiveViews.View{System.Nullable{System.Double}})">
      <summary>Computes the minimum value of a view of nullable <see cref="T:System.Double" /> values.</summary>
      <param name="source">A view containing the values to determine the minimum value of.</param>
      <returns>A view representing the minimum of the values.</returns>
      <remarks>
        <para>If the <i>source</i> is empty or contains only nulls, the minimum value is null.</para>
        <para>It is possible to use standard LINQ query operator <b>Min</b> instead of <b>LiveMin</b>.
            Both are "live" in the sense that they are recomputed automatically when any change occurs in the source.
            The difference is that <b>Min</b> will every time loop through the entire source collection and aggregate it from scratch,
            whereas <b>LiveMin</b> will use a more performant algorithm, will maintain its value incrementally,
            processing only those source items that actually changed.</para>
      </remarks>
    </member>
    <member name="M:C1.LiveLinq.LiveViewExtensions.LiveMin``1(C1.LiveLinq.LiveViews.View{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Double}})">
      <summary>Computes the minimum value of a view of <see cref="T:System.Double" /> values that are obtained 
            by invoking a transform function on each element of the source view.</summary>
      <typeparam name="TSource">The type of the elements of <i>source</i>.</typeparam>
      <param name="source">A view containing the values to determine the minimum value of.</param>
      <param name="selector">A transform function to apply to each element.</param>
      <returns>A view representing the minimum of the values.</returns>
      <remarks>
        <para>If the <i>source</i> is empty, an <see cref="T:System.InvalidOperationException" /> is thrown.</para>
        <para>It is possible to use standard LINQ query operator <b>Min</b> instead of <b>LiveMin</b>.
            Both are "live" in the sense that they are recomputed automatically when any change occurs in the source.
            The difference is that <b>Min</b> will every time loop through the entire source collection and aggregate it from scratch,
            whereas <b>LiveMin</b> will use a more performant algorithm, will maintain its value incrementally,
            processing only those source items that actually changed.</para>
      </remarks>
    </member>
    <member name="M:C1.LiveLinq.LiveViewExtensions.LiveMin``1(C1.LiveLinq.LiveViews.View{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Nullable{System.Double}}})">
      <summary>Computes the minimum value of a view of nullable <see cref="T:System.Double" /> values that are obtained 
            by invoking a transform function on each element of the source view.</summary>
      <typeparam name="TSource">The type of the elements of <i>source</i>.</typeparam>
      <param name="source">A view containing the values to determine the minimum value of.</param>
      <param name="selector">A transform function to apply to each element.</param>
      <returns>A view representing the minimum of the values.</returns>
      <remarks>
        <para>If the <i>source</i> is empty or contains only nulls, the minimum value is null.</para>
        <para>It is possible to use standard LINQ query operator <b>Min</b> instead of <b>LiveMin</b>.
            Both are "live" in the sense that they are recomputed automatically when any change occurs in the source.
            The difference is that <b>Min</b> will every time loop through the entire source collection and aggregate it from scratch,
            whereas <b>LiveMin</b> will use a more performant algorithm, will maintain its value incrementally,
            processing only those source items that actually changed.</para>
      </remarks>
    </member>
    <member name="M:C1.LiveLinq.LiveViewExtensions.LiveMax(C1.LiveLinq.LiveViews.View{System.Double})">
      <summary>Computes the maximum value of a view of <see cref="T:System.Double" /> values.</summary>
      <param name="source">A view containing the values to determine the maximum value of.</param>
      <returns>A view representing the maximum of the values.</returns>
      <remarks>
        <para>If the <i>source</i> is empty or contains only nulls, an <see cref="T:System.InvalidOperationException" /> is thrown.</para>
        <para>It is possible to use standard LINQ query operator <b>Max</b> instead of <b>LiveMax</b>.
            Both are "live" in the sense that they are recomputed automatically when any change occurs in the source.
            The difference is that <b>Max</b> will every time loop through the entire source collection and aggregate it from scratch,
            whereas <b>LiveMax</b> will use a more performant algorithm, will maintain its value incrementally,
            processing only those source items that actually changed.</para>
      </remarks>
    </member>
    <member name="M:C1.LiveLinq.LiveViewExtensions.LiveMax(C1.LiveLinq.LiveViews.View{System.Nullable{System.Double}})">
      <summary>Computes the maximum value of a view of nullable <see cref="T:System.Double" /> values.</summary>
      <param name="source">A view containing the values to determine the maximum value of.</param>
      <returns>A view representing the maximum of the values.</returns>
      <remarks>
        <para>If the <i>source</i> is empty or contains only nulls, the maximum value is null.</para>
        <para>It is possible to use standard LINQ query operator <b>Max</b> instead of <b>LiveMax</b>.
            Both are "live" in the sense that they are recomputed automatically when any change occurs in the source.
            The difference is that <b>Max</b> will every time loop through the entire source collection and aggregate it from scratch,
            whereas <b>LiveMax</b> will use a more performant algorithm, will maintain its value incrementally,
            processing only those source items that actually changed.</para>
      </remarks>
    </member>
    <member name="M:C1.LiveLinq.LiveViewExtensions.LiveMax``1(C1.LiveLinq.LiveViews.View{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Double}})">
      <summary>Computes the maximum value of a view of <see cref="T:System.Double" /> values that are obtained 
            by invoking a transform function on each element of the source view.</summary>
      <typeparam name="TSource">The type of the elements of <i>source</i>.</typeparam>
      <param name="source">A view containing the values to determine the maximum value of.</param>
      <param name="selector">A transform function to apply to each element.</param>
      <returns>A view representing the maximum of the values.</returns>
      <remarks>
        <para>If the <i>source</i> is empty, an <see cref="T:System.InvalidOperationException" /> is thrown.</para>
        <para>It is possible to use standard LINQ query operator <b>Max</b> instead of <b>LiveMax</b>.
            Both are "live" in the sense that they are recomputed automatically when any change occurs in the source.
            The difference is that <b>Max</b> will every time loop through the entire source collection and aggregate it from scratch,
            whereas <b>LiveMax</b> will use a more performant algorithm, will maintain its value incrementally,
            processing only those source items that actually changed.</para>
      </remarks>
    </member>
    <member name="M:C1.LiveLinq.LiveViewExtensions.LiveMax``1(C1.LiveLinq.LiveViews.View{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Nullable{System.Double}}})">
      <summary>Computes the maximum value of a view of nullable <see cref="T:System.Double" /> values that are obtained 
            by invoking a transform function on each element of the source view.</summary>
      <typeparam name="TSource">The type of the elements of <i>source</i>.</typeparam>
      <param name="source">A view containing the values to determine the maximum value of.</param>
      <param name="selector">A transform function to apply to each element.</param>
      <returns>A view representing the maximum of the values.</returns>
      <remarks>
        <para>If the <i>source</i> is empty or contains only nulls, the maximum value is null.</para>
        <para>It is possible to use standard LINQ query operator <b>Max</b> instead of <b>LiveMax</b>.
            Both are "live" in the sense that they are recomputed automatically when any change occurs in the source.
            The difference is that <b>Max</b> will every time loop through the entire source collection and aggregate it from scratch,
            whereas <b>LiveMax</b> will use a more performant algorithm, will maintain its value incrementally,
            processing only those source items that actually changed.</para>
      </remarks>
    </member>
    <member name="M:C1.LiveLinq.LiveViewExtensions.LiveMin(C1.LiveLinq.LiveViews.View{System.Single})">
      <summary>Computes the minimum value of a view of <see cref="T:System.Single" /> values.</summary>
      <param name="source">A view containing the values to determine the minimum value of.</param>
      <returns>A view representing the minimum of the values.</returns>
      <remarks>
        <para>If the <i>source</i> is empty or contains only nulls, an <see cref="T:System.InvalidOperationException" /> is thrown.</para>
        <para>It is possible to use standard LINQ query operator <b>Min</b> instead of <b>LiveMin</b>.
            Both are "live" in the sense that they are recomputed automatically when any change occurs in the source.
            The difference is that <b>Min</b> will every time loop through the entire source collection and aggregate it from scratch,
            whereas <b>LiveMin</b> will use a more performant algorithm, will maintain its value incrementally,
            processing only those source items that actually changed.</para>
      </remarks>
    </member>
    <member name="M:C1.LiveLinq.LiveViewExtensions.LiveMin(C1.LiveLinq.LiveViews.View{System.Nullable{System.Single}})">
      <summary>Computes the minimum value of a view of nullable <see cref="T:System.Single" /> values.</summary>
      <param name="source">A view containing the values to determine the minimum value of.</param>
      <returns>A view representing the minimum of the values.</returns>
      <remarks>
        <para>If the <i>source</i> is empty or contains only nulls, the minimum value is null.</para>
        <para>It is possible to use standard LINQ query operator <b>Min</b> instead of <b>LiveMin</b>.
            Both are "live" in the sense that they are recomputed automatically when any change occurs in the source.
            The difference is that <b>Min</b> will every time loop through the entire source collection and aggregate it from scratch,
            whereas <b>LiveMin</b> will use a more performant algorithm, will maintain its value incrementally,
            processing only those source items that actually changed.</para>
      </remarks>
    </member>
    <member name="M:C1.LiveLinq.LiveViewExtensions.LiveMin``1(C1.LiveLinq.LiveViews.View{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Single}})">
      <summary>Computes the minimum value of a view of <see cref="T:System.Single" /> values that are obtained 
            by invoking a transform function on each element of the source view.</summary>
      <typeparam name="TSource">The type of the elements of <i>source</i>.</typeparam>
      <param name="source">A view containing the values to determine the minimum value of.</param>
      <param name="selector">A transform function to apply to each element.</param>
      <returns>A view representing the minimum of the values.</returns>
      <remarks>
        <para>If the <i>source</i> is empty, an <see cref="T:System.InvalidOperationException" /> is thrown.</para>
        <para>It is possible to use standard LINQ query operator <b>Min</b> instead of <b>LiveMin</b>.
            Both are "live" in the sense that they are recomputed automatically when any change occurs in the source.
            The difference is that <b>Min</b> will every time loop through the entire source collection and aggregate it from scratch,
            whereas <b>LiveMin</b> will use a more performant algorithm, will maintain its value incrementally,
            processing only those source items that actually changed.</para>
      </remarks>
    </member>
    <member name="M:C1.LiveLinq.LiveViewExtensions.LiveMin``1(C1.LiveLinq.LiveViews.View{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Nullable{System.Single}}})">
      <summary>Computes the minimum value of a view of nullable <see cref="T:System.Single" /> values that are obtained 
            by invoking a transform function on each element of the source view.</summary>
      <typeparam name="TSource">The type of the elements of <i>source</i>.</typeparam>
      <param name="source">A view containing the values to determine the minimum value of.</param>
      <param name="selector">A transform function to apply to each element.</param>
      <returns>A view representing the minimum of the values.</returns>
      <remarks>
        <para>If the <i>source</i> is empty or contains only nulls, the minimum value is null.</para>
        <para>It is possible to use standard LINQ query operator <b>Min</b> instead of <b>LiveMin</b>.
            Both are "live" in the sense that they are recomputed automatically when any change occurs in the source.
            The difference is that <b>Min</b> will every time loop through the entire source collection and aggregate it from scratch,
            whereas <b>LiveMin</b> will use a more performant algorithm, will maintain its value incrementally,
            processing only those source items that actually changed.</para>
      </remarks>
    </member>
    <member name="M:C1.LiveLinq.LiveViewExtensions.LiveMax(C1.LiveLinq.LiveViews.View{System.Single})">
      <summary>Computes the maximum value of a view of <see cref="T:System.Single" /> values.</summary>
      <param name="source">A view containing the values to determine the maximum value of.</param>
      <returns>A view representing the maximum of the values.</returns>
      <remarks>
        <para>If the <i>source</i> is empty or contains only nulls, an <see cref="T:System.InvalidOperationException" /> is thrown.</para>
        <para>It is possible to use standard LINQ query operator <b>Max</b> instead of <b>LiveMax</b>.
            Both are "live" in the sense that they are recomputed automatically when any change occurs in the source.
            The difference is that <b>Max</b> will every time loop through the entire source collection and aggregate it from scratch,
            whereas <b>LiveMax</b> will use a more performant algorithm, will maintain its value incrementally,
            processing only those source items that actually changed.</para>
      </remarks>
    </member>
    <member name="M:C1.LiveLinq.LiveViewExtensions.LiveMax(C1.LiveLinq.LiveViews.View{System.Nullable{System.Single}})">
      <summary>Computes the maximum value of a view of nullable <see cref="T:System.Single" /> values.</summary>
      <param name="source">A view containing the values to determine the maximum value of.</param>
      <returns>A view representing the maximum of the values.</returns>
      <remarks>
        <para>If the <i>source</i> is empty or contains only nulls, the maximum value is null.</para>
        <para>It is possible to use standard LINQ query operator <b>Max</b> instead of <b>LiveMax</b>.
            Both are "live" in the sense that they are recomputed automatically when any change occurs in the source.
            The difference is that <b>Max</b> will every time loop through the entire source collection and aggregate it from scratch,
            whereas <b>LiveMax</b> will use a more performant algorithm, will maintain its value incrementally,
            processing only those source items that actually changed.</para>
      </remarks>
    </member>
    <member name="M:C1.LiveLinq.LiveViewExtensions.LiveMax``1(C1.LiveLinq.LiveViews.View{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Single}})">
      <summary>Computes the maximum value of a view of <see cref="T:System.Single" /> values that are obtained 
            by invoking a transform function on each element of the source view.</summary>
      <typeparam name="TSource">The type of the elements of <i>source</i>.</typeparam>
      <param name="source">A view containing the values to determine the maximum value of.</param>
      <param name="selector">A transform function to apply to each element.</param>
      <returns>A view representing the maximum of the values.</returns>
      <remarks>
        <para>If the <i>source</i> is empty, an <see cref="T:System.InvalidOperationException" /> is thrown.</para>
        <para>It is possible to use standard LINQ query operator <b>Max</b> instead of <b>LiveMax</b>.
            Both are "live" in the sense that they are recomputed automatically when any change occurs in the source.
            The difference is that <b>Max</b> will every time loop through the entire source collection and aggregate it from scratch,
            whereas <b>LiveMax</b> will use a more performant algorithm, will maintain its value incrementally,
            processing only those source items that actually changed.</para>
      </remarks>
    </member>
    <member name="M:C1.LiveLinq.LiveViewExtensions.LiveMax``1(C1.LiveLinq.LiveViews.View{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Nullable{System.Single}}})">
      <summary>Computes the maximum value of a view of nullable <see cref="T:System.Single" /> values that are obtained 
            by invoking a transform function on each element of the source view.</summary>
      <typeparam name="TSource">The type of the elements of <i>source</i>.</typeparam>
      <param name="source">A view containing the values to determine the maximum value of.</param>
      <param name="selector">A transform function to apply to each element.</param>
      <returns>A view representing the maximum of the values.</returns>
      <remarks>
        <para>If the <i>source</i> is empty or contains only nulls, the maximum value is null.</para>
        <para>It is possible to use standard LINQ query operator <b>Max</b> instead of <b>LiveMax</b>.
            Both are "live" in the sense that they are recomputed automatically when any change occurs in the source.
            The difference is that <b>Max</b> will every time loop through the entire source collection and aggregate it from scratch,
            whereas <b>LiveMax</b> will use a more performant algorithm, will maintain its value incrementally,
            processing only those source items that actually changed.</para>
      </remarks>
    </member>
    <member name="M:C1.LiveLinq.LiveViewExtensions.LiveMin``2(C1.LiveLinq.LiveViews.View{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}})">
      <summary>
            Invokes a transform function on each element of a view of elements of a generic type and computes the minimum resulting value.
            </summary>
      <typeparam name="TSource">The type of the elements of <i>source</i>.</typeparam>
      <typeparam name="TResult">The type of the value returned by <i>selector</i>.</typeparam>
      <param name="source">A view containing the values to determine the minimum value of.</param>
      <param name="selector">A transform function to apply to each element.</param>
      <returns>A view representing the minimum of the values.</returns>
      <remarks>
        <para>If type <i>TResult</i> implements <see cref="T:System.IComparable`1" />, this method uses that implementation to compare values.
            Otherwise, if type <i>TResult</i> implements <see cref="T:System.IComparable" />, that implementation is used to compare values.</para>
        <para>It is possible to use standard LINQ query operator <b>Min</b> instead of <b>LiveMax</b>.
            Both are "live" in the sense that they are recomputed automatically when any change occurs in the source.
            The difference is that <b>Min</b> will every time loop through the entire source collection and aggregate it from scratch,
            whereas <b>LiveMax</b> will use a more performant algorithm, will maintain its value incrementally,
            processing only those source items that actually changed.</para>
      </remarks>
    </member>
    <member name="M:C1.LiveLinq.LiveViewExtensions.LiveMin``1(C1.LiveLinq.LiveViews.View{``0})">
      <summary>
            Computes the minimum value of a view of elements of a generic type.
            </summary>
      <typeparam name="TSource">The type of the elements of <i>source</i>.</typeparam>
      <param name="source">A view containing the values to determine the minimum value of.</param>
      <returns>A view representing the minimum of the values.</returns>
      <remarks>
        <para>If type <i>TSource</i> implements <see cref="T:System.IComparable`1" />, this method uses that implementation to compare values.
            Otherwise, if type <i>TSource</i> implements <see cref="T:System.IComparable" />, that implementation is used to compare values.</para>
        <para>It is possible to use standard LINQ query operator <b>Min</b> instead of <b>LiveMax</b>.
            Both are "live" in the sense that they are recomputed automatically when any change occurs in the source.
            The difference is that <b>Min</b> will every time loop through the entire source collection and aggregate it from scratch,
            whereas <b>LiveMax</b> will use a more performant algorithm, will maintain its value incrementally,
            processing only those source items that actually changed.</para>
      </remarks>
    </member>
    <member name="M:C1.LiveLinq.LiveViewExtensions.LiveMax``2(C1.LiveLinq.LiveViews.View{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}})">
      <summary>
            Invokes a transform function on each element of a view of elements of a generic type and computes the maximum resulting value.
            </summary>
      <typeparam name="TSource">The type of the elements of <i>source</i>.</typeparam>
      <typeparam name="TResult">The type of the value returned by <i>selector</i>.</typeparam>
      <param name="source">A view containing the values to determine the maximum value of.</param>
      <param name="selector">A transform function to apply to each element.</param>
      <returns>A view representing the maximum of the values.</returns>
      <remarks>
        <para>If type <i>TResult</i> implements <see cref="T:System.IComparable`1" />, this method uses that implementation to compare values.
            Otherwise, if type <i>TResult</i> implements <see cref="T:System.IComparable" />, that implementation is used to compare values.</para>
        <para>It is possible to use standard LINQ query operator <b>Max</b> instead of <b>LiveMax</b>.
            Both are "live" in the sense that they are recomputed automatically when any change occurs in the source.
            The difference is that <b>Max</b> will every time loop through the entire source collection and aggregate it from scratch,
            whereas <b>LiveMax</b> will use a more performant algorithm, will maintain its value incrementally,
            processing only those source items that actually changed.</para>
      </remarks>
    </member>
    <member name="M:C1.LiveLinq.LiveViewExtensions.LiveMax``1(C1.LiveLinq.LiveViews.View{``0})">
      <summary>
            Computes the maximum value of a view of elements of a generic type.
            </summary>
      <typeparam name="TSource">The type of the elements of <i>source</i>.</typeparam>
      <param name="source">A view containing the values to determine the maximum value of.</param>
      <returns>A view representing the maximum of the values.</returns>
      <remarks>
        <para>If type <i>TSource</i> implements <see cref="T:System.IComparable`1" />, this method uses that implementation to compare values.
            Otherwise, if type <i>TSource</i> implements <see cref="T:System.IComparable" />, that implementation is used to compare values.</para>
        <para>It is possible to use standard LINQ query operator <b>Max</b> instead of <b>LiveMax</b>.
            Both are "live" in the sense that they are recomputed automatically when any change occurs in the source.
            The difference is that <b>Max</b> will every time loop through the entire source collection and aggregate it from scratch,
            whereas <b>LiveMax</b> will use a more performant algorithm, will maintain its value incrementally,
            processing only those source items that actually changed.</para>
      </remarks>
    </member>
    <member name="M:C1.LiveLinq.LiveViewExtensions.LiveSum(C1.LiveLinq.LiveViews.View{System.Int32})">
      <summary>Computes the sum of a view of <see cref="T:System.Int32" /> values.</summary>
      <param name="source">A view containing the values to calculate the sum of.</param>
      <returns>A view representing the sum of the values.</returns>
      <remarks>
        <para>If the <i>source</i> is empty or contains only nulls, the sum value is zero.</para>
        <para>It is possible to use standard LINQ query operator <b>Sum</b> instead of <b>LiveSum</b>.
            Both are "live" in the sense that they are recomputed automatically when any change occurs in the source.
            The difference is that <b>Sum</b> will every time loop through the entire source collection and aggregate it from scratch,
            whereas <b>LiveSum</b> will use a more performant algorithm, will maintain its value incrementally,
            processing only those source items that actually changed.</para>
      </remarks>
    </member>
    <member name="M:C1.LiveLinq.LiveViewExtensions.LiveSum(C1.LiveLinq.LiveViews.View{System.Nullable{System.Int32}})">
      <summary>Computes the sum of a view of nullable <see cref="T:System.Int32" /> values.</summary>
      <param name="source">A view containing the values to calculate the sum of.</param>
      <returns>A view representing the sum of the values.</returns>
      <remarks>
        <para>If the <i>source</i> is empty or contains only nulls, the sum value is zero.</para>
        <para>It is possible to use standard LINQ query operator <b>Sum</b> instead of <b>LiveSum</b>.
            Both are "live" in the sense that they are recomputed automatically when any change occurs in the source.
            The difference is that <b>Sum</b> will every time loop through the entire source collection and aggregate it from scratch,
            whereas <b>LiveSum</b> will use a more performant algorithm, will maintain its value incrementally,
            processing only those source items that actually changed.</para>
      </remarks>
    </member>
    <member name="M:C1.LiveLinq.LiveViewExtensions.LiveSum``1(C1.LiveLinq.LiveViews.View{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Int32}})">
      <summary>Computes the sum of a view of <see cref="T:System.Int32" /> values that are obtained 
            by invoking a transform function on each element of the source view.</summary>
      <typeparam name="TSource">The type of the elements of <i>source</i>.</typeparam>
      <param name="source">A view containing the values to calculate the sum of.</param>
      <param name="selector">A transform function to apply to each element.</param>
      <returns>A view representing the sum of the values.</returns>
      <remarks>
        <para>If the <i>source</i> is empty or contains only nulls, the sum value is zero.</para>
        <para>It is possible to use standard LINQ query operator <b>Sum</b> instead of <b>LiveSum</b>.
            Both are "live" in the sense that they are recomputed automatically when any change occurs in the source.
            The difference is that <b>Sum</b> will every time loop through the entire source collection and aggregate it from scratch,
            whereas <b>LiveSum</b> will use a more performant algorithm, will maintain its value incrementally,
            processing only those source items that actually changed.</para>
      </remarks>
    </member>
    <member name="M:C1.LiveLinq.LiveViewExtensions.LiveSum``1(C1.LiveLinq.LiveViews.View{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Nullable{System.Int32}}})">
      <summary>Computes the sum of a view of nullable <see cref="T:System.Int32" /> values that are obtained 
            by invoking a transform function on each element of the source view.</summary>
      <typeparam name="TSource">The type of the elements of <i>source</i>.</typeparam>
      <param name="source">A view containing the values to calculate the sum of.</param>
      <param name="selector">A transform function to apply to each element.</param>
      <returns>A view representing the sum of the values.</returns>
      <remarks>
        <para>If the <i>source</i> is empty or contains only nulls, the sum value is zero.</para>
        <para>It is possible to use standard LINQ query operator <b>Sum</b> instead of <b>LiveSum</b>.
            Both are "live" in the sense that they are recomputed automatically when any change occurs in the source.
            The difference is that <b>Sum</b> will every time loop through the entire source collection and aggregate it from scratch,
            whereas <b>LiveSum</b> will use a more performant algorithm, will maintain its value incrementally,
            processing only those source items that actually changed.</para>
      </remarks>
    </member>
    <member name="M:C1.LiveLinq.LiveViewExtensions.LiveSum(C1.LiveLinq.LiveViews.View{System.Decimal})">
      <summary>Computes the sum of a view of <see cref="T:System.Decimal" /> values.</summary>
      <param name="source">A view containing the values to calculate the sum of.</param>
      <returns>A view representing the sum of the values.</returns>
      <remarks>
        <para>If the <i>source</i> is empty or contains only nulls, the sum value is zero.</para>
        <para>It is possible to use standard LINQ query operator <b>Sum</b> instead of <b>LiveSum</b>.
            Both are "live" in the sense that they are recomputed automatically when any change occurs in the source.
            The difference is that <b>Sum</b> will every time loop through the entire source collection and aggregate it from scratch,
            whereas <b>LiveSum</b> will use a more performant algorithm, will maintain its value incrementally,
            processing only those source items that actually changed.</para>
      </remarks>
    </member>
    <member name="M:C1.LiveLinq.LiveViewExtensions.LiveSum(C1.LiveLinq.LiveViews.View{System.Nullable{System.Decimal}})">
      <summary>Computes the sum of a view of nullable <see cref="T:System.Decimal" /> values.</summary>
      <param name="source">A view containing the values to calculate the sum of.</param>
      <returns>A view representing the sum of the values.</returns>
      <remarks>
        <para>If the <i>source</i> is empty or contains only nulls, the sum value is zero.</para>
        <para>It is possible to use standard LINQ query operator <b>Sum</b> instead of <b>LiveSum</b>.
            Both are "live" in the sense that they are recomputed automatically when any change occurs in the source.
            The difference is that <b>Sum</b> will every time loop through the entire source collection and aggregate it from scratch,
            whereas <b>LiveSum</b> will use a more performant algorithm, will maintain its value incrementally,
            processing only those source items that actually changed.</para>
      </remarks>
    </member>
    <member name="M:C1.LiveLinq.LiveViewExtensions.LiveSum``1(C1.LiveLinq.LiveViews.View{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Decimal}})">
      <summary>Computes the sum of a view of <see cref="T:System.Decimal" /> values that are obtained 
            by invoking a transform function on each element of the source view.</summary>
      <typeparam name="TSource">The type of the elements of <i>source</i>.</typeparam>
      <param name="source">A view containing the values to calculate the sum of.</param>
      <param name="selector">A transform function to apply to each element.</param>
      <returns>A view representing the sum of the values.</returns>
      <remarks>
        <para>If the <i>source</i> is empty or contains only nulls, the sum value is zero.</para>
        <para>It is possible to use standard LINQ query operator <b>Sum</b> instead of <b>LiveSum</b>.
            Both are "live" in the sense that they are recomputed automatically when any change occurs in the source.
            The difference is that <b>Sum</b> will every time loop through the entire source collection and aggregate it from scratch,
            whereas <b>LiveSum</b> will use a more performant algorithm, will maintain its value incrementally,
            processing only those source items that actually changed.</para>
      </remarks>
    </member>
    <member name="M:C1.LiveLinq.LiveViewExtensions.LiveSum``1(C1.LiveLinq.LiveViews.View{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Nullable{System.Decimal}}})">
      <summary>Computes the sum of a view of nullable <see cref="T:System.Decimal" /> values that are obtained 
            by invoking a transform function on each element of the source view.</summary>
      <typeparam name="TSource">The type of the elements of <i>source</i>.</typeparam>
      <param name="source">A view containing the values to calculate the sum of.</param>
      <param name="selector">A transform function to apply to each element.</param>
      <returns>A view representing the sum of the values.</returns>
      <remarks>
        <para>If the <i>source</i> is empty or contains only nulls, the sum value is zero.</para>
        <para>It is possible to use standard LINQ query operator <b>Sum</b> instead of <b>LiveSum</b>.
            Both are "live" in the sense that they are recomputed automatically when any change occurs in the source.
            The difference is that <b>Sum</b> will every time loop through the entire source collection and aggregate it from scratch,
            whereas <b>LiveSum</b> will use a more performant algorithm, will maintain its value incrementally,
            processing only those source items that actually changed.</para>
      </remarks>
    </member>
    <member name="M:C1.LiveLinq.LiveViewExtensions.LiveSum(C1.LiveLinq.LiveViews.View{System.Int64})">
      <summary>Computes the sum of a view of <see cref="T:System.Int64" /> values.</summary>
      <param name="source">A view containing the values to calculate the sum of.</param>
      <returns>A view representing the sum of the values.</returns>
      <remarks>
        <para>If the <i>source</i> is empty or contains only nulls, the sum value is zero.</para>
        <para>It is possible to use standard LINQ query operator <b>Sum</b> instead of <b>LiveSum</b>.
            Both are "live" in the sense that they are recomputed automatically when any change occurs in the source.
            The difference is that <b>Sum</b> will every time loop through the entire source collection and aggregate it from scratch,
            whereas <b>LiveSum</b> will use a more performant algorithm, will maintain its value incrementally,
            processing only those source items that actually changed.</para>
      </remarks>
    </member>
    <member name="M:C1.LiveLinq.LiveViewExtensions.LiveSum(C1.LiveLinq.LiveViews.View{System.Nullable{System.Int64}})">
      <summary>Computes the sum of a view of nullable <see cref="T:System.Int64" /> values.</summary>
      <param name="source">A view containing the values to calculate the sum of.</param>
      <returns>A view representing the sum of the values.</returns>
      <remarks>
        <para>If the <i>source</i> is empty or contains only nulls, the sum value is zero.</para>
        <para>It is possible to use standard LINQ query operator <b>Sum</b> instead of <b>LiveSum</b>.
            Both are "live" in the sense that they are recomputed automatically when any change occurs in the source.
            The difference is that <b>Sum</b> will every time loop through the entire source collection and aggregate it from scratch,
            whereas <b>LiveSum</b> will use a more performant algorithm, will maintain its value incrementally,
            processing only those source items that actually changed.</para>
      </remarks>
    </member>
    <member name="M:C1.LiveLinq.LiveViewExtensions.LiveSum``1(C1.LiveLinq.LiveViews.View{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Int64}})">
      <summary>Computes the sum of a view of <see cref="T:System.Int64" /> values that are obtained 
            by invoking a transform function on each element of the source view.</summary>
      <typeparam name="TSource">The type of the elements of <i>source</i>.</typeparam>
      <param name="source">A view containing the values to calculate the sum of.</param>
      <param name="selector">A transform function to apply to each element.</param>
      <returns>A view representing the sum of the values.</returns>
      <remarks>
        <para>If the <i>source</i> is empty or contains only nulls, the sum value is zero.</para>
        <para>It is possible to use standard LINQ query operator <b>Sum</b> instead of <b>LiveSum</b>.
            Both are "live" in the sense that they are recomputed automatically when any change occurs in the source.
            The difference is that <b>Sum</b> will every time loop through the entire source collection and aggregate it from scratch,
            whereas <b>LiveSum</b> will use a more performant algorithm, will maintain its value incrementally,
            processing only those source items that actually changed.</para>
      </remarks>
    </member>
    <member name="M:C1.LiveLinq.LiveViewExtensions.LiveSum``1(C1.LiveLinq.LiveViews.View{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Nullable{System.Int64}}})">
      <summary>Computes the sum of a view of nullable <see cref="T:System.Int64" /> values that are obtained 
            by invoking a transform function on each element of the source view.</summary>
      <typeparam name="TSource">The type of the elements of <i>source</i>.</typeparam>
      <param name="source">A view containing the values to calculate the sum of.</param>
      <param name="selector">A transform function to apply to each element.</param>
      <returns>A view representing the sum of the values.</returns>
      <remarks>
        <para>If the <i>source</i> is empty or contains only nulls, the sum value is zero.</para>
        <para>It is possible to use standard LINQ query operator <b>Sum</b> instead of <b>LiveSum</b>.
            Both are "live" in the sense that they are recomputed automatically when any change occurs in the source.
            The difference is that <b>Sum</b> will every time loop through the entire source collection and aggregate it from scratch,
            whereas <b>LiveSum</b> will use a more performant algorithm, will maintain its value incrementally,
            processing only those source items that actually changed.</para>
      </remarks>
    </member>
    <member name="M:C1.LiveLinq.LiveViewExtensions.LiveSum(C1.LiveLinq.LiveViews.View{System.Double})">
      <summary>Computes the sum of a view of <see cref="T:System.Double" /> values.</summary>
      <param name="source">A view containing the values to calculate the sum of.</param>
      <returns>A view representing the sum of the values.</returns>
      <remarks>
        <para>If the <i>source</i> is empty or contains only nulls, the sum value is zero.</para>
        <para>It is possible to use standard LINQ query operator <b>Sum</b> instead of <b>LiveSum</b>.
            Both are "live" in the sense that they are recomputed automatically when any change occurs in the source.
            The difference is that <b>Sum</b> will every time loop through the entire source collection and aggregate it from scratch,
            whereas <b>LiveSum</b> will use a more performant algorithm, will maintain its value incrementally,
            processing only those source items that actually changed.</para>
      </remarks>
    </member>
    <member name="M:C1.LiveLinq.LiveViewExtensions.LiveSum(C1.LiveLinq.LiveViews.View{System.Nullable{System.Double}})">
      <summary>Computes the sum of a view of nullable <see cref="T:System.Double" /> values.</summary>
      <param name="source">A view containing the values to calculate the sum of.</param>
      <returns>A view representing the sum of the values.</returns>
      <remarks>
        <para>If the <i>source</i> is empty or contains only nulls, the sum value is zero.</para>
        <para>It is possible to use standard LINQ query operator <b>Sum</b> instead of <b>LiveSum</b>.
            Both are "live" in the sense that they are recomputed automatically when any change occurs in the source.
            The difference is that <b>Sum</b> will every time loop through the entire source collection and aggregate it from scratch,
            whereas <b>LiveSum</b> will use a more performant algorithm, will maintain its value incrementally,
            processing only those source items that actually changed.</para>
      </remarks>
    </member>
    <member name="M:C1.LiveLinq.LiveViewExtensions.LiveSum``1(C1.LiveLinq.LiveViews.View{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Double}})">
      <summary>Computes the sum of a view of <see cref="T:System.Double" /> values that are obtained 
            by invoking a transform function on each element of the source view.</summary>
      <typeparam name="TSource">The type of the elements of <i>source</i>.</typeparam>
      <param name="source">A view containing the values to calculate the sum of.</param>
      <param name="selector">A transform function to apply to each element.</param>
      <returns>A view representing the sum of the values.</returns>
      <remarks>
        <para>If the <i>source</i> is empty or contains only nulls, the sum value is zero.</para>
        <para>It is possible to use standard LINQ query operator <b>Sum</b> instead of <b>LiveSum</b>.
            Both are "live" in the sense that they are recomputed automatically when any change occurs in the source.
            The difference is that <b>Sum</b> will every time loop through the entire source collection and aggregate it from scratch,
            whereas <b>LiveSum</b> will use a more performant algorithm, will maintain its value incrementally,
            processing only those source items that actually changed.</para>
      </remarks>
    </member>
    <member name="M:C1.LiveLinq.LiveViewExtensions.LiveSum``1(C1.LiveLinq.LiveViews.View{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Nullable{System.Double}}})">
      <summary>Computes the sum of a view of nullable <see cref="T:System.Double" /> values that are obtained 
            by invoking a transform function on each element of the source view.</summary>
      <typeparam name="TSource">The type of the elements of <i>source</i>.</typeparam>
      <param name="source">A view containing the values to calculate the sum of.</param>
      <param name="selector">A transform function to apply to each element.</param>
      <returns>A view representing the sum of the values.</returns>
      <remarks>
        <para>If the <i>source</i> is empty or contains only nulls, the sum value is zero.</para>
        <para>It is possible to use standard LINQ query operator <b>Sum</b> instead of <b>LiveSum</b>.
            Both are "live" in the sense that they are recomputed automatically when any change occurs in the source.
            The difference is that <b>Sum</b> will every time loop through the entire source collection and aggregate it from scratch,
            whereas <b>LiveSum</b> will use a more performant algorithm, will maintain its value incrementally,
            processing only those source items that actually changed.</para>
      </remarks>
    </member>
    <member name="M:C1.LiveLinq.LiveViewExtensions.LiveSum(C1.LiveLinq.LiveViews.View{System.Single})">
      <summary>Computes the sum of a view of <see cref="T:System.Single" /> values.</summary>
      <param name="source">A view containing the values to calculate the sum of.</param>
      <returns>A view representing the sum of the values.</returns>
      <remarks>
        <para>If the <i>source</i> is empty or contains only nulls, the sum value is zero.</para>
        <para>It is possible to use standard LINQ query operator <b>Sum</b> instead of <b>LiveSum</b>.
            Both are "live" in the sense that they are recomputed automatically when any change occurs in the source.
            The difference is that <b>Sum</b> will every time loop through the entire source collection and aggregate it from scratch,
            whereas <b>LiveSum</b> will use a more performant algorithm, will maintain its value incrementally,
            processing only those source items that actually changed.</para>
      </remarks>
    </member>
    <member name="M:C1.LiveLinq.LiveViewExtensions.LiveSum(C1.LiveLinq.LiveViews.View{System.Nullable{System.Single}})">
      <summary>Computes the sum of a view of nullable <see cref="T:System.Single" /> values.</summary>
      <param name="source">A view containing the values to calculate the sum of.</param>
      <returns>A view representing the sum of the values.</returns>
      <remarks>
        <para>If the <i>source</i> is empty or contains only nulls, the sum value is zero.</para>
        <para>It is possible to use standard LINQ query operator <b>Sum</b> instead of <b>LiveSum</b>.
            Both are "live" in the sense that they are recomputed automatically when any change occurs in the source.
            The difference is that <b>Sum</b> will every time loop through the entire source collection and aggregate it from scratch,
            whereas <b>LiveSum</b> will use a more performant algorithm, will maintain its value incrementally,
            processing only those source items that actually changed.</para>
      </remarks>
    </member>
    <member name="M:C1.LiveLinq.LiveViewExtensions.LiveSum``1(C1.LiveLinq.LiveViews.View{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Single}})">
      <summary>Computes the sum of a view of <see cref="T:System.Single" /> values that are obtained 
            by invoking a transform function on each element of the source view.</summary>
      <typeparam name="TSource">The type of the elements of <i>source</i>.</typeparam>
      <param name="source">A view containing the values to calculate the sum of.</param>
      <param name="selector">A transform function to apply to each element.</param>
      <returns>A view representing the sum of the values.</returns>
      <remarks>
        <para>If the <i>source</i> is empty or contains only nulls, the sum value is zero.</para>
        <para>It is possible to use standard LINQ query operator <b>Sum</b> instead of <b>LiveSum</b>.
            Both are "live" in the sense that they are recomputed automatically when any change occurs in the source.
            The difference is that <b>Sum</b> will every time loop through the entire source collection and aggregate it from scratch,
            whereas <b>LiveSum</b> will use a more performant algorithm, will maintain its value incrementally,
            processing only those source items that actually changed.</para>
      </remarks>
    </member>
    <member name="M:C1.LiveLinq.LiveViewExtensions.LiveSum``1(C1.LiveLinq.LiveViews.View{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Nullable{System.Single}}})">
      <summary>Computes the sum of a view of nullable <see cref="T:System.Single" /> values that are obtained 
            by invoking a transform function on each element of the source view.</summary>
      <typeparam name="TSource">The type of the elements of <i>source</i>.</typeparam>
      <param name="source">A view containing the values to calculate the sum of.</param>
      <param name="selector">A transform function to apply to each element.</param>
      <returns>A view representing the sum of the values.</returns>
      <remarks>
        <para>If the <i>source</i> is empty or contains only nulls, the sum value is zero.</para>
        <para>It is possible to use standard LINQ query operator <b>Sum</b> instead of <b>LiveSum</b>.
            Both are "live" in the sense that they are recomputed automatically when any change occurs in the source.
            The difference is that <b>Sum</b> will every time loop through the entire source collection and aggregate it from scratch,
            whereas <b>LiveSum</b> will use a more performant algorithm, will maintain its value incrementally,
            processing only those source items that actually changed.</para>
      </remarks>
    </member>
    <member name="M:C1.LiveLinq.LiveViewExtensions.AsLive``1(C1.LiveLinq.IObservableSource{``0})">
      <summary>Creates a view based on the specified <see cref="T:C1.LiveLinq.IObservableSource`1" /> collection.</summary>
      <typeparam name="T">The type of the elements in the collection.</typeparam>
      <param name="source">The <see cref="T:C1.LiveLinq.IObservableSource`1" /> collection to expose as a view.</param>
      <returns>A view that contains the same elements as the <see cref="T:C1.LiveLinq.IObservableSource`1" /></returns>
      <remarks>The resulting view may have its elements ordered differently than they are ordered in the <i>source</i> collection.
            Correspondingly, views built on this resulting view (for example, if you filter it with <b>Where</b>) will not preserve the source order either.
            If you need to preserve the source order, consider using the other <b>AsLive</b> overload where 
            you can specify to what extent you need the order to be preserved.</remarks>
    </member>
    <member name="M:C1.LiveLinq.LiveViewExtensions.AsLive``1(C1.LiveLinq.IObservableSource{``0},C1.LiveLinq.LiveViews.ViewOrder)">
      <summary>Creates a view based on the specified <see cref="T:C1.LiveLinq.IObservableSource`1" /> collection.</summary>
      <typeparam name="T">The type of the elements in the collection.</typeparam>
      <param name="source">The <see cref="T:C1.LiveLinq.IObservableSource`1" /> collection to expose as a view.</param>
      <param name="order">Specifies whether to preserve source item order.</param>
      <returns>A view that contains the same elements as the <see cref="T:C1.LiveLinq.IObservableSource`1" /></returns>
      <remarks>
        <para>If the <i>order</i> parameter specifies preserving item order, the order of items in the source is preserved,
            at a certain performance cost, in the resulting view and in views based on it (for example, if you filter it with <b>Where</b>).</para>
        <para>Note that <b>Join</b> does not preserve source order. If you need to order a join result, use <b>OrderBy</b> after <b>Join</b>.</para>
      </remarks>
    </member>
    <member name="M:C1.LiveLinq.LiveViewExtensions.AsLive``1(System.ComponentModel.IBindingList)">
      <summary>Creates a view based on the specified <see cref="T:System.ComponentModel.IBindingList" /> data source.</summary>
      <typeparam name="T">The type of the elements in the view.</typeparam>
      <param name="source">The <see cref="T:System.ComponentModel.IBindingList" /> data source to expose as a view.</param>
      <returns>A view that contains the same elements as the <see cref="T:System.ComponentModel.IBindingList" />.</returns>
      <remarks>
        <para>Use this method to build views from existing data sources. The only requirements for the data source 
            is that it implements the standard data binding interface <see cref="T:System.ComponentModel.IBindingList" />.</para>
        <para>The resulting view may have its elements ordered differently than they are ordered in the <i>source</i> collection.
            Correspondingly, views built on this resulting view (for example, if you filter it with <b>Where</b>) will not preserve the source order either.
            If you need to preserve the source order, consider using the other <b>AsLive</b> overload where 
            you can specify to what extent you need the order to be preserved.</para>
      </remarks>
    </member>
    <member name="M:C1.LiveLinq.LiveViewExtensions.AsLive``1(System.ComponentModel.IBindingList,C1.LiveLinq.LiveViews.ViewOrder)">
      <summary>Creates a view based on the specified <see cref="T:System.ComponentModel.IBindingList" /> data source.</summary>
      <typeparam name="T">The type of the elements in the view.</typeparam>
      <param name="source">The <see cref="T:System.ComponentModel.IBindingList" /> data source to expose as a view.</param>
      <param name="order">Specifies whether to preserve source item order.</param>
      <returns>A view that contains the same elements as the <see cref="T:System.ComponentModel.IBindingList" />.</returns>
      <remarks>
        <para>Use this method to build views from existing data sources. The only requirements for the data source 
            is that it implements the standard data binding interface <see cref="T:System.ComponentModel.IBindingList" />.</para>
        <para>If the <i>order</i> parameter specifies preserving item order, the order of items in the source is preserved,
            at a certain performance cost, in the resulting view and in views based on it (for example, if you filter it with <b>Where</b>).</para>
        <para>Note that <b>Join</b> does not preserve source order. If you need to order a join result, use <b>OrderBy</b> after <b>Join</b>.</para>
      </remarks>
    </member>
    <member name="M:C1.LiveLinq.LiveViewExtensions.AsLive``1(System.ComponentModel.BindingList{``0})">
      <summary>A typed specialization of the <see cref="M:C1.LiveLinq.LiveViewExtensions.AsLive``1(System.ComponentModel.IBindingList)" /> method.</summary>
      <typeparam name="T">The type of the elements in the view.</typeparam>
      <param name="source">The <see cref="T:System.ComponentModel.BindingList`1" /> data source to expose as a view.</param>
      <returns>A view that contains the same elements as the <see cref="T:System.ComponentModel.BindingList`1" />.</returns>
    </member>
    <member name="M:C1.LiveLinq.LiveViewExtensions.AsLive``1(System.ComponentModel.BindingList{``0},C1.LiveLinq.LiveViews.ViewOrder)">
      <summary>A typed specialization of the <see cref="M:C1.LiveLinq.LiveViewExtensions.AsLive``1(System.ComponentModel.IBindingList,C1.LiveLinq.LiveViews.ViewOrder)" /> method.</summary>
      <typeparam name="T">The type of the elements in the view.</typeparam>
      <param name="source">The <see cref="T:System.ComponentModel.BindingList`1" /> data source to expose as a view.</param>
      <param name="order">Specifies whether to preserve source item order.</param>
      <returns>A view that contains the same elements as the <see cref="T:System.ComponentModel.BindingList`1" />.</returns>
    </member>
    <member name="M:C1.LiveLinq.LiveViewExtensions.AsUpdatable``1(C1.LiveLinq.LiveViews.View{``0})">
      <summary>Specifies a view as updatable.</summary>
      <typeparam name="T">The type of the elements in the view.</typeparam>
      <param name="view">The view to specify as updatable.</param>
      <returns>The same <i>view</i>.</returns>
      <remarks>
        <para>This method is used with <b>Join</b> operation to specify which of the two parts of the join you want to be updatable.</para>
        <para>Properties exposed by a view can be updatable or read-only. Updatable properties of a view can be modified directly in the view.
            Read-only properties of a view cannot be modified directly in the view, but they still reflect up-to-date values of the source,
            so the difference is often not critical, you can always modify corresponding property in the source, that
            will automatically change the property in the view.</para>
        <para>Only one of the two arguments of a <b>Join</b> can be updatable, the one you qualified with <b>AsUpdatable()</b>.
            In absence of this qualification, both parts of the join are read-only. For example, in
            <code>
            from c in customers.AsLive()
            join o in orders.AsLive().AsUpdatable() on o.CustomerID equals c.CustomerID
            select new { c.CustomerName, o.OrderDate, o.OrderAmount }
            </code><b>CustomerName</b> is read-only, and <b>OrderDate</b> and <b>OrderAmount</b> are updatable.</para>
      </remarks>
      <seealso cref="P:C1.LiveLinq.LiveViews.View.IsReadOnly" />
      <seealso cref="T:C1.LiveLinq.LiveViews.ViewRow" />
      <seealso cref="T:C1.LiveLinq.LiveViews.ViewRowState" />
    </member>
    <member name="M:C1.LiveLinq.LiveViewExtensions.AsNonUpdatable``1(C1.LiveLinq.LiveViews.View{``0})">
      <summary>Specifies a view as read-only.</summary>
      <typeparam name="T">The type of the elements in the view.</typeparam>
      <param name="view">The view to specify as read-only.</param>
      <returns>The same <i>view</i>.</returns>
      <seealso cref="M:C1.LiveLinq.LiveViewExtensions.AsUpdatable``1(C1.LiveLinq.LiveViews.View{``0})" />
    </member>
    <member name="T:C1.LiveLinq.LiveViews.AggregationView`2">
      <summary>Represents a view having a single element calculated by aggregating a source view.</summary>
      <typeparam name="TSource">The type of the elements of the source view.</typeparam>
      <typeparam name="TResult">The type of the single element of the aggregation view.</typeparam>
    </member>
    <member name="P:C1.LiveLinq.LiveViews.AggregationView`2.Value">
      <summary>Gets the value of the single element of the aggregation view.</summary>
    </member>
    <member name="T:C1.LiveLinq.LiveViews.GroupView`2">
      <summary>A group in a grouping view.</summary>
      <typeparam name="TKey">The type of the key used for grouping.</typeparam>
      <typeparam name="TElement">The type of the elements in the group view.</typeparam>
      <remarks>
            A grouping view is a result of a <b>GroupBy</b> operation on a live view. It is a collection of groups.
            Each group contains elements with the same key. That collection is a live view, and every group in itself is a live view,
            an object of type <b>GroupView&lt;TKey, TElement&gt;</b>.
            </remarks>
    </member>
    <member name="M:C1.LiveLinq.LiveViews.GroupView`2.ToString">
      <summary>Returns a string that represents this instance of <see cref="T:C1.LiveLinq.LiveViews.GroupView`2" /></summary>
    </member>
    <member name="M:C1.LiveLinq.LiveViews.GroupView`2.Rebuild">
      <summary>This method overrides <see cref="M:C1.LiveLinq.LiveViews.View.Rebuild" />.</summary>
    </member>
    <member name="M:C1.LiveLinq.LiveViews.GroupView`2.Maintain">
      <summary>This method overrides <see cref="M:C1.LiveLinq.LiveViews.View.Maintain" />.</summary>
    </member>
    <member name="M:C1.LiveLinq.LiveViews.GroupView`2.PurgeEmptyGroups">
      <summary>This method overrides <see cref="M:C1.LiveLinq.LiveViews.View.PurgeEmptyGroups" />.</summary>
    </member>
    <member name="P:C1.LiveLinq.LiveViews.GroupView`2.Key">
      <summary>Gets the key value of the group.</summary>
      <remarks>The key value is common to the elements of this group.</remarks>
    </member>
    <member name="P:C1.LiveLinq.LiveViews.GroupView`2.Parent">
      <summary>Gets the grouping view (the result of a <b>GroupBy</b> operation) to which this group belongs.</summary>
    </member>
    <member name="P:C1.LiveLinq.LiveViews.GroupView`2.MaintenanceMode">
      <summary>This property overrides <see cref="P:C1.LiveLinq.LiveViews.View.MaintenanceMode" />.</summary>
    </member>
    <member name="P:C1.LiveLinq.LiveViews.GroupView`2.DeferredMaintenance">
      <summary>This property overrides <see cref="P:C1.LiveLinq.LiveViews.View.DeferredMaintenance" />.</summary>
    </member>
    <member name="T:C1.LiveLinq.LiveViews.OrderedView`1">
      <summary>Represents a sorted view.</summary>
      <typeparam name="T">The type of the elements in the view.</typeparam>
      <seealso cref="M:C1.LiveLinq.LiveViews.View`1.OrderBy``1(System.Linq.Expressions.Expression{System.Func{`0,``0}})" />
      <seealso cref="M:C1.LiveLinq.LiveViews.View`1.OrderByDescending``1(System.Linq.Expressions.Expression{System.Func{`0,``0}})" />
    </member>
    <member name="M:C1.LiveLinq.LiveViews.OrderedView`1.ThenBy``1(System.Linq.Expressions.Expression{System.Func{`0,``0}})">
      <summary>Performs a subsequent ordering of view elements in ascending order according to a key.</summary>
      <typeparam name="TKey">The type of the key returned by <i>keySelector</i>.</typeparam>
      <param name="keySelector">A function to extract a key from each element.</param>
      <returns>A view whose elements are sorted according to a key.</returns>
    </member>
    <member name="M:C1.LiveLinq.LiveViews.OrderedView`1.ThenByDescending``1(System.Linq.Expressions.Expression{System.Func{`0,``0}})">
      <summary>Performs a subsequent ordering of view elements in descending order according to a key.</summary>
      <typeparam name="TKey">The type of the key returned by <i>keySelector</i>.</typeparam>
      <param name="keySelector">A function to extract a key from each element.</param>
      <returns>A view whose elements are sorted in descending order according to a key.</returns>
    </member>
    <member name="T:C1.LiveLinq.LiveViews.ViewMaintenanceMode">
      <summary>Specifies how a view is synchronized with changes in its base data.</summary>
      <remarks>
        <b>See Also:</b>
        <span style="C1H Jump">View Maintenance Mode</span>.</remarks>
      <seealso cref="P:C1.LiveLinq.LiveViews.View.MaintenanceMode" />
      <seealso cref="P:C1.LiveLinq.LiveViews.View.DeferredMaintenance" />
    </member>
    <member name="F:C1.LiveLinq.LiveViews.ViewMaintenanceMode.Default">
      <summary>
        <para>By default, the view is in a "smart mode": It is in <b>Deferred</b> mode if nobody is interested in its data,
            and it is synchronized and goes to <b>Immediate</b> mode if there is a client interested in receiving
            notifications of changes in that view's data.</para>
        <para>In other words, a view in <b>Default</b> mode is effectively in <b>Deferred</b> mode if no listeners registered to
            be notified of its changes, and it is effectively in <b>Immediate</b> mode if there are such listeners
            (for example, if there is GUI control bound to it).</para>
      </summary>
    </member>
    <member name="F:C1.LiveLinq.LiveViews.ViewMaintenanceMode.Deferred">
      <summary>
            When a change in base data occur, the view is not synchronized with it immediately. It is allowed to go stale,
            out of sync with its base data as long as there are no requests for this view's data.
            The view is synchronized on demand, that is, it is synchronized when any request for its data arrives.
            </summary>
    </member>
    <member name="F:C1.LiveLinq.LiveViews.ViewMaintenanceMode.Immediate">
      <summary>
            The view is synchronized with its base data automatically and immediately after any change in its base data occurs.
            The view is kept synchronized with its base data at all times.
            </summary>
    </member>
    <member name="T:C1.LiveLinq.LiveViews.ViewRowAddingEventArgs">
      <summary>Provides data for the <see cref="E:C1.LiveLinq.LiveViews.ViewRowCollection.ViewRowAdding" /> event.</summary>
    </member>
    <member name="P:C1.LiveLinq.LiveViews.ViewRowAddingEventArgs.Row">
      <summary>Gets the new view row that has just been added to <see cref="T:C1.LiveLinq.LiveViews.ViewRowCollection" />.</summary>
    </member>
    <member name="T:C1.LiveLinq.LiveViews.ViewRowState">
      <summary>The state of a view row with regard to edit, add and delete operations if they are performed directly on the view.</summary>
      <remarks>
        <para> This state concerns edit, add and delete operations performed directly on the view (programmatically via
            <see cref="T:C1.LiveLinq.LiveViews.ViewRow" /> objects or through data binding). It does not concern modifications made to the view's
            base (source) data collections. Modifications made to source data can also change view items, as a result of the normal
            view maintenance process, see <see cref="P:C1.LiveLinq.LiveViews.View.MaintenanceMode" />, but in that case the state of thus added
            or modified rows remains <b>Unmodified</b>. </para>
        <para>
          <b>Note on adding rows directly to the view:</b>
        </para>
        <para>If a row is added directly to the view (as opposed to adding it to one of its base data collections), the following happens:</para>
        <para>When a new row is created with <see cref="M:C1.LiveLinq.LiveViews.ViewRowCollection.CreateRow" /> or through data binding, it enters edit mode.</para>
            When it is committed with <see cref="M:C1.LiveLinq.LiveViews.ViewRow.EndEdit" />,
            a new row is added to the view's base data collection, and, usually,
            a corresponding row appears in the view, that has <b>Unmodified</b> state, although
            in some cases it may be more than one row or none, depending on the view query. The original view row
            no longer corresponds to a view item after the <see cref="M:C1.LiveLinq.LiveViews.ViewRow.EndEdit" /> or <see cref="M:C1.LiveLinq.LiveViews.ViewRow.CancelEdit" /> call,
            its state becomes <b>Detached</b>. Accessing it after that would throw an exception.
            </remarks>
    </member>
    <member name="F:C1.LiveLinq.LiveViews.ViewRowState.Unmodified">
      <summary>The row is a regular view row, not in edit mode and not deleted.</summary>
    </member>
    <member name="F:C1.LiveLinq.LiveViews.ViewRowState.Modified">
      <summary>
            The row is in edit mode (<see cref="M:C1.LiveLinq.LiveViews.ViewRow.BeginEdit" /> was called,
            neither <see cref="M:C1.LiveLinq.LiveViews.ViewRow.EndEdit" /> nor <see cref="M:C1.LiveLinq.LiveViews.ViewRow.CancelEdit" /> was called yet),
            and the row is not new (was not created by <see cref="M:C1.LiveLinq.LiveViews.ViewRowCollection.CreateRow" />).
            </summary>
    </member>
    <member name="F:C1.LiveLinq.LiveViews.ViewRowState.New">
      <summary>
            The row was added to the view directly (not by adding to a basic data collection)
            by calling <see cref="M:C1.LiveLinq.LiveViews.ViewRowCollection.CreateRow" /> or through data binding (such new row 
            enters edit mode once it is created) and still in edit mode
            (neither <see cref="M:C1.LiveLinq.LiveViews.ViewRow.EndEdit" /> nor <see cref="M:C1.LiveLinq.LiveViews.ViewRow.CancelEdit" /> was called yet).
            </summary>
    </member>
    <member name="F:C1.LiveLinq.LiveViews.ViewRowState.Detached">
      <summary>
            The row was deleted, or it is a new row after exiting edit mode.
            </summary>
    </member>
    <member name="T:C1.LiveLinq.LiveViews.Xml.XHint">
      <summary>
            The class used for the return type in the <see cref="M:C1.LiveLinq.LiveViews.Xml.XmlExtensions.IndexedElement(System.Xml.Linq.XContainer,System.Xml.Linq.XName)" /> and <see cref="M:C1.LiveLinq.LiveViews.Xml.XmlExtensions.IndexedAttribute(System.Xml.Linq.XElement,System.Xml.Linq.XName)" /> extension methods.
            </summary>
      <remarks>
            This class is not used in execution, because hints like <see cref="M:C1.LiveLinq.LiveViews.Xml.XmlExtensions.IndexedElement(System.Xml.Linq.XContainer,System.Xml.Linq.XName)" /> and <see cref="M:C1.LiveLinq.LiveViews.Xml.XmlExtensions.IndexedAttribute(System.Xml.Linq.XElement,System.Xml.Linq.XName)" />
            are never executed, they are used merely to convey information ('hint') to LiveLinq query optimizer, they are discarded
            before the query is executed. The only purpose of this class is to preserve syntactical correctness of the query.
            </remarks>
    </member>
    <member name="T:C1.LiveLinq.LiveViews.Xml.XmlExtensions">
      <summary>Provides a set of static (extension) methods for LiveLinq to XML.</summary>
    </member>
    <member name="M:C1.LiveLinq.LiveViews.Xml.XmlExtensions.Root(C1.LiveLinq.LiveViews.View{System.Xml.Linq.XDocument})">
      <summary>Gets the view for the root element of the XML tree for this document.</summary>
      <param name="documentView">The view representing this XML document.</param>
      <returns>A view containing a single element, the root of the XML tree.</returns>
    </member>
    <member name="M:C1.LiveLinq.LiveViews.Xml.XmlExtensions.Elements``1(C1.LiveLinq.LiveViews.View{``0})">
      <summary>
            Returns a view representing the collection of child elements of every element and document in the source view..
            </summary>
      <typeparam name="T">The type of the objects in the source <i>view</i>, constrained to <see cref="T:System.Xml.Linq.XContainer" />.</typeparam>
      <param name="view">The source view.</param>
      <returns>A view containing the child elements of every element and document in the source view.</returns>
    </member>
    <member name="M:C1.LiveLinq.LiveViews.Xml.XmlExtensions.Elements``1(C1.LiveLinq.LiveViews.View{``0},System.Xml.Linq.XName)">
      <summary>
            Returns a view representing filtered collection of child elements of every element and document in the source view.
            Only elements that have a matching <see cref="T:System.Xml.Linq.XName" /> are included.
            </summary>
      <typeparam name="T">The type of the objects in the source <i>view</i>, constrained to <see cref="T:System.Xml.Linq.XContainer" />.</typeparam>
      <param name="view">The source view.</param>
      <param name="name">The <see cref="T:System.Xml.Linq.XName" /> to match.</param>
      <returns>A view that contains a filtered collection of child elements of every element and document in the source view.
            Only elements that have a matching <see cref="T:System.Xml.Linq.XName" /> are included.</returns>
    </member>
    <member name="M:C1.LiveLinq.LiveViews.Xml.XmlExtensions.Attributes(C1.LiveLinq.LiveViews.View{System.Xml.Linq.XElement})">
      <summary>Returns a view representing the collection of the attributes of every element in the source view.</summary>
      <param name="view">The source view.</param>
      <returns>A view containing the attributes of every element in the source view.</returns>
    </member>
    <member name="M:C1.LiveLinq.LiveViews.Xml.XmlExtensions.Attributes(C1.LiveLinq.LiveViews.View{System.Xml.Linq.XElement},System.Xml.Linq.XName)">
      <summary>
            Returns a view representing a filtered collection of the attributes of every element in the source view.
            Only attributes that have a matching <see cref="T:System.Xml.Linq.XName" /> are included.
            </summary>
      <param name="view">The source view.</param>
      <param name="name">The <see cref="T:System.Xml.Linq.XName" /> to match.</param>
      <returns>A view that contains a filtered collection of the attributes of every element in the source view.
            Only attributes that have a matching <see cref="T:System.Xml.Linq.XName" /> are included.</returns>
    </member>
    <member name="M:C1.LiveLinq.LiveViews.Xml.XmlExtensions.Nodes``1(C1.LiveLinq.LiveViews.View{``0})">
      <summary>
            Returns a view representing the collection of child nodes of every document and element in the source view.
            </summary>
      <typeparam name="T">The type of the objects in the source <i>view</i>, constrained to <see cref="T:System.Xml.Linq.XContainer" />.</typeparam>
      <param name="view">The source view.</param>
      <returns>A view containing every child node of every document and element in the source view.</returns>
    </member>
    <member name="M:C1.LiveLinq.LiveViews.Xml.XmlExtensions.Descendants``1(C1.LiveLinq.LiveViews.View{``0})">
      <summary>
            Returns a view representing the collection of elements that contains the descendent elements of every
            element and document in the source view.
            </summary>
      <typeparam name="T">The type of the objects in the source <i>view</i>, constrained to <see cref="T:System.Xml.Linq.XContainer" />.</typeparam>
      <param name="view">The source view.</param>
      <returns>A view containing every descendent element of every element and document in the source view.</returns>
    </member>
    <member name="M:C1.LiveLinq.LiveViews.Xml.XmlExtensions.Descendants``1(C1.LiveLinq.LiveViews.View{``0},System.Xml.Linq.XName)">
      <summary>
            Returns a view representing a filtered collection of elements
            that contains the descendent elements of every element and document in the source view.
            Only elements that have a matching <see cref="T:System.Xml.Linq.XName" /> are included.
            </summary>
      <typeparam name="T">The type of the objects in the source <i>view</i>, constrained to <see cref="T:System.Xml.Linq.XContainer" />.</typeparam>
      <param name="view">The source view.</param>
      <param name="name">The <see cref="T:System.Xml.Linq.XName" /> to match.</param>
      <returns>A view containing descendants of elements and documents in the source view.
            Only elements that have a matching <see cref="T:System.Xml.Linq.XName" /> are included.</returns>
    </member>
    <member name="M:C1.LiveLinq.LiveViews.Xml.XmlExtensions.DescendantsAndSelf(C1.LiveLinq.LiveViews.View{System.Xml.Linq.XElement})">
      <summary>
            Returns a view representing a collection of elements that contains every element in the source view,
            and the descendent elements of every element in the source view.
            </summary>
      <param name="view">The source view.</param>
      <returns>A view containing every element in the source view, and the descendent elements of every element in the source view.</returns>
    </member>
    <member name="M:C1.LiveLinq.LiveViews.Xml.XmlExtensions.DescendantsAndSelf(C1.LiveLinq.LiveViews.View{System.Xml.Linq.XElement},System.Xml.Linq.XName)">
      <summary>
            Returns a view representing a filtered collection of elements that contains
            every element in the source view, and the descendants of every element in the source view.
            Only elements that have a matching <see cref="T:System.Xml.Linq.XName" /> are included.
            </summary>
      <param name="view">The source view.</param>
      <param name="name">The <see cref="T:System.Xml.Linq.XName" /> to match.</param>
      <returns>A view containing elements in the source view, and the descendants of elements in the source view.
            Only elements that have a matching <see cref="T:System.Xml.Linq.XName" /> are included.</returns>
    </member>
    <member name="M:C1.LiveLinq.LiveViews.Xml.XmlExtensions.DescendantNodes``1(C1.LiveLinq.LiveViews.View{``0})">
      <summary>Returns a view representing the collection of the descendent nodes of every element
            and document in the source view.</summary>
      <typeparam name="T">The type of the objects in the source <i>view</i>, constrained to <see cref="T:System.Xml.Linq.XContainer" />.</typeparam>
      <param name="view">The source view.</param>
      <returns>A view containing every descendent node of every document and element in the source view.</returns>
    </member>
    <member name="M:C1.LiveLinq.LiveViews.Xml.XmlExtensions.DescendantNodesAndSelf(C1.LiveLinq.LiveViews.View{System.Xml.Linq.XElement})">
      <summary>
            Returns a view representing the collection of nodes that contains every element in the source view,
            and the descendent nodes of every element in the source view.
            </summary>
      <param name="view">The source view.</param>
      <returns>A view containing every element in the source view, and the descendent nodes of every element in the source view.</returns>
    </member>
    <member name="M:C1.LiveLinq.LiveViews.Xml.XmlExtensions.AsLive(System.Xml.Linq.XDocument)">
      <summary>Creates a view based on the specified XML document.</summary>
      <param name="document"> The XML document to expose as a view.</param>
      <returns>A view representing the specified XML document.</returns>
      <remarks>
        <para>Since there can be only one root element in a document, the view based on a document (<c>document.AsLive()</c>) is 
            similar to the view based on its root element (<c>document.Root.AsLive()</c>).
            The difference is that the document view contains the document as its only item,
            and the root view contains the root as its only item. This difference is essential only when
            the root of the document is replaced with a different element (and so the whole XML tree changes), then
            the document view remains valid and shows the changed document contents, whereas the root view becomes
            disconnected from the document.</para>
        <para>
          <b>Note:</b> This view is owned by the <see cref="T:System.Xml.Linq.XDocument" /> object (it is stored as one of its annotations),
            so, if you create a view for the same document several times, it will be the same object.</para>
      </remarks>
    </member>
    <member name="M:C1.LiveLinq.LiveViews.Xml.XmlExtensions.AsLive(System.Xml.Linq.XElement)">
      <summary>Creates a view based on the specified XML element.</summary>
      <param name="element"> The XML element to expose as a view.</param>
      <returns>A view representing the specified XML element.</returns>
      <remarks>
        <para>This view represents a single XML node. Therefore, as a collection of items, this view's <b>Count</b> is always 1.
            This view is usually used as a starting point to construct a view containing elements or attributes 
            from this node's descendants by using a query with operators from <see cref="T:C1.LiveLinq.LiveViews.Xml.XmlExtensions" /> such as <b>Elements</b>,
            <b>Descendants</b> and others, in combination with standard LINQ query operators <b>where</b>, <b>join</b> and others.</para>
        <para>
          <b>Note:</b> This view is owned by the <see cref="T:System.Xml.Linq.XElement" /> object (it is stored as one of its annotations),
            so, if you create a view for the same element several times, it will be the same object.</para>
      </remarks>
    </member>
    <member name="M:C1.LiveLinq.LiveViews.Xml.XmlExtensions.IndexedAttribute(System.Xml.Linq.XElement,System.Xml.Linq.XName)">
      <summary>A hint to create and use an index on the specified XML attribute. The hint has default action.</summary>
      <param name="element">The element containing the attribute.</param>
      <param name="name">The name of the attribute to get.</param>
      <returns>The attribute that has the specified name.</returns>
      <remarks>
            Hints are used declaratively. They tell LiveLinq query optimizer to create and use an index on this attribute, if possible.
            When the query is executed, the hint method <b>IndexedAttribute</b> is replaced with the standard LINQ to XML method
            <see cref="M:System.Xml.Linq.XElement.Attribute(System.Xml.Linq.XName)" />. See <see cref="T:C1.LiveLinq.Hints" /> for more details.
            </remarks>
      <example>
        <code>
            var query =
                from c in customers
                where (string)c.IndexedAttribute("CustomerID") == "ALFKI"
                select c;
            </code>
      </example>
    </member>
    <member name="M:C1.LiveLinq.LiveViews.Xml.XmlExtensions.IndexedElement(System.Xml.Linq.XContainer,System.Xml.Linq.XName)">
      <summary>A hint to create and use an index on the specified XML element. The hint has default action.</summary>
      <param name="container">The element or document containing the element.</param>
      <param name="name">The name of the element to get.</param>
      <returns>The element that has the specified name.</returns>
      <remarks>
            Hints are used declaratively. They tell LiveLinq query optimizer to create and use an index on this element, if possible.
            When the query is executed, the hint method <b>IndexedElement</b> is replaced with the standard LINQ to XML method
            <see cref="M:System.Xml.Linq.XContainer.Element(System.Xml.Linq.XName)" />. See <see cref="T:C1.LiveLinq.Hints" /> for more details.
            </remarks>
      <example>
        <code>
            var query =
                from c in customers
                where (string)c.IndexedElement("CustomerID") == "ALFKI"
                select c;
            </code>
      </example>
    </member>
    <member name="M:C1.LiveLinq.LiveViews.Xml.XmlExtensions.IndexedElement(System.Xml.Linq.XElement)">
      <summary>A hint to create and use an index on the specified XML element. The hint has default action.</summary>
      <param name="element">The element to apply the hint to.</param>
      <returns>Formally, the hint returns the same value that it receives in the parameter. In fact, it is never executed,
            its role is purely declarative.</returns>
      <remarks>
            Hints are used declaratively. They tell LiveLinq query optimizer to create and use an index on this element, if possible.
            After it is used for query optimization, before the query is executed, this hint is removed from the expression.
            See <see cref="T:C1.LiveLinq.Hints" /> for more details.
            </remarks>
      <example>
        <code>
            var query =
                from c in customers
                where (string)c.Element("CustomerID").IndexedElement() == "ALFKI"
                select c;
            </code>
      </example>
    </member>
    <member name="M:C1.LiveLinq.LiveViews.Xml.XmlExtensions.IndexedAttribute(System.Xml.Linq.XAttribute)">
      <summary>A hint to create and use an index on the specified XML attribute. The hint has default action.</summary>
      <param name="attribute">The attribute to apply the hint to.</param>
      <returns>Formally, the hint returns the same value that it receives in the parameter. In fact, it is never executed,
            its role is purely declarative.</returns>
      <remarks>
            Hints are used declaratively. They tell LiveLinq query optimizer to create and use an index on this attribute, if possible.
            After it is used for query optimization, before the query is executed, this hint is removed from the expression.
            See <see cref="T:C1.LiveLinq.Hints" /> for more details.
            </remarks>
      <example>
        <code>
            var query =
                from c in customers
                where (string)c.Attribute("CustomerID").IndexedAttribute() == "ALFKI"
                select c;
            </code>
      </example>
    </member>
    <member name="M:C1.LiveLinq.LiveViews.Xml.XmlExtensions.IndexedAttribute(System.Xml.Linq.XAttribute,C1.LiveLinq.IndexingHintAction)">
      <summary>A hint to create and use an index on the specified XML attribute. The hint has specified action.</summary>
      <param name="attribute">The attribute to apply the hint to.</param>
      <param name="action">The action specified by the hint.</param>
      <returns>Formally, the hint returns the same value that it receives in the parameter. In fact, it is never executed,
            its role is purely declarative.</returns>
      <remarks>
            Hints are used declaratively. They tell LiveLinq query optimizer to create and use an index on this attribute, if possible.
            After it is used for query optimization, before the query is executed, this hint is removed from the expression.
            See <see cref="T:C1.LiveLinq.Hints" /> for more details.
            </remarks>
      <example>
        <code>
            var query =
                from c in customers
                where (string)c.Attribute("CustomerID").IndexedAttribute(IndexingHintAction.Mandatory) == "ALFKI"
                select c;
            </code>
      </example>
    </member>
    <member name="M:C1.LiveLinq.LiveViews.Xml.XmlExtensions.IndexedAttribute(System.Xml.Linq.XElement,System.Xml.Linq.XName,C1.LiveLinq.IndexingHintAction)">
      <summary>A hint to create and use an index on the specified XML attribute. The hint has specified action.</summary>
      <param name="element">The element containing the attribute.</param>
      <param name="name">The name of the attribute to get.</param>
      <param name="action">The action specified by the hint.</param>
      <returns>The attribute that has the specified name.</returns>
      <remarks>
            Hints are used declaratively. They tell LiveLinq query optimizer to create and use an index on this attribute, if possible.
            When the query is executed, the hint method <b>IndexedAttribute</b> is replaced with the standard LINQ to XML method
            <see cref="M:System.Xml.Linq.XElement.Attribute(System.Xml.Linq.XName)" />. See <see cref="T:C1.LiveLinq.Hints" /> for more details.
            </remarks>
      <example>
        <code>
            var query =
                from c in customers
                where (string)c.IndexedAttribute("CustomerID", IndexingHintAction.Mandatory) == "ALFKI"
                select c;
            </code>
      </example>
    </member>
    <member name="M:C1.LiveLinq.LiveViews.Xml.XmlExtensions.IndexedElement(System.Xml.Linq.XElement,C1.LiveLinq.IndexingHintAction)">
      <summary>A hint to create and use an index on the specified XML element. The hint has specified action.</summary>
      <param name="element">The element to apply the hint to.</param>
      <param name="action">The action specified by the hint.</param>
      <returns>Formally, the hint returns the same value that it receives in the parameter. In fact, it is never executed,
            its role is purely declarative.</returns>
      <remarks>
            Hints are used declaratively. They tell LiveLinq query optimizer to create and use an index on this element, if possible.
            After it is used for query optimization, before the query is executed, this hint is removed from the expression.
            See <see cref="T:C1.LiveLinq.Hints" /> for more details.
            </remarks>
      <example>
        <code>
            var query =
                from c in customers
                where (string)c.Element("CustomerID").IndexedElement(IndexingHintAction.Mandatory) == "ALFKI"
                select c;
            </code>
      </example>
    </member>
    <member name="M:C1.LiveLinq.LiveViews.Xml.XmlExtensions.IndexedElement(System.Xml.Linq.XContainer,System.Xml.Linq.XName,C1.LiveLinq.IndexingHintAction)">
      <summary>A hint to create and use an index on the specified XML element. The hint has specified action.</summary>
      <param name="container">The element or document containing the element.</param>
      <param name="name">The name of the element to get.</param>
      <param name="action">The action specified by the hint.</param>
      <returns>The element that has the specified name.</returns>
      <remarks>
            Hints are used declaratively. They tell LiveLinq query optimizer to create and use an index on this element, if possible.
            When the query is executed, the hint method <b>IndexedElement</b> is replaced with the standard LINQ to XML method
            <see cref="M:System.Xml.Linq.XContainer.Element(System.Xml.Linq.XName)" />. See <see cref="T:C1.LiveLinq.Hints" /> for more details.
            </remarks>
      <example>
        <code>
            var query =
                from c in customers
                where (string)c.IndexedElement("CustomerID", IndexingHintAction.Mandatory) == "ALFKI"
                select c;
            </code>
      </example>
    </member>
    <member name="M:C1.LiveLinq.LiveViews.Xml.XmlExtensions.BeginUpdate(System.Xml.Linq.XContainer)">
      <summary>Suspends notifications while massive changes are being made to an XML node and its descendants.</summary>
      <param name="node">The node that is the root of a tree where massive changes are made in code.</param>
      <remarks>
        <para>This method must be followed by <see cref="M:C1.LiveLinq.LiveViews.Xml.XmlExtensions.EndUpdate(System.Xml.Linq.XContainer)" />.</para>
        <para>Use this method when you already have indexes over this XML or live views based on it,
            and you need to perform massive changes on the contents of this node and its descendants.
            Without this method, every single change you make causes LiveLinq to perform necessary operations
            for maintaining your indexes and live views dependent on this node and its descendants. In case of massive changes,
            this can be slower than to wait until the massive changes are done and rebuild the indexes and live views.</para>
        <para> Between <b>BeginUpdate</b> and <see cref="M:C1.LiveLinq.LiveViews.Xml.XmlExtensions.EndUpdate(System.Xml.Linq.XContainer)" /> calls, indexes, live views, bound controls
            and other change notification listeners are not updated, they don't receive change notifications.
            When <see cref="M:C1.LiveLinq.LiveViews.Xml.XmlExtensions.EndUpdate(System.Xml.Linq.XContainer)" /> is called, a <see cref="T:C1.LiveLinq.SourceChangeType">SourceChangeType.Reset</see>
            notification is sent, meaning all indexes, live views and other collections dependent on this node and its descendants
            must be rebuilt from scratch.</para>
      </remarks>
    </member>
    <member name="M:C1.LiveLinq.LiveViews.Xml.XmlExtensions.EndUpdate(System.Xml.Linq.XContainer)">
      <summary>Ends notification suspension started with <see cref="M:C1.LiveLinq.LiveViews.Xml.XmlExtensions.BeginUpdate(System.Xml.Linq.XContainer)" />.</summary>
      <param name="node">The node that is the root of a tree where massive changes have been made since the <see cref="M:C1.LiveLinq.LiveViews.Xml.XmlExtensions.BeginUpdate(System.Xml.Linq.XContainer)" /> call.</param>
    </member>
    <member name="T:C1.LiveLinq.LiveViews.ViewRowPropertyInfo">
      <summary>
            Allows to control certain behavior of a property of the element type of a <see cref="T:C1.LiveLinq.LiveViews.View" />.
            </summary>
    </member>
    <member name="P:C1.LiveLinq.LiveViews.ViewRowPropertyInfo.PropertyName">
      <summary>
            Gets the name of the property.
            </summary>
    </member>
    <member name="P:C1.LiveLinq.LiveViews.ViewRowPropertyInfo.ImmediateUpdate">
      <summary>
            Gets or sets a boolean value indicating whether changes made to this property through data binding 
            must be immediately sent to the corresponding view item 
            even if the view in editing mode.
            <seealso cref="M:C1.LiveLinq.LiveViews.ViewRow.BeginEdit" /></summary>
    </member>
    <member name="T:C1.LiveLinq.CompiledQuery">
      <summary>Provides for compilation and cache of queries for reuse.</summary>
      <remarks>
            If you need to execute the same query many times, each time with different parameter values,
            use the <b>CompiledQuery</b> class to improve performance. Without it, every query execution includes a compilation stage,
            that does not take much time but that time can accumulate to significant numbers if it is repeated many times.
            The <b>CompiledQuery</b> class contains a single <b>Compile</b> method with several overloads.
            Call the <b>Compile</b> method to create a delegate to represent the compiled query.
            </remarks>
    </member>
    <member name="M:C1.LiveLinq.CompiledQuery.Compile``5(System.Linq.Expressions.Expression{System.Func{``0,``1,``2,``3,C1.LiveLinq.Indexing.IIndexedSource{``4}}})">
      <summary>Compiles the query.</summary>
      <typeparam name="T1">The type of the first parameter that has to be passed in when executing the delegate returned by the Compile method.</typeparam>
      <typeparam name="T2">The type of the second parameter that has to be passed in when executing the delegate returned by the Compile method.</typeparam>
      <typeparam name="T3">The type of the third parameter that has to be passed in when executing the delegate returned by the Compile method.</typeparam>
      <typeparam name="T4">The type of the fourth parameter that has to be passed in when executing the delegate returned by the Compile method.</typeparam>
      <typeparam name="TResult">The type of <b>TResult</b> in the <see cref="T:C1.LiveLinq.Indexing.IIndexedSource`1">IIndexedSource&lt;TResult&gt;</see> returned when executing the delegate returned by the Compile method.</typeparam>
      <param name="query">The query expression to be compiled.</param>
      <returns>The delegate to be called to execute the compiled query with particular parameter values.</returns>
    </member>
    <member name="M:C1.LiveLinq.CompiledQuery.Compile``4(System.Linq.Expressions.Expression{System.Func{``0,``1,``2,C1.LiveLinq.Indexing.IIndexedSource{``3}}})">
      <summary>Compiles the query.</summary>
      <typeparam name="T1">The type of the first parameter that has to be passed in when executing the delegate returned by the Compile method.</typeparam>
      <typeparam name="T2">The type of the second parameter that has to be passed in when executing the delegate returned by the Compile method.</typeparam>
      <typeparam name="T3">The type of the third parameter that has to be passed in when executing the delegate returned by the Compile method.</typeparam>
      <typeparam name="TResult">The type of <b>TResult</b> in the <see cref="T:C1.LiveLinq.Indexing.IIndexedSource`1">IIndexedSource&lt;TResult&gt;</see> returned when executing the delegate returned by the Compile method.</typeparam>
      <param name="query">The query expression to be compiled.</param>
      <returns>The delegate to be called to execute the compiled query with particular parameter values.</returns>
    </member>
    <member name="M:C1.LiveLinq.CompiledQuery.Compile``3(System.Linq.Expressions.Expression{System.Func{``0,``1,C1.LiveLinq.Indexing.IIndexedSource{``2}}})">
      <summary>Compiles the query.</summary>
      <typeparam name="T1">The type of the first parameter that has to be passed in when executing the delegate returned by the Compile method.</typeparam>
      <typeparam name="T2">The type of the second parameter that has to be passed in when executing the delegate returned by the Compile method.</typeparam>
      <typeparam name="TResult">The type of <b>TResult</b> in the <see cref="T:C1.LiveLinq.Indexing.IIndexedSource`1">IIndexedSource&lt;TResult&gt;</see> returned when executing the delegate returned by the Compile method.</typeparam>
      <param name="query">The query expression to be compiled.</param>
      <returns>The delegate to be called to execute the compiled query with particular parameter values.</returns>
    </member>
    <member name="M:C1.LiveLinq.CompiledQuery.Compile``2(System.Linq.Expressions.Expression{System.Func{``0,C1.LiveLinq.Indexing.IIndexedSource{``1}}})">
      <summary>Compiles the query.</summary>
      <typeparam name="T">The type of the parameter that has to be passed in when executing the delegate returned by the Compile method.</typeparam>
      <typeparam name="TResult">The type of <b>TResult</b> in the <see cref="T:C1.LiveLinq.Indexing.IIndexedSource`1">IIndexedSource&lt;TResult&gt;</see> returned when executing the delegate returned by the Compile method.</typeparam>
      <param name="query">The query expression to be compiled.</param>
      <returns>The delegate to be called to execute the compiled query with particular parameter values.</returns>
    </member>
    <member name="T:C1.LiveLinq.AdoNet.AdoNetExtensions">
      <summary>Provides a set of static (extension) methods for LiveLinq to DataSet.</summary>
    </member>
    <member name="M:C1.LiveLinq.AdoNet.AdoNetExtensions.AsIndexed(System.Data.DataTable)">
      <summary>
            Wraps a <see cref="T:System.Data.DataTable" /> in an <see cref="T:C1.LiveLinq.AdoNet.IndexedDataTable`1">IndexedDataTable&lt;DataRow&gt;</see> so it can be indexed and
            queried using the optimized query operators from <see cref="T:C1.LiveLinq.IndexedQueryExtensions" />.
            </summary>
      <param name="table">A <see cref="T:System.Data.DataTable" /> to represent as an <see cref="T:C1.LiveLinq.AdoNet.IndexedDataTable`1">IndexedDataTable&lt;DataRow&gt;</see>.</param>
      <returns>An <see cref="T:C1.LiveLinq.AdoNet.IndexedDataTable`1">IndexedDataTable&lt;DataRow&gt;</see> that contains the same rows as <i>table</i>
            and enables indexing of its rows.</returns>
      <remarks>
        <para>Use this method to index ADO.NET data tables and query them using the query operators optimized with indexing.</para>
        <para>Elements of the source data table aren't duplicated or copied to a new collection.
            This method just wraps the original data table in an <see cref="T:C1.LiveLinq.AdoNet.IndexedDataTable`1">IndexedDataTable&lt;DataRow&gt;</see>.</para>
        <b>Note:</b> The <see cref="T:C1.LiveLinq.AdoNet.IndexedDataTable`1">IndexedDataTable&lt;DataRow&gt;</see> wrapper is owned by the original <see cref="T:System.Data.DataTable" /> object
            (in fact, it is stored in its <b>ExtendedProperties</b>). So, if you create a wrapper for the same data table several times,
            it will be the same object.
            </remarks>
    </member>
    <member name="M:C1.LiveLinq.AdoNet.AdoNetExtensions.AsIndexed``1(System.Data.DataTable)">
      <summary>
            Wraps a <see cref="T:System.Data.DataTable" /> in an <see cref="T:C1.LiveLinq.AdoNet.IndexedDataTable`1" /> so it can be indexed and
            queried using the optimized query operators from <see cref="T:C1.LiveLinq.IndexedQueryExtensions" />.
            </summary>
      <typeparam name="TRow">The type of the rows in the <i>table</i>.</typeparam>
      <param name="table">A <see cref="T:System.Data.DataTable" /> to represent as an <see cref="T:C1.LiveLinq.AdoNet.IndexedDataTable`1" />.</param>
      <returns>An <see cref="T:C1.LiveLinq.AdoNet.IndexedDataTable`1" /> that contains the same rows as <i>table</i>
            and enables indexing of its rows.</returns>
      <remarks>
        <para>Use this method to index ADO.NET data tables and query them using the query operators optimized with indexing.</para>
        <para>Elements of the source data table aren't duplicated or copied to a new collection.
            This method just wraps the original data table in an <see cref="T:C1.LiveLinq.AdoNet.IndexedDataTable`1" />.</para>
        <b>Note:</b> The <see cref="T:C1.LiveLinq.AdoNet.IndexedDataTable`1" /> wrapper is owned by the original <see cref="T:System.Data.DataTable" /> object
            (in fact, it is stored in its <b>ExtendedProperties</b>). So, if you create a wrapper for the same data table several times,
            it will be the same object.
            </remarks>
    </member>
    <member name="M:C1.LiveLinq.AdoNet.AdoNetExtensions.AsIndexed``1(System.Data.TypedTableBase{``0})">
      <summary>
            Wraps a typed ADO.NET data table in an <see cref="T:C1.LiveLinq.AdoNet.IndexedDataTable`1" /> so it can be indexed and
            queried using the optimized query operators from <see cref="T:C1.LiveLinq.IndexedQueryExtensions" />.
            </summary>
      <typeparam name="TRow">The type of the rows in the <i>table</i>.</typeparam>
      <param name="table">A typed data table to represent as an <see cref="T:C1.LiveLinq.AdoNet.IndexedDataTable`1" />.</param>
      <returns>An <see cref="T:C1.LiveLinq.AdoNet.IndexedDataTable`1" /> that contains the same rows as <i>table</i>
            and enables indexing of its rows.</returns>
      <remarks>
        <para>Use this method to index typed data tables and query them using the query operators optimized with indexing.</para>
        <para>Elements of the source data table aren't duplicated or copied to a new collection.
            This method just wraps the original data table in an <see cref="T:C1.LiveLinq.AdoNet.IndexedDataTable`1" />.</para>
        <b>Note:</b> The <see cref="T:C1.LiveLinq.AdoNet.IndexedDataTable`1" /> wrapper is owned by the original <see cref="T:System.Data.DataTable" /> object
            (in fact, it is stored in its <b>ExtendedProperties</b>). So, if you create a wrapper for the same data table several times,
            it will be the same object.
            </remarks>
    </member>
    <member name="M:C1.LiveLinq.AdoNet.AdoNetExtensions.AsLive(System.Data.DataTable)">
      <summary>Creates a view based on the specified ADO.NET <see cref="T:System.Data.DataTable" />.</summary>
      <param name="table">The <see cref="T:System.Data.DataTable" /> to expose as a view.</param>
      <returns>A view that contains the same elements as <i>table</i>.</returns>
    </member>
    <member name="M:C1.LiveLinq.AdoNet.AdoNetExtensions.AsLive``1(System.Data.DataTable)">
      <summary>Creates a view based on the specified ADO.NET <see cref="T:System.Data.DataTable" />.</summary>
      <typeparam name="TRow">The type of the rows in the <i>table</i>.</typeparam>
      <param name="table">The typed data table to expose as a view.</param>
      <returns>A view that contains the same elements as <i>table</i>.</returns>
    </member>
    <member name="M:C1.LiveLinq.AdoNet.AdoNetExtensions.AsLive``1(System.Data.TypedTableBase{``0})">
      <summary>Creates a view based on the specified typed data table.</summary>
      <param name="table">The typed data table to expose as a view.</param>
      <typeparam name="TRow">The type of the rows in the <i>table</i>.</typeparam>
      <returns>A view that contains the same elements as <i>table</i>.</returns>
    </member>
    <member name="M:C1.LiveLinq.AdoNet.AdoNetExtensions.IndexedField``1(System.Data.DataRow,System.Int32)">
      <summary>A hint to create and use an index on the specified data column. The hint has default action.</summary>
      <typeparam name="T">The type of the data column</typeparam>
      <param name="row">The data row.</param>
      <param name="columnIndex">The zero-based ordinal position of the column.</param>
      <returns>The data column value.</returns>
      <remarks>
            Hints are used declaratively. They tell LiveLinq query optimizer to create and use an index on that column, if possible.
            When the query is executed, the hint method <b>IndexedField</b> is replaced with the standard LINQ to DataSet extension method
            <see cref="M:System.Data.DataRowExtensions.Field``1(System.Data.DataRow,System.String)">Field</see>. See <see cref="T:C1.LiveLinq.Hints" /> for more details.
            </remarks>
      <example>
        <code>
            var query = from c in customersTable
                where c.IndexedField&lt;string&gt;(0) == "ALFKI"
                select c;
            </code>
      </example>
    </member>
    <member name="M:C1.LiveLinq.AdoNet.AdoNetExtensions.IndexedField``1(System.Data.DataRow,System.Data.DataColumn)">
      <summary>A hint to create and use an index on the specified data column. The hint has default action.</summary>
      <typeparam name="T">The type of the data column</typeparam>
      <param name="row">The data row.</param>
      <param name="column">The data column.</param>
      <returns>The data column value.</returns>
      <remarks>
            Hints are used declaratively. They tell LiveLinq query optimizer to create and use an index on that column, if possible.
            When the query is executed, the hint method <b>IndexedField</b> is replaced with the standard LINQ to DataSet extension method
            <see cref="M:System.Data.DataRowExtensions.Field``1(System.Data.DataRow,System.String)">Field</see>. See <see cref="T:C1.LiveLinq.Hints" /> for more details.
            </remarks>
      <example>
        <code>
            var query = from c in customersTable
                where c.IndexedField&lt;string&gt;(customerColumn) == "ALFKI"
                select c;
            </code>
      </example>
    </member>
    <member name="M:C1.LiveLinq.AdoNet.AdoNetExtensions.IndexedField``1(System.Data.DataRow,System.String)">
      <summary>A hint to create and use an index on the specified data column. The hint has default action.</summary>
      <typeparam name="T">The type of the data column</typeparam>
      <param name="row">The data row.</param>
      <param name="columnName">The name of the column.</param>
      <returns>The data column value.</returns>
      <remarks>
            Hints are used declaratively. They tell LiveLinq query optimizer to create and use an index on that column, if possible.
            When the query is executed, the hint method <b>IndexedField</b> is replaced with the standard LINQ to DataSet extension method
            <see cref="M:System.Data.DataRowExtensions.Field``1(System.Data.DataRow,System.String)">Field</see>. See <see cref="T:C1.LiveLinq.Hints" /> for more details.
            </remarks>
      <example>
        <code>
            var query = from c in customersTable
                where c.IndexedField&lt;string&gt;("CustomerID") == "ALFKI"
                select c;
            </code>
      </example>
    </member>
    <member name="M:C1.LiveLinq.AdoNet.AdoNetExtensions.IndexedField``1(System.Data.DataRow,System.Int32,C1.LiveLinq.IndexingHintAction)">
      <summary>A hint to create and use an index on the specified data column. The hint has specified action.</summary>
      <typeparam name="T">The type of the data column</typeparam>
      <param name="row">The data row.</param>
      <param name="columnIndex">The zero-based ordinal position of the column.</param>
      <param name="action">The action specified by the hint.</param>
      <returns>The data column value.</returns>
      <remarks>
            Hints are used declaratively. They tell LiveLinq query optimizer to create and use an index on that column, if possible.
            When the query is executed, the hint method <b>IndexedField</b> is replaced with the standard LINQ to DataSet extension method
            <see cref="M:System.Data.DataRowExtensions.Field``1(System.Data.DataRow,System.String)">Field</see>. See <see cref="T:C1.LiveLinq.Hints" /> for more details.
            </remarks>
      <example>
        <code>
            var query = from c in customersTable
                where c.IndexedField&lt;string&gt;(0, IndexingHintAction.Mandatory) == "ALFKI"
                select c;
            </code>
      </example>
    </member>
    <member name="M:C1.LiveLinq.AdoNet.AdoNetExtensions.IndexedField``1(System.Data.DataRow,System.Data.DataColumn,C1.LiveLinq.IndexingHintAction)">
      <summary>A hint to create and use an index on the specified data column. The hint has specified action.</summary>
      <typeparam name="T">The type of the data column</typeparam>
      <param name="row">The data row.</param>
      <param name="column">The data column.</param>
      <param name="action">The action specified by the hint.</param>
      <returns>The data column value.</returns>
      <remarks>
            Hints are used declaratively. They tell LiveLinq query optimizer to create and use an index on that column, if possible.
            When the query is executed, the hint method <b>IndexedField</b> is replaced with the standard LINQ to DataSet extension method
            <see cref="M:System.Data.DataRowExtensions.Field``1(System.Data.DataRow,System.String)">Field</see>. See <see cref="T:C1.LiveLinq.Hints" /> for more details.
            </remarks>
      <example>
        <code>
            var query =
                from c in customersTable
                where c.IndexedField&lt;string&gt;(customerColumn, IndexingHintAction.Mandatory) == "ALFKI"
                select c;
            </code>
      </example>
    </member>
    <member name="M:C1.LiveLinq.AdoNet.AdoNetExtensions.IndexedField``1(System.Data.DataRow,System.String,C1.LiveLinq.IndexingHintAction)">
      <summary>A hint to create and use an index on the specified data column. The hint has specified action.</summary>
      <typeparam name="T">The type of the data column</typeparam>
      <param name="row">The data row.</param>
      <param name="columnName">The name of the column.</param>
      <param name="action">The action specified by the hint.</param>
      <returns>The data column value.</returns>
      <remarks>
            Hints are used declaratively. They tell LiveLinq query optimizer to create and use an index on that column, if possible.
            When the query is executed, the hint method <b>IndexedField</b> is replaced with the standard LINQ to DataSet extension method
            <see cref="M:System.Data.DataRowExtensions.Field``1(System.Data.DataRow,System.String)">Field</see>. See <see cref="T:C1.LiveLinq.Hints" /> for more details.
            </remarks>
      <example>
        <code>
            var query =
                from c in customersTable
                where c.IndexedField&lt;string&gt;("CustomerID", IndexingHintAction.Mandatory) == "ALFKI"
                select c;
            </code>
      </example>
    </member>
    <member name="M:C1.LiveLinq.AdoNet.AdoNetExtensions.BeginUpdate(System.Data.DataSet)">
      <summary>
            Indicates that massive changes are being made in code,
            until <see cref="M:C1.LiveLinq.AdoNet.AdoNetExtensions.EndUpdate(System.Data.DataSet)" />, to data tables in this <see cref="T:System.Data.DataSet" />.
            </summary>
      <param name="dataSet">The <see cref="T:System.Data.DataSet" /> to start massive changes for.</param>
      <remarks> 
            This extension method calls <see cref="M:C1.LiveLinq.AdoNet.IndexedDataTable`1.BeginUpdate" /> for all data tables of this <see cref="T:System.Data.DataSet" />.
            </remarks>
    </member>
    <member name="M:C1.LiveLinq.AdoNet.AdoNetExtensions.EndUpdate(System.Data.DataSet)">
      <summary>
            Indicates the end of massive changes to data tables in this <see cref="T:System.Data.DataSet" />
            started with <see cref="M:C1.LiveLinq.AdoNet.AdoNetExtensions.BeginUpdate(System.Data.DataSet)" />.
            </summary>
      <param name="dataSet">The <see cref="T:System.Data.DataSet" /> where massive changes have ended.</param>
      <remarks> 
            This extension method calls <see cref="M:C1.LiveLinq.AdoNet.IndexedDataTable`1.EndUpdate" /> for all data tables of this <see cref="T:System.Data.DataSet" />.
            </remarks>
    </member>
    <member name="T:C1.LiveLinq.AdoNet.IndexedDataTable`1">
      <summary>
            A wrapper for the standard ADO.NET <see cref="T:System.Data.DataTable" /> class allowing to use ADO.NET data sources in LiveLinq indexing and live views.
            </summary>
      <typeparam name="TRow">The type of the rows of the <see cref="T:System.Data.DataTable" />. It is a class derived from <see cref="T:System.Data.DataRow" /></typeparam>
      <remarks>
        <b>Note:</b> The <b>IndexedDataTable</b> wrapper is owned by the original <see cref="T:System.Data.DataTable" /> object
            (in fact, it is stored in its <b>ExtendedProperties</b>). So, if you create a wrapper for the same data table several times,
            it will be the same object.
            </remarks>
    </member>
    <member name="M:C1.LiveLinq.AdoNet.IndexedDataTable`1.GetEnumerator">
      <summary>Returns an enumerator that iterates through the <see cref="T:C1.LiveLinq.AdoNet.IndexedDataTable`1" />.</summary>
    </member>
    <member name="M:C1.LiveLinq.AdoNet.IndexedDataTable`1.BeginUpdate">
      <summary>Suspends notifications while massive changes are being made to a data table.</summary>
      <remarks>
        <para>This method must be followed by <see cref="M:C1.LiveLinq.AdoNet.IndexedDataTable`1.EndUpdate" />.</para>
        <para>Use this method when you already have indexes built over a data table or live views based on that data table,
            and you need to re-populate it or perform other massive changes to rows of that data table.
            Without this method, every single change you make causes LiveLinq to perform necessary operations
            for maintaining your indexes and live views dependent on this data table. In case of massive changes,
            this can be slower than to wait until the massive changes are done and rebuild the indexes and live views.</para>
        <para> Between <b>BeginUpdate</b> and <see cref="M:C1.LiveLinq.AdoNet.IndexedDataTable`1.EndUpdate" /> calls, indexes, live views, bound controls
            and other change notification listeners are not updated, they don't receive change notifications.</para>
        <para>When <see cref="M:C1.LiveLinq.AdoNet.IndexedDataTable`1.EndUpdate" /> is called, a 
            <see cref="T:C1.LiveLinq.SourceChangeType">SourceChangeType.Modify</see> or <see cref="T:C1.LiveLinq.SourceChangeType">SourceChangeType.Reset</see>
            notification is sent, depending on whether the change affected a single row or multiple rows of the data table.
            Even when you change a single row, it may make sense to enclose your changes in <b>BeginUpdate/EndUpdate</b> if
            you change multiple fields in the row. In that case a <see cref="T:C1.LiveLinq.SourceChangeType">SourceChangeType.Modify</see>
            notification is sent. If more than one row was changed, a <see cref="T:C1.LiveLinq.SourceChangeType">SourceChangeType.Reset</see>
            notification is sent, meaning all indexes, live views and other collections dependent on this data table
            must be rebuilt from scratch.</para>
      </remarks>
    </member>
    <member name="M:C1.LiveLinq.AdoNet.IndexedDataTable`1.EndUpdate">
      <summary>Ends notification suspension started with <see cref="M:C1.LiveLinq.AdoNet.IndexedDataTable`1.BeginUpdate" />.</summary>
    </member>
    <member name="P:C1.LiveLinq.AdoNet.IndexedDataTable`1.Table">
      <summary>Gets the ADO.NET <see cref="T:System.Data.DataTable" /> object represented by this <see cref="T:C1.LiveLinq.AdoNet.IndexedDataTable`1" />.</summary>
    </member>
    <member name="P:C1.LiveLinq.AdoNet.IndexedDataTable`1.Indexes">
      <summary>The collection of indexes for this <see cref="T:C1.LiveLinq.AdoNet.IndexedDataTable`1" /></summary>
    </member>
    <member name="P:C1.LiveLinq.AdoNet.IndexedDataTable`1.Count">
      <summary>Gets the number of rows in the data table.</summary>
      <remarks>
            This property returns the same number of rows as the <b>Count</b> property
            of the <see cref="T:System.Data.DataTable" /> represented by this <see cref="T:C1.LiveLinq.AdoNet.IndexedDataTable`1" /></remarks>
    </member>
    <member name="P:C1.LiveLinq.AdoNet.IndexedDataTable`1.Item(System.Int32)">
      <summary>Gets the row at the specified ordinal position.</summary>
      <param name="ordinal">The zero-based ordinal position of the row to return.</param>
      <returns>The specified row.</returns>
      <remarks>
            This property returns the same row as <b>Rows[ordinal]</b> of the
            <see cref="T:System.Data.DataTable" /> represented by this <see cref="T:C1.LiveLinq.AdoNet.IndexedDataTable`1" />.
            </remarks>
    </member>
    <member name="T:C1.LiveLinq.DeletedStateIsAvailableAttribute">
      <summary>
            Indicates that the properties of an object of a class still return 
            correct property values after the object has been deleted from the collection it belonged to.
            </summary>
      <remarks>
            This attribute is used with classes of elements of <see cref="T:C1.LiveLinq.Collections.IndexedCollection`1" /> and other collections implementing <see cref="T:C1.LiveLinq.IObservableSource`1" />.
            It gives you a way of changing the value of <see cref="P:C1.LiveLinq.IObservableSource`1.IsDeletedStateAvailable" /> without
            having to create a full-blown custom implementation of the <see cref="T:C1.LiveLinq.IObservableSource`1" /> interface.
            </remarks>
    </member>
    <member name="M:C1.LiveLinq.DeletedStateIsAvailableAttribute.#ctor(System.Boolean)">
      <summary>
            Initializes a new instance of the <see cref="T:C1.LiveLinq.DeletedStateIsAvailableAttribute" /> class.
            </summary>
      <param name="isAvailable">
        <b>true</b> if the properties of an object of the class still return 
            correct property values after the object has been deleted from the collection it belonged to.</param>
    </member>
    <member name="P:C1.LiveLinq.DeletedStateIsAvailableAttribute.IsAvailable">
      <summary>
        <b>true</b> if the properties of an object of the class still return 
            correct property values after the object has been deleted from the collection it belonged to.
            </summary>
    </member>
    <member name="T:C1.LiveLinq.Hints">
      <summary>
            Provides a static (extension) method used as a hint that can be applied to an expression (usually, a property) in a query.
            </summary>
      <remarks>
        <para>A hint does not change the value of the expression it is applied to,
            it only tells LiveLinq to create and use an index on that property, if possible.</para>
        <para>
          <b>Note: </b>Hints can only be used in indexed queries (with <b>AsIndexed()</b> extension method).
            Using them in live views (with <b>AsLive()</b> extension method) will result in an exception.</para>
            See <span style="C1H Jump">How to create indexes</span>.
            </remarks>
    </member>
    <member name="M:C1.LiveLinq.Hints.Indexed``1(``0,C1.LiveLinq.IndexingHintAction)">
      <summary>
            A hint with specified action.
            </summary>
      <typeparam name="T">This can be any type, because hints are applicable to expressions of any type.</typeparam>
      <param name="value">The value of the expression the hint is applied to. This value is not actually used by the hint,
            because the hint is never executed, its role is purely declarative.</param>
      <param name="action">The action specified by the hint.</param>
      <returns>Formally, the hint returns the same value that it receives in the parameter. In fact, it is never executed,
            its role is purely declarative.</returns>
      <remarks>
        <para>A hint does not change the value of the expression it is applied to.
            It only tells LiveLinq query optimizer to create and use an index on that expression, if possible.
            In fact, hints are removed from the expression before it is executed.</para>
        <para>
          <b>See Also:</b>
          <span style="C1H Jump">How to create indexes</span>.</para>
      </remarks>
    </member>
    <member name="M:C1.LiveLinq.Hints.Indexed``1(``0)">
      <summary>
            A hint with default action.
            </summary>
      <typeparam name="T">This can be any type, because hints are applicable to expressions of any type.</typeparam>
      <param name="value">The value of the expression the hint is applied to. This value is not actually used by the hint,
            because the hint is never executed, its role is purely declarative.</param>
      <returns>Formally, the hint returns the same value that it receives in the parameter. In fact, it is never executed,
            its role is purely declarative.</returns>
      <remarks>
        <para>Current default action is defined by the value of the static <see cref="P:C1.LiveLinq.Hints.DefaultAction" /> property.
            By default, it is <see cref="T:C1.LiveLinq.IndexingHintAction" />.<b>Optional</b>.</para>
        <para>Use the other <b>Indexed</b> overload if you need a hint with non-default action.</para>
        <para>A hint does not change the value of the expression it is applied to.
            It only tells LiveLinq query optimizer to create and use an index on that expression, if possible.
            In fact, hints are removed from the expression before it is executed.</para>
        <para>
          <b>See Also:</b>
          <span style="C1H Jump">How to create indexes</span>.</para>
      </remarks>
    </member>
    <member name="P:C1.LiveLinq.Hints.DefaultAction">
      <summary>
            Gets or sets the default action for indexing hints.
            </summary>
      <remarks>
            The default is <see cref="T:C1.LiveLinq.IndexingHintAction" />.<b>Optional</b>. This setting
            is global for the application. If you want to change it, do it at application startup.
            </remarks>
    </member>
    <member name="T:C1.LiveLinq.IndexingHintAction">
      <summary>
            Specifies the actions taken by LiveLinq query optimizer when it encounters an 
            <b>Indexed()</b> hint applied to an expression (usually, a property) in a query.
            </summary>
    </member>
    <member name="F:C1.LiveLinq.IndexingHintAction.Mandatory">
      <summary>
            Create an index for this expression, if such index does not already exist.
            Use this index in executing the query (perform an index scan using that index).
            Throw an exception if it is impossible to use it in query execution.
            </summary>
    </member>
    <member name="F:C1.LiveLinq.IndexingHintAction.Optional">
      <summary>
            Create an index for this expression, if such index does not already exist.
            Use this index in executing the query, if it is possible.
            Do not throw exception if it is impossible to use that index in query execution.
            </summary>
    </member>
    <member name="F:C1.LiveLinq.IndexingHintAction.UseExistingIndex">
      <summary>
            Check that there exists an index for this expression. If it does not exist, throw an exception.
            Use this index in executing the query. Throw an exception if it 
            is impossible to use this index in query execution.
            </summary>
    </member>
    <member name="T:C1.LiveLinq.Indexing.IndexingException">
      <summary>Represents an exception that is thrown when errors are generated using LiveLinq components.</summary>
    </member>
    <member name="M:C1.LiveLinq.Indexing.IndexingException.#ctor">
      <summary>Initializes a new instance of the <see cref="T:C1.LiveLinq.Indexing.IndexingException" /> class. This is the default constructor.</summary>
    </member>
    <member name="M:C1.LiveLinq.Indexing.IndexingException.#ctor(System.String)">
      <summary>Initializes a new instance of the <see cref="T:C1.LiveLinq.Indexing.IndexingException" /> class with the specified string.</summary>
      <param name="message">The string to display when the exception is thrown.</param>
    </member>
    <member name="M:C1.LiveLinq.Indexing.IndexingException.#ctor(System.String,System.Exception)">
      <summary>Initializes a new instance of the <see cref="T:C1.LiveLinq.Indexing.IndexingException" /> class with the specified string and inner exception.</summary>
      <param name="message">The string to display when the exception is thrown.</param>
      <param name="inner">A reference to an inner exception.</param>
    </member>
    <member name="M:C1.LiveLinq.Indexing.IndexingException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>Initializes a new instance of the <see cref="T:C1.LiveLinq.Indexing.IndexingException" /> class with the specified serialization information and context.</summary>
      <param name="info">The data necessary to serialize or deserialize an object.</param>
      <param name="context">Description of the source and destination of the specified serialized stream.</param>
    </member>
    <member name="T:C1.LiveLinq.Indexing.IndexCollection`1">
      <summary>Represents a collection of indexes attached to an indexed collection.</summary>
      <remarks>
            Any indexed collection (implementing the <see cref="T:C1.LiveLinq.Indexing.IIndexedSource`1" /> interface) has a 
            collection of indexes attached to it.
            </remarks>
      <typeparam name="T">The type of the elements of the indexed collection.</typeparam>
      <seealso cref="P:C1.LiveLinq.Indexing.IIndexedSource`1.Indexes" />
      <seealso cref="P:C1.LiveLinq.Collections.IndexedCollection`1.Indexes" />
      <seealso cref="P:C1.LiveLinq.AdoNet.IndexedDataTable`1.Indexes" />
      <seealso cref="P:C1.LiveLinq.LiveViews.View`1.Indexes" />
      <seealso cref="P:C1.LiveLinq.LiveViews.ViewRowCollection.Indexes" />
    </member>
    <member name="M:C1.LiveLinq.Indexing.IndexCollection`1.#ctor(C1.LiveLinq.IObservableSource{`0})">
      <summary>Initializes a new instance of the <see cref="T:C1.LiveLinq.Indexing.IndexCollection`1" /> class.</summary>
      <param name="source">The collection to be indexed.</param>
      <remarks>
            Normally, you don't need to create instances of the <see cref="T:C1.LiveLinq.Indexing.IndexCollection`1" /> class in your code,
            they already exist in the instances of LiveLinq indexed collection classes.
            You need to create them explicitly in code only if you define your own indexable collection class and then only if
            it does not inherit from <see cref="T:C1.LiveLinq.Collections.IndexedCollection`1" />.
            </remarks>
    </member>
    <member name="M:C1.LiveLinq.Indexing.IndexCollection`1.Add``1(System.Linq.Expressions.Expression{System.Func{`0,``0}})">
      <summary>Creates a new index and adds it to the collection of indexes.</summary>
      <typeparam name="TKey">The type of the index key.</typeparam>
      <param name="keySelector">Key selector expression of the index, see <see cref="P:C1.LiveLinq.Indexing.IndexDefinition`1.KeySelector" />.</param>
      <returns>The new index added to the collection of indexes.</returns>
    </member>
    <member name="M:C1.LiveLinq.Indexing.IndexCollection`1.Add``1(System.Linq.Expressions.Expression{System.Func{`0,``0}},System.Boolean)">
      <summary>Creates a new index and adds it to the collection of indexes.</summary>
      <typeparam name="TKey">The type of the index key.</typeparam>
      <param name="keySelector">Key selector expression of the index, see <see cref="P:C1.LiveLinq.Indexing.IndexDefinition`1.KeySelector" />.</param>
      <param name="keyIsUnque">
        <b>true</b> if a unique index must be created.</param>
      <returns>The new index added to the collection of indexes.</returns>
      <remarks>
        <para>A unique index occupies less memory and performs better than a non-unique index (although the difference isn't dramatic).
            Therefore, for unique keys, it's recommended to specify the corresponding index as unique.</para>
        <para>But do that only if you are sure that the key is indeed unique, as it imposes a uniqueness constraint on the indexed collection.
            An attempt to modify the indexed collection violating the uniqueness throws an <see cref="T:System.InvalidOperationException" />.</para>
      </remarks>
    </member>
    <member name="M:C1.LiveLinq.Indexing.IndexCollection`1.Remove(System.Linq.Expressions.LambdaExpression)">
      <summary>Removes an index from the collection.</summary>
      <param name="keySelector">Key selector expression of an index, see <see cref="P:C1.LiveLinq.Indexing.IndexDefinition`1.KeySelector" />.</param>
      <returns>
        <b>true</b> if an index has been removed; <b>false</b> if there is no index with the given key selector in the collection.</returns>
    </member>
    <member name="M:C1.LiveLinq.Indexing.IndexCollection`1.Remove(C1.LiveLinq.Indexing.Index{`0})">
      <summary>Removes an index from the collection.</summary>
      <param name="index">The index to remove.</param>
      <returns>
        <b>true</b> if an index has been removed; <b>false</b> if the index does not belong to this collection.</returns>
    </member>
    <member name="M:C1.LiveLinq.Indexing.IndexCollection`1.Find(System.Linq.Expressions.LambdaExpression)">
      <summary>Finds an index in the collection by its key selector.</summary>
      <param name="keySelector">Key selector expression of an index, see <see cref="P:C1.LiveLinq.Indexing.IndexDefinition`1.KeySelector" />.</param>
      <returns>An index with the given key selector, if it is found; otherwise, <b>null</b>.</returns>
    </member>
    <member name="M:C1.LiveLinq.Indexing.IndexCollection`1.Find``1(System.Linq.Expressions.Expression{System.Func{`0,``0}})">
      <summary>Finds an index in the collection by its key selector.</summary>
      <typeparam name="TKey">The type of the index key.</typeparam>
      <param name="keySelector">Key selector expression of an index, see <see cref="P:C1.LiveLinq.Indexing.IndexDefinition`1.KeySelector" />.</param>
      <returns>An index with the given key selector, if it is found; otherwise, <b>null</b>.</returns>
    </member>
    <member name="M:C1.LiveLinq.Indexing.IndexCollection`1.Clear">
      <summary>Clears the collection of all indexes. All indexes are detached from the indexed collection and destroyed.</summary>
    </member>
    <member name="M:C1.LiveLinq.Indexing.IndexCollection`1.GetEnumerator">
      <summary>Returns an enumerator that iterates through the <see cref="T:C1.LiveLinq.Indexing.IndexCollection`1" />.</summary>
    </member>
    <member name="P:C1.LiveLinq.Indexing.IndexCollection`1.Count">
      <summary>Gets the number of indexes in the collection.</summary>
      <value>The number of indexes in the collection.</value>
    </member>
    <member name="P:C1.LiveLinq.Indexing.IndexCollection`1.Item(System.Linq.Expressions.LambdaExpression)">
      <summary>Gets the index with the specified key selector.</summary>
      <param name="key">Key selector expression of an index, see <see cref="P:C1.LiveLinq.Indexing.IndexDefinition`1.KeySelector" />.</param>
    </member>
    <member name="T:C1.LiveLinq.Indexing.SubindexCollection`1">
      <summary>Represents a collection of subindexes attached to an <see cref="T:C1.LiveLinq.Indexing.IndexDefinition`1" />.</summary>
      <typeparam name="T">The type of the elements of the collection to index.</typeparam>
      <remarks>
        <para>A <see cref="T:C1.LiveLinq.Indexing.Subindex`2" /> is attached to its parent index definition, which is an <see cref="T:C1.LiveLinq.Indexing.Index`2" />
            or another <see cref="T:C1.LiveLinq.Indexing.Subindex`2" />. The subindexes collection is stored in the parent's <see cref="P:C1.LiveLinq.Indexing.IndexDefinition`1.Subindexes" /> property.</para>
        <para>Subindexes are optional, not required for any indexing tasks, but can provide additional optimization and help minimize memory requirements when a collection is indexed by multi-level (multi-field) keys.</para>
      </remarks>
    </member>
    <member name="M:C1.LiveLinq.Indexing.SubindexCollection`1.Add``1(System.Linq.Expressions.Expression{System.Func{`0,``0}},System.Boolean,System.Boolean,C1.LiveLinq.Indexing.IndexingAlgorithm,System.Globalization.CultureInfo)">
      <summary>Creates a new subindex and attaches it to its parent's <see cref="P:C1.LiveLinq.Indexing.IndexDefinition`1.Subindexes" /> collection.</summary>
      <typeparam name="TKey">The type of the subindex key.</typeparam>
      <param name="keySelector">Key selector expression of the subindex, see <see cref="P:C1.LiveLinq.Indexing.IndexDefinition`1.KeySelector" />.</param>
      <param name="keyIsUnique">Specifies whether the key used in this subindex is unique for any given value of the parent key (default: <b>false</b>).</param>
      <param name="onlyOnce">Specifies whether it is required that the subindex does not exist prior to this method call (default: <b>false</b>).
            If a subindex with this <i>keySelector</i> already exists, an exception is thrown if it is <b>true</b>,
            and this method call is ignored if it is <b>false</b>.</param>
      <param name="algorithm">An <see cref="T:C1.LiveLinq.Indexing.IndexingAlgorithm" /> used by the subindex. In the current version, only one algorithm 
            is supported, RedBlackTree. Later versions may support other algorithms, such as bitmap or hash indexing.</param>
      <param name="locale">Locale information used to compare strings in the subindex (default: <see cref="P:System.Globalization.CultureInfo.CurrentCulture">CultureInfo.CurrentCulture</see>).</param>
      <returns>The new subindex added to its parent's <see cref="P:C1.LiveLinq.Indexing.IndexDefinition`1.Subindexes" /> collection.</returns>
      <remarks>
        <para>A unique index occupies less memory and performs better than a non-unique index (although the difference isn't dramatic).
            Therefore, for unique keys, it's recommended to specify the corresponding index as unique.</para>
        <para>But do that only if you are sure that the key is indeed unique, as it imposes a uniqueness constraint on the indexed collection.
            An attempt to modify the indexed collection violating the uniqueness throws an <see cref="T:System.InvalidOperationException" />.</para>
        <para>For a subindex, uniqueness means that any given pair of parent key and subindex key values uniquely determines an item in the indexed collection.</para>
      </remarks>
    </member>
    <member name="M:C1.LiveLinq.Indexing.SubindexCollection`1.Add``1(System.Linq.Expressions.Expression{System.Func{`0,``0}},System.Boolean,System.Boolean,System.Globalization.CultureInfo)">
      <summary>Creates a new subindex and attaches it to its parent's <see cref="P:C1.LiveLinq.Indexing.IndexDefinition`1.Subindexes" /> collection.</summary>
      <typeparam name="TKey">The type of the subindex key.</typeparam>
      <param name="keySelector">Key selector expression of the subindex, see <see cref="P:C1.LiveLinq.Indexing.IndexDefinition`1.KeySelector" />.</param>
      <param name="keyIsUnique">Specifies whether the key used in this subindex is unique for any given value of the parent key (default: <b>false</b>).</param>
      <param name="onlyOnce">Specifies whether it is required that the subindex does not exist prior to this method call (default: <b>false</b>).
            If a subindex with this <i>keySelector</i> already exists, an exception is thrown if it is <b>true</b>,
            and this method call is ignored if it is <b>false</b>.</param>
      <param name="locale">Locale information used to compare strings in the subindex (default: <see cref="P:System.Globalization.CultureInfo.CurrentCulture">CultureInfo.CurrentCulture</see>).</param>
      <returns>The new subindex added to its parent's <see cref="P:C1.LiveLinq.Indexing.IndexDefinition`1.Subindexes" /> collection.</returns>
      <remarks>
        <para>A unique index occupies less memory and performs better than a non-unique index (although the difference isn't dramatic).
            Therefore, for unique keys, it's recommended to specify the corresponding index as unique.</para>
        <para>But do that only if you are sure that the key is indeed unique, as it imposes a uniqueness constraint on the indexed collection.
            An attempt to modify the indexed collection violating the uniqueness throws an <see cref="T:System.InvalidOperationException" />.</para>
        <para>For a subindex, uniqueness means that any given pair of parent key and subindex key values uniquely determines an item in the indexed collection.</para>
      </remarks>
    </member>
    <member name="M:C1.LiveLinq.Indexing.SubindexCollection`1.Add``1(System.Linq.Expressions.Expression{System.Func{`0,``0}},System.Boolean,System.Boolean)">
      <summary>Creates a new subindex and attaches it to its parent's <see cref="P:C1.LiveLinq.Indexing.IndexDefinition`1.Subindexes" /> collection.</summary>
      <typeparam name="TKey">The type of the subindex key.</typeparam>
      <param name="keySelector">Key selector expression of the subindex, see <see cref="P:C1.LiveLinq.Indexing.IndexDefinition`1.KeySelector" />.</param>
      <param name="keyIsUnique">Specifies whether the key used in this subindex is unique for any given value of the parent key (default: <b>false</b>).</param>
      <param name="onlyOnce">Specifies whether it is required that the subindex does not exist prior to this method call (default: <b>false</b>).
            If a subindex with this <i>keySelector</i> already exists, an exception is thrown if it is <b>true</b>,
            and this method call is ignored if it is <b>false</b>.</param>
      <returns>The new subindex added to its parent's <see cref="P:C1.LiveLinq.Indexing.IndexDefinition`1.Subindexes" /> collection.</returns>
      <remarks>
        <para>A unique index occupies less memory and performs better than a non-unique index (although the difference isn't dramatic).
            Therefore, for unique keys, it's recommended to specify the corresponding index as unique.</para>
        <para>But do that only if you are sure that the key is indeed unique, as it imposes a uniqueness constraint on the indexed collection.
            An attempt to modify the indexed collection violating the uniqueness throws an <see cref="T:System.InvalidOperationException" />.</para>
        <para>For a subindex, uniqueness means that any given pair of parent key and subindex key values uniquely determines an item in the indexed collection.</para>
      </remarks>
    </member>
    <member name="M:C1.LiveLinq.Indexing.SubindexCollection`1.Add``1(System.Linq.Expressions.Expression{System.Func{`0,``0}},System.Boolean)">
      <summary>Creates a new subindex and attaches it to its parent's <see cref="P:C1.LiveLinq.Indexing.IndexDefinition`1.Subindexes" /> collection.</summary>
      <typeparam name="TKey">The type of the subindex key.</typeparam>
      <param name="keySelector">Key selector expression of the subindex, see <see cref="P:C1.LiveLinq.Indexing.IndexDefinition`1.KeySelector" />.</param>
      <param name="keyIsUnique">Specifies whether the key used in this subindex is unique for any given value of the parent key (default: <b>false</b>).</param>
      <returns>The new subindex added to its parent's <see cref="P:C1.LiveLinq.Indexing.IndexDefinition`1.Subindexes" /> collection.</returns>
      <remarks>
        <para>A unique index occupies less memory and performs better than a non-unique index (although the difference isn't dramatic).
            Therefore, for unique keys, it's recommended to specify the corresponding index as unique.</para>
        <para>But do that only if you are sure that the key is indeed unique, as it imposes a uniqueness constraint on the indexed collection.
            An attempt to modify the indexed collection violating the uniqueness throws an <see cref="T:System.InvalidOperationException" />.</para>
        <para>For a subindex, uniqueness means that any given pair of parent key and subindex key values uniquely determines an item in the indexed collection.</para>
      </remarks>
    </member>
    <member name="M:C1.LiveLinq.Indexing.SubindexCollection`1.Add``1(System.Linq.Expressions.Expression{System.Func{`0,``0}})">
      <summary>Creates a new subindex and attaches it to its parent's <see cref="P:C1.LiveLinq.Indexing.IndexDefinition`1.Subindexes" /> collection.</summary>
      <typeparam name="TKey">The type of the subindex key.</typeparam>
      <param name="keySelector">Key selector expression of the subindex, see <see cref="P:C1.LiveLinq.Indexing.IndexDefinition`1.KeySelector" />.</param>
      <returns>The new subindex added to its parent's <see cref="P:C1.LiveLinq.Indexing.IndexDefinition`1.Subindexes" /> collection.</returns>
    </member>
    <member name="M:C1.LiveLinq.Indexing.SubindexCollection`1.Add(System.Linq.Expressions.LambdaExpression,System.Boolean,System.Boolean,C1.LiveLinq.Indexing.IndexingAlgorithm,System.Globalization.CultureInfo)">
      <summary>Creates a new subindex and attaches it to its parent's <see cref="P:C1.LiveLinq.Indexing.IndexDefinition`1.Subindexes" /> collection.</summary>
      <param name="keySelector">Key selector expression of the subindex, see <see cref="P:C1.LiveLinq.Indexing.IndexDefinition`1.KeySelector" />.</param>
      <param name="keyIsUnique">Specifies whether the key used in this subindex is unique for any given value of the parent key (default: <b>false</b>).</param>
      <param name="onlyOnce">Specifies whether it is required that the subindex does not exist prior to this method call.
            If a subindex with this <i>keySelector</i> already exists, an exception is thrown if it is <b>true</b>,
            and this method call is ignored if it is <b>false</b>.</param>
      <param name="algorithm">An <see cref="T:C1.LiveLinq.Indexing.IndexingAlgorithm" /> used by the subindex. In the current version, only one algorithm 
            is supported, RedBlackTree. Later versions may support other algorithms, such as bitmap or hash indexing.</param>
      <param name="locale">Locale information used to compare strings in the subindex (default: <see cref="P:System.Globalization.CultureInfo.CurrentCulture">CultureInfo.CurrentCulture</see>).</param>
      <returns>The new subindex added to its parent's <see cref="P:C1.LiveLinq.Indexing.IndexDefinition`1.Subindexes" /> collection.</returns>
      <remarks>
        <para>A unique index occupies less memory and performs better than a non-unique index (although the difference isn't dramatic).
            Therefore, for unique keys, it's recommended to specify the corresponding index as unique.</para>
        <para>But do that only if you are sure that the key is indeed unique, as it imposes a uniqueness constraint on the indexed collection.
            An attempt to modify the indexed collection violating the uniqueness throws an <see cref="T:System.InvalidOperationException" />.</para>
        <para>For a subindex, uniqueness means that any given pair of parent key and subindex key values uniquely determines an item in the indexed collection.</para>
      </remarks>
    </member>
    <member name="M:C1.LiveLinq.Indexing.SubindexCollection`1.Remove(C1.LiveLinq.Indexing.Subindex{`0})">
      <summary>Removes a subindex from the collection.</summary>
      <param name="definition">The subindex to remove.</param>
      <returns>
        <b>true</b> if a subindex has been removed; <b>false</b> if the subindex does not belong to this collection.</returns>
    </member>
    <member name="M:C1.LiveLinq.Indexing.SubindexCollection`1.Remove(System.Linq.Expressions.LambdaExpression)">
      <summary>Removes a subindex from the collection.</summary>
      <param name="keySelector">Key selector expression of a subindex, see <see cref="P:C1.LiveLinq.Indexing.IndexDefinition`1.KeySelector" />.</param>
      <returns>
        <b>true</b> if a subindex has been removed; <b>false</b> if there is no subindex with the given key selector in the collection.</returns>
    </member>
    <member name="M:C1.LiveLinq.Indexing.SubindexCollection`1.Find``1(System.Linq.Expressions.Expression{System.Func{`0,``0}})">
      <summary>Finds a subindex in the collection by its key selector.</summary>
      <typeparam name="TKey">The type of the subindex key.</typeparam>
      <param name="keySelector">Key selector expression of an subindex, see <see cref="P:C1.LiveLinq.Indexing.IndexDefinition`1.KeySelector" />.</param>
      <returns>A subindex with the given key selector, if it is found; otherwise, <b>null</b>.</returns>
    </member>
    <member name="M:C1.LiveLinq.Indexing.SubindexCollection`1.Find(System.Linq.Expressions.LambdaExpression)">
      <summary>Finds a subindex in the collection by its key selector.</summary>
      <param name="keySelector">Key selector expression of an subindex, see <see cref="P:C1.LiveLinq.Indexing.IndexDefinition`1.KeySelector" />.</param>
      <returns>A subindex with the given key selector, if it is found; otherwise, <b>null</b>.</returns>
    </member>
    <member name="M:C1.LiveLinq.Indexing.SubindexCollection`1.Contains(System.Linq.Expressions.LambdaExpression)">
      <summary>Determines whether a subindex with the specified key selector exists in the collection.</summary>
      <param name="keySelector">Key selector expression of a subindex, see <see cref="P:C1.LiveLinq.Indexing.IndexDefinition`1.KeySelector" />.</param>
      <returns>
        <b>true</b> if a subindex with the specified key selector is found in the collection; otherwise, <b>false</b>.</returns>
    </member>
    <member name="M:C1.LiveLinq.Indexing.SubindexCollection`1.Contains``1(System.Linq.Expressions.Expression{System.Func{`0,``0}})">
      <summary>Determines whether a subindex with the specified key selector exists in the collection.</summary>
      <typeparam name="TKey">The type of the subindex key.</typeparam>
      <param name="keySelector">Key selector expression of a subindex, see <see cref="P:C1.LiveLinq.Indexing.IndexDefinition`1.KeySelector" />.</param>
      <returns>
        <b>true</b> if a subindex with the specified key selector is found in the collection; otherwise, <b>false</b>.</returns>
    </member>
    <member name="M:C1.LiveLinq.Indexing.SubindexCollection`1.Clear">
      <summary>Clears the collection of all subindexes. All subindexes are detached from the parent and destroyed.</summary>
    </member>
    <member name="M:C1.LiveLinq.Indexing.SubindexCollection`1.GetEnumerator">
      <summary>Returns an enumerator that iterates through the <see cref="T:C1.LiveLinq.Indexing.SubindexCollection`1" />.</summary>
    </member>
    <member name="P:C1.LiveLinq.Indexing.SubindexCollection`1.Count">
      <summary>Gets the number of subindexes in the collection.</summary>
      <value>The number of subindexes in the collection.</value>
    </member>
    <member name="P:C1.LiveLinq.Indexing.SubindexCollection`1.Item(System.Int32)">
      <summary>Gets the subindex object at the specified ordinal position in the collection.</summary>
      <param name="ordinal">The zero-based ordinal position of the subindex to find</param>
    </member>
    <member name="T:C1.LiveLinq.Indexing.IndexingAlgorithm">
      <summary>Defines the kind of an index, the algorithm used by that index. Currently, the RedBlackTree algorithm is always used.</summary>
      <remarks>In the current version, only one algorithm is supported, RedBlackTree. 
            Later versions may support other algorithms, such as bitmap or hash indexing.</remarks>
    </member>
    <member name="F:C1.LiveLinq.Indexing.IndexingAlgorithm.RedBlackTree">
      <summary>
            The red-black tree algorithm, a type of self-balancing binary search tree widely 
            used in computer science because it has good performance that does not significantly degrade even in worst cases. 
            </summary>
    </member>
    <member name="M:C1.LiveLinq.Indexing.IndexingAlgorithm.CreateIndex``2(C1.LiveLinq.IObservableSource{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Boolean,System.Globalization.CultureInfo)">
      <summary>Creates a new index.</summary>
      <typeparam name="T">The type of the elements of the collection to index.</typeparam>
      <typeparam name="TKey">The type of the index key.</typeparam>
      <param name="source">The collection to be indexed.</param>
      <param name="keySelector">Key selector expression of the index, see <see cref="P:C1.LiveLinq.Indexing.IndexDefinition`1.KeySelector" />.</param>
      <param name="keyIsUnique">Specifies whether the key used in this index is a unique key for the indexed collection.</param>
      <param name="locale">Locale information used to compare strings in the index (default: <see cref="P:System.Globalization.CultureInfo.CurrentCulture">CultureInfo.CurrentCulture</see>).</param>
      <returns>The new index.</returns>
      <remarks>
        <para>Normally, you don't need to use this method. Indexes are usually created in code by calling 
            <see cref="M:C1.LiveLinq.Indexing.IndexCollection`1.Add``1(System.Linq.Expressions.Expression{System.Func{`0,``0}})">IndexCollection.Add</see>, or their creation
            can be enforced in LINQ queries by using the <see cref="M:C1.LiveLinq.Hints.Indexed``1(``0,C1.LiveLinq.IndexingHintAction)">Indexed</see> hint.
            This method should be used only in special situations where all you want is to index a collection without an overhead of maintaining a collection of indexes,
            or you need an index that exists separately from the collection of indexes maintained by the source.
            Unlike the standard ways of creating indexes, this method only creates an index object and attaches it to the source
            (so it will be automatically synchronized with the source when the source is modified), but the created index is 
            not added to <see cref="T:C1.LiveLinq.Indexing.IndexCollection`1" />.</para>
        <para>A unique index occupies less memory and performs better than a non-unique index (although the difference isn't dramatic).
            Therefore, for unique keys, it's recommended to specify the corresponding index as unique.
            But do that only if you are sure that the key is indeed unique, as it imposes a uniqueness constraint on the indexed collection.
            An attempt to modify the indexed collection violating the uniqueness throws an <see cref="T:System.InvalidOperationException" />.</para>
      </remarks>
    </member>
    <member name="T:C1.LiveLinq.LiveViews.ViewOrder">
      <summary>
            Specifies whether and how a view must preserve item order if it exists in the source. 
            </summary>
    </member>
    <member name="F:C1.LiveLinq.LiveViews.ViewOrder.Preserved">
      <summary>
            Source order is preserved completely. Order of items in the view is always the 
            same as in the source (if source has a particular order),
            even after the view is maintained to reflect changes that occurred in the source.
            </summary>
    </member>
    <member name="F:C1.LiveLinq.LiveViews.ViewOrder.PartiallyPreserved">
      <summary>
            Source order is partially preserved. When the view is created, it preserves source order,
            but later, when changes occur in the source, view items added or modified to reflect those changes
            aren't guaranteed to appear at the same order position in the view as in the source.
            </summary>
    </member>
    <member name="F:C1.LiveLinq.LiveViews.ViewOrder.NotPreserved">
      <summary>
            Source order is not preserved. Preserving source order is not guaranteed even at view creation.
            </summary>
    </member>
    <member name="T:C1.LiveLinq.Ordering`1">
      <summary>Represents a sorted <see cref="T:C1.LiveLinq.Indexing.IIndexedSource`1" />.</summary>
      <typeparam name="T">The type of the elements of the collection.</typeparam>
      <remarks>
            An <b>Ordering&lt;T&gt;</b> can be obtained as a result of an <see cref="M:C1.LiveLinq.IndexedQueryExtensions.OrderBy``2(C1.LiveLinq.Indexing.IIndexedSource{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}})">OrderBy</see>
            or <see cref="M:C1.LiveLinq.IndexedQueryExtensions.OrderByDescending``2(C1.LiveLinq.Indexing.IIndexedSource{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}})">OrderByDescending</see> query operator.
            Query operators (extension methods) <see cref="M:C1.LiveLinq.Ordering`1.ThenBy``1(System.Linq.Expressions.Expression{System.Func{`0,``0}})">ThenBy</see> and
            <see cref="M:C1.LiveLinq.Ordering`1.ThenByDescending``1(System.Linq.Expressions.Expression{System.Func{`0,``0}})">ThenByDescending</see> operate on objects
            of type <b>Ordering&lt;T&gt;</b>.
            </remarks>
    </member>
    <member name="M:C1.LiveLinq.Ordering`1.GetEnumerator">
      <summary>Returns an enumerator that iterates through the <see cref="T:C1.LiveLinq.Ordering`1" />.</summary>
    </member>
    <member name="M:C1.LiveLinq.Ordering`1.ThenBy``1(System.Linq.Expressions.Expression{System.Func{`0,``0}})">
      <summary>Performs a subsequent ordering of the elements in a collection in ascending order according to a key.</summary>
      <typeparam name="TKey">The type of the key returned by <i>keySelector</i>.</typeparam>
      <param name="keySelector">A function to extract a key from each element.</param>
      <returns>A collection whose elements are sorted according to a key.</returns>
    </member>
    <member name="M:C1.LiveLinq.Ordering`1.ThenByDescending``1(System.Linq.Expressions.Expression{System.Func{`0,``0}})">
      <summary>Performs a subsequent ordering of the elements in a collection in descending order according to a key.</summary>
      <typeparam name="TKey">The type of the key returned by <i>keySelector</i>.</typeparam>
      <param name="keySelector">A function to extract a key from each element.</param>
      <returns>A collection whose elements are sorted in descending order according to a key.</returns>
    </member>
    <member name="T:C1.LiveLinq.Order">
      <summary>Indicates if a certain order is required in the result collection of an operation.</summary>
    </member>
    <member name="F:C1.LiveLinq.Order.Unordered">
      <summary>No particular order is required in the resulting collection.</summary>
    </member>
    <member name="F:C1.LiveLinq.Order.Ascending">
      <summary>The resulting collection must be ordered in ascending key order.</summary>
    </member>
    <member name="F:C1.LiveLinq.Order.Descending">
      <summary>The resulting collection must be ordered in descending key order.</summary>
    </member>
    <member name="T:C1.WPF.LiveLinq.WpfExtensions">
      <summary>
            Provides a set of static (extension) methods for <see cref="T:System.Collections.Specialized.INotifyCollectionChanged" />
            and <see cref="T:System.Collections.ObjectModel.ObservableCollection`1" /> types (specific to WPF).
            </summary>
    </member>
    <member name="M:C1.WPF.LiveLinq.WpfExtensions.ToIndexed``1(System.Collections.Specialized.INotifyCollectionChanged)">
      <summary>Creates an <see cref="T:C1.LiveLinq.Collections.IndexedCollection`1" /> based on the specified <see cref="T:System.Collections.Specialized.INotifyCollectionChanged" /> data source.</summary>
      <typeparam name="T">The type of the elements in the collection.</typeparam>
      <param name="source">An <see cref="T:System.Collections.Specialized.INotifyCollectionChanged" /> data source to represent as an <see cref="T:C1.LiveLinq.Collections.IndexedCollection`1" />.</param>
      <returns>An <see cref="T:C1.LiveLinq.Collections.IndexedCollection`1" /> that contains the same elements as the <see cref="T:System.Collections.Specialized.INotifyCollectionChanged" />
            and enables indexing of that data source.</returns>
      <remarks>
        <para>Use this method to index and query your existing data sources implementing <see cref="T:System.Collections.Specialized.INotifyCollectionChanged" />.
            The element type of this data source must implement <see cref="T:System.ComponentModel.INotifyPropertyChanged" />,
            see <span style="C1H Jump">Using the built-in collection class IndexedCollection(T) (LiveLinq to Objects)|tag=Using_the_built_in_collection_class_IndexedCollectionT_LiveLinq_to_Objects</span>.</para>
        <para> The collection returned by this method also implements the <see cref="T:System.Collections.Specialized.INotifyCollectionChanged" /> interface,
            because this method actually returns objects of an internal derived class that implements that interface.</para>
        <para>
          <b>Note: </b>Indexes created on the resulting  <see cref="T:C1.LiveLinq.Collections.IndexedCollection`1" /> are owned by it
            and not by the original data source. Every <b>ToIndexed()</b> call creates a separate object that
            has its own separate indexes. Avoid calling <b>ToIndexed()</b> repeatedly 
            for the same collection because it can increase the cost of maintaining indexes.</para>
      </remarks>
    </member>
    <member name="M:C1.WPF.LiveLinq.WpfExtensions.ToIndexed``1(System.Collections.ObjectModel.ObservableCollection{``0})">
      <summary>A typed specialization of the <see cref="M:C1.WPF.LiveLinq.WpfExtensions.ToIndexed``1(System.Collections.Specialized.INotifyCollectionChanged)" /> method.</summary>
      <typeparam name="T">The type of the elements in the collection.</typeparam>
      <param name="source">An <see cref="T:System.Collections.ObjectModel.ObservableCollection`1" />  represent as an <see cref="T:C1.LiveLinq.Collections.IndexedCollection`1" />.</param>
      <returns>An <see cref="T:C1.LiveLinq.Collections.IndexedCollection`1" /> that contains the same elements as the <see cref="T:System.Collections.ObjectModel.ObservableCollection`1" />
            and enables indexing of that collection.</returns>
    </member>
    <member name="M:C1.WPF.LiveLinq.WpfExtensions.AsLive``1(System.Collections.Specialized.INotifyCollectionChanged)">
      <summary>Creates a view based on the specified <see cref="T:System.Collections.Specialized.INotifyCollectionChanged" /> data source.</summary>
      <typeparam name="T">The type of the elements in the view.</typeparam>
      <param name="source">The <see cref="T:System.Collections.Specialized.INotifyCollectionChanged" /> data source to expose as a view.</param>
      <returns>A view that contains the same elements as the <see cref="T:System.Collections.Specialized.INotifyCollectionChanged" /> data source.</returns>
      <remarks>
        <para>Use this method to build views from existing data sources implementing <see cref="T:System.Collections.Specialized.INotifyCollectionChanged" />.
            The element type of this data source must implement <see cref="T:System.ComponentModel.INotifyPropertyChanged" />,
            see <span style="C1H Jump">Using the built-in collection class IndexedCollection(T) (LiveLinq to Objects)|tag=Using_the_built_in_collection_class_IndexedCollectionT_LiveLinq_to_Objects</span>.</para>
        <para>The resulting view may have its elements ordered differently than they are ordered in the <i>source</i>.
            Correspondingly, views built on this resulting view (for example, if you filter it with <b>Where</b>) will not preserve the source order either.
            If you need to preserve the source order, consider using the other <b>AsLive</b> overload where 
            you can specify to what extent you need the order to be preserved.</para>
      </remarks>
    </member>
    <member name="M:C1.WPF.LiveLinq.WpfExtensions.AsLive``1(System.Collections.Specialized.INotifyCollectionChanged,C1.LiveLinq.LiveViews.ViewOrder)">
      <summary>Creates a view based on the specified <see cref="T:System.Collections.Specialized.INotifyCollectionChanged" /> data source.</summary>
      <typeparam name="T">The type of the elements in the view.</typeparam>
      <param name="source">The <see cref="T:System.Collections.Specialized.INotifyCollectionChanged" /> data source to expose as a view.</param>
      <param name="order">Specifies whether to preserve source item order.</param>
      <returns>A view that contains the same elements as the <see cref="T:System.Collections.Specialized.INotifyCollectionChanged" /> data source.</returns>
      <remarks>
        <para>Use this method to build views from existing data sources implementing <see cref="T:System.Collections.Specialized.INotifyCollectionChanged" />.
            The element type of this data source must implement <see cref="T:System.ComponentModel.INotifyPropertyChanged" />,
            see <span style="C1H Jump">Using the built-in collection class IndexedCollection(T) (LiveLinq to Objects)|tag=Using_the_built_in_collection_class_IndexedCollectionT_LiveLinq_to_Objects</span>.</para>
        <para>If the <i>order</i> parameter specifies preserving item order, the order of items in the source is preserved,
            at a certain performance cost, in the resulting view and in views based on it (for example, if you filter it with <b>Where</b>).</para>
        <para>Note that <b>Join</b> does not preserve source order. If you need to order a join result, use <b>OrderBy</b> after <b>Join</b>.</para>
      </remarks>
    </member>
    <member name="M:C1.WPF.LiveLinq.WpfExtensions.AsLive``1(System.Collections.ObjectModel.ObservableCollection{``0})">
      <summary>A typed specialization of the <see cref="M:C1.WPF.LiveLinq.WpfExtensions.AsLive``1(System.Collections.Specialized.INotifyCollectionChanged)" /> method.</summary>
      <typeparam name="T">The type of the elements in the view.</typeparam>
      <param name="source">The <see cref="T:System.Collections.ObjectModel.ObservableCollection`1" /> to expose as a view.</param>
      <returns>A view that contains the same elements as the <see cref="T:System.Collections.ObjectModel.ObservableCollection`1" />.</returns>
    </member>
    <member name="M:C1.WPF.LiveLinq.WpfExtensions.AsLive``1(System.Collections.ObjectModel.ObservableCollection{``0},C1.LiveLinq.LiveViews.ViewOrder)">
      <summary>A typed specialization of the <see cref="M:C1.WPF.LiveLinq.WpfExtensions.AsLive``1(System.Collections.Specialized.INotifyCollectionChanged,C1.LiveLinq.LiveViews.ViewOrder)" /> method.</summary>
      <typeparam name="T">The type of the elements in the view.</typeparam>
      <param name="source">The <see cref="T:System.Collections.ObjectModel.ObservableCollection`1" /> to expose as a view.</param>
      <param name="order">Specifies whether to preserve source item order.</param>
      <returns>A view that contains the same elements as the <see cref="T:System.Collections.ObjectModel.ObservableCollection`1" />.</returns>
    </member>
    <member name="M:C1.WPF.LiveLinq.WpfExtensions.AsLive``1(System.Collections.ObjectModel.ReadOnlyObservableCollection{``0})">
      <summary>A typed specialization of the <see cref="M:C1.WPF.LiveLinq.WpfExtensions.AsLive``1(System.Collections.Specialized.INotifyCollectionChanged)" /> method.</summary>
      <typeparam name="T">The type of the elements in the view.</typeparam>
      <param name="source">The <see cref="T:System.Collections.ObjectModel.ReadOnlyObservableCollection`1" /> to expose as a view.</param>
      <returns>A view that contains the same elements as the <see cref="T:System.Collections.ObjectModel.ReadOnlyObservableCollection`1" />.</returns>
    </member>
    <member name="M:C1.WPF.LiveLinq.WpfExtensions.AsLive``1(System.Collections.ObjectModel.ReadOnlyObservableCollection{``0},C1.LiveLinq.LiveViews.ViewOrder)">
      <summary>A typed specialization of the <see cref="M:C1.WPF.LiveLinq.WpfExtensions.AsLive``1(System.Collections.Specialized.INotifyCollectionChanged,C1.LiveLinq.LiveViews.ViewOrder)" /> method.</summary>
      <typeparam name="T">The type of the elements in the view.</typeparam>
      <param name="source">The <see cref="T:System.Collections.ObjectModel.ReadOnlyObservableCollection`1" /> to expose as a view.</param>
      <param name="order">Specifies whether to preserve source item order.</param>
      <returns>A view that contains the same elements as the <see cref="T:System.Collections.ObjectModel.ReadOnlyObservableCollection`1" />.</returns>
    </member>
  </members>
</doc>